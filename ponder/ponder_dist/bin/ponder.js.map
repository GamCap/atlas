{"version":3,"sources":["../../src/bin/ponder.ts","../../src/utils/extend.ts","../../src/build/service.ts","../../src/schema/utils.ts","../../src/server/graphql/buildGraphqlSchema.ts","../../src/server/graphql/entity.ts","../../src/server/graphql/filter.ts","../../src/server/graphql/scalar.ts","../../src/server/graphql/enum.ts","../../src/server/graphql/plural.ts","../../src/server/graphql/singular.ts","../../src/build/configAndIndexingFunctions.ts","../../src/utils/duplicates.ts","../../src/config/abi.ts","../../src/utils/lowercase.ts","../../src/utils/offset.ts","../../src/config/factories.ts","../../src/utils/chains.ts","../../src/config/networks.ts","../../src/config/sources.ts","../../../common/src/promiseWithResolvers.ts","../../../common/src/debounce.ts","../../../common/src/dedupe.ts","../../../common/src/queue.ts","../../src/build/plugin.ts","../../src/build/schema.ts","../../src/build/stacktrace.ts","../../src/build/index.ts","../../src/common/codegen.ts","../../src/common/logger.ts","../../src/common/metrics.ts","../../src/common/options.ts","../../src/common/telemetry.ts","../../src/utils/timer.ts","../../src/utils/wait.ts","../../src/bin/utils/shutdown.ts","../../src/common/errors.ts","../../src/bin/commands/codegen.ts","../../src/bin/commands/dev.ts","../../src/utils/format.ts","../../src/ui/app.tsx","../../src/ui/ProgressBar.tsx","../../src/ui/Table.tsx","../../src/ui/service.ts","../../src/sync-store/postgres/migrations.ts","../../src/utils/checkpoint.ts","../../src/utils/hash.ts","../../src/utils/pg.ts","../../src/utils/print.ts","../../src/database/postgres/service.ts","../../src/database/kysely.ts","../../src/database/revert.ts","../../src/database/postgres/migrations.ts","../../src/database/sqlite/service.ts","../../src/sync-store/sqlite/migrations.ts","../../src/utils/sqlite.ts","../../src/utils/exists.ts","../../src/database/sqlite/migrations.ts","../../src/indexing-store/historical.ts","../../src/utils/encoding.ts","../../src/indexing-store/utils/encoding.ts","../../src/indexing-store/utils/errors.ts","../../src/indexing-store/utils/filter.ts","../../src/indexing-store/readonly.ts","../../src/utils/serialize.ts","../../src/indexing-store/utils/cursor.ts","../../src/indexing-store/utils/sort.ts","../../src/indexing-store/realtime.ts","../../src/utils/never.ts","../../src/indexing/service.ts","../../src/indexing/ponderActions.ts","../../src/indexing/trace.ts","../../src/indexing/index.ts","../../src/server/service.ts","../../src/ui/graphiql.html.ts","../../src/server/graphql/buildLoaderCache.ts","../../src/utils/fragments.ts","../../src/utils/interval.ts","../../src/utils/range.ts","../../src/sync-store/postgres/store.ts","../../src/sync-store/postgres/encoding.ts","../../src/sync-store/sqlite/store.ts","../../src/sync-store/sqlite/encoding.ts","../../src/sync/events.ts","../../src/sync/index.ts","../../src/utils/queue.ts","../../src/sync-historical/service.ts","../../src/sync-historical/validateHistoricalBlockRange.ts","../../src/sync-realtime/service.ts","../../src/sync-realtime/bloom.ts","../../src/sync-realtime/filter.ts","../../src/sync-realtime/format.ts","../../src/sync-realtime/index.ts","../../src/utils/requestQueue.ts","../../src/sync/service.ts","../../src/sync/transport.ts","../../src/bin/utils/run.ts","../../src/bin/commands/serve.ts","../../src/bin/commands/start.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { readFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport { Command } from \"@commander-js/extra-typings\";\nimport dotenv from \"dotenv\";\nimport { codegen } from \"./commands/codegen.js\";\nimport { dev } from \"./commands/dev.js\";\nimport { serve } from \"./commands/serve.js\";\nimport { start } from \"./commands/start.js\";\n\ndotenv.config({ path: \".env.local\" });\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst packageJsonPath = resolve(__dirname, \"../../package.json\");\nconst packageJson = JSON.parse(\n  readFileSync(packageJsonPath, { encoding: \"utf8\" }),\n);\n\nconst ponder = new Command(\"ponder\")\n  .usage(\"<command> [OPTIONS]\")\n  .helpOption(\"-h, --help\", \"Show this help message\")\n  .helpCommand(false)\n  .option(\n    \"--root <PATH>\",\n    \"Path to the project root directory (default: working directory)\",\n  )\n  .option(\n    \"--config <PATH>\",\n    \"Path to the project config file\",\n    \"ponder.config.ts\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug-level logs, e.g. realtime blocks, internal events\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace-level logs, e.g. db queries, indexing checkpoints\",\n  )\n  .version(packageJson.version, \"-V, --version\", \"Show the version number\")\n  .configureHelp({ showGlobalOptions: true })\n  .allowExcessArguments(false)\n  .showHelpAfterError()\n  .enablePositionalOptions(false);\n\ntype GlobalOptions = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n} & ReturnType<typeof ponder.opts>;\n\nconst devCommand = new Command(\"dev\")\n  .description(\"Start the development server with hot reloading\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await dev({ cliOptions });\n  });\n\nconst startCommand = new Command(\"start\")\n  .description(\"Start the production server\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await start({ cliOptions });\n  });\n\nconst serveCommand = new Command(\"serve\")\n  .description(\"Start the production HTTP server without the indexer\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await serve({ cliOptions });\n  });\n\nconst codegenCommand = new Command(\"codegen\")\n  .description(\"Generate the schema.graphql file, then exit\")\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await codegen({ cliOptions });\n  });\n\n// const cache = new Command(\"cache\");\n\n// cache\n//   .command(\"drop\")\n//   .description(\"Dangerously drop all cached RPC data\")\n//   .action(async (_, command) => {\n//     const cliOptions = command.optsWithGlobals() as GlobalOptions &\n//       ReturnType<typeof command.opts>;\n//     console.log(\"ponder db drop\");\n//   });\n\n// ponder.addCommand(cache);\n\n// cli\n//   .command(\"cache prune\", \"Drop stale indexed data tables\")\n//   .action(async (cliOptions: DbOptions) => {\n//     // if (cliOptions.help) process.exit(0);\n//     console.log(\"ponder cache prune\");\n//   });\n\nponder.addCommand(devCommand);\nponder.addCommand(startCommand);\nponder.addCommand(serveCommand);\nponder.addCommand(codegenCommand);\n\nexport type CliOptions = Prettify<\n  GlobalOptions &\n    Partial<\n      ReturnType<typeof devCommand.opts> &\n        ReturnType<typeof startCommand.opts> &\n        ReturnType<typeof serveCommand.opts> &\n        ReturnType<typeof codegenCommand.opts>\n    >\n>;\n\nawait ponder.parseAsync();\n","import type { Prettify } from \"@/types/utils.js\";\n\nexport const extend = <\n  TCreate extends (...params: any[]) => any,\n  TMethods extends { [methodName: string]: (...params: any[]) => unknown },\n>(\n  create: TCreate,\n  _methods: TMethods,\n): ((\n  ...params: Parameters<TCreate>\n) => ReturnType<TCreate> extends Promise<any>\n  ? Promise<Extend<Awaited<ReturnType<TCreate>>, TMethods>>\n  : Extend<ReturnType<TCreate>, TMethods>) => {\n  return (...params: Parameters<TCreate>) => {\n    const service = create(...params);\n\n    if (service instanceof Promise) {\n      return service.then((s) => {\n        const methods: any = {};\n        for (const [methodName, method] of Object.entries(_methods)) {\n          methods[methodName] = (...params: any) => method(s, ...params);\n        }\n\n        return {\n          ...s,\n          ...methods,\n        };\n      });\n    } else {\n      const methods: any = {};\n      for (const [methodName, method] of Object.entries(_methods)) {\n        methods[methodName] = (...params: any) => method(service, ...params);\n      }\n\n      return {\n        ...service,\n        ...methods,\n      };\n    }\n  };\n};\n\nexport type Extend<\n  service,\n  methods extends { [methodName: string]: (...params: any[]) => unknown },\n> = Prettify<\n  service & {\n    [methodName in keyof methods]: Parameters<methods[methodName]> extends [\n      any,\n      ...infer parameters,\n    ]\n      ? (...params: parameters) => ReturnType<methods[methodName]>\n      : never;\n  }\n>;\n","import { createHash } from \"node:crypto\";\nimport { readFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Config, OptionsConfig } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { EventSource } from \"@/config/sources.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport { buildGraphqlSchema } from \"@/server/graphql/buildGraphqlSchema.js\";\nimport { glob } from \"glob\";\nimport type { GraphQLSchema } from \"graphql\";\nimport { type ViteDevServer, createServer } from \"vite\";\nimport { ViteNodeRunner } from \"vite-node/client\";\nimport { ViteNodeServer } from \"vite-node/server\";\nimport { installSourcemapsSupport } from \"vite-node/source-map\";\nimport { normalizeModuleId, toFilePath } from \"vite-node/utils\";\nimport viteTsconfigPathsPlugin from \"vite-tsconfig-paths\";\nimport {\n  type IndexingFunctions,\n  type RawIndexingFunctions,\n  safeBuildConfigAndIndexingFunctions,\n} from \"./configAndIndexingFunctions.js\";\nimport { vitePluginPonder } from \"./plugin.js\";\nimport { safeBuildSchema } from \"./schema.js\";\nimport { parseViteNodeError } from \"./stacktrace.js\";\n\nconst BUILD_ID_VERSION = \"1\";\n\nexport type Service = {\n  // static\n  common: Common;\n  srcRegex: RegExp;\n\n  // vite\n  viteDevServer: ViteDevServer;\n  viteNodeServer: ViteNodeServer;\n  viteNodeRunner: ViteNodeRunner;\n};\n\nexport type Build = {\n  // Build ID for caching\n  buildId: string;\n  // Config\n  databaseConfig: DatabaseConfig;\n  optionsConfig: OptionsConfig;\n  sources: EventSource[];\n  networks: Network[];\n  // Schema\n  schema: Schema;\n  graphqlSchema: GraphQLSchema;\n  // Indexing functions\n  indexingFunctions: IndexingFunctions;\n};\n\nexport type BuildResult =\n  | { status: \"success\"; build: Build }\n  | { status: \"error\"; error: Error };\n\ntype RawBuild = {\n  config: { config: Config; contentHash: string };\n  schema: { schema: Schema; contentHash: string };\n  indexingFunctions: {\n    indexingFunctions: RawIndexingFunctions;\n    contentHash: string;\n  };\n};\n\nexport const create = async ({\n  common,\n}: {\n  common: Common;\n}): Promise<Service> => {\n  const escapeRegex = /[.*+?^${}()|[\\]\\\\]/g;\n  const escapedSrcDir = common.options.srcDir\n    // If on Windows, use a POSIX path for this regex.\n    .replace(/\\\\/g, \"/\")\n    // Escape special characters in the path.\n    .replace(escapeRegex, \"\\\\$&\");\n  const srcRegex = new RegExp(`^${escapedSrcDir}/.*\\\\.(ts|js)$`);\n\n  const viteLogger = {\n    warnedMessages: new Set<string>(),\n    loggedErrors: new WeakSet<Error>(),\n    hasWarned: false,\n    clearScreen() {},\n    hasErrorLogged: (error: Error) => viteLogger.loggedErrors.has(error),\n    info: (msg: string) => {\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warn: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warnOnce: (msg: string) => {\n      if (viteLogger.warnedMessages.has(msg)) return;\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n      viteLogger.warnedMessages.add(msg);\n    },\n    error: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n  };\n\n  const viteDevServer = await createServer({\n    root: common.options.rootDir,\n    cacheDir: path.join(common.options.ponderDir, \"vite\"),\n    publicDir: false,\n    customLogger: viteLogger,\n    server: { hmr: false },\n    plugins: [viteTsconfigPathsPlugin(), vitePluginPonder()],\n  });\n\n  // This is Vite boilerplate (initializes the Rollup container).\n  await viteDevServer.pluginContainer.buildStart({});\n\n  const viteNodeServer = new ViteNodeServer(viteDevServer);\n  installSourcemapsSupport({\n    getSourceMap: (source) => viteNodeServer.getSourceMap(source),\n  });\n\n  const viteNodeRunner = new ViteNodeRunner({\n    root: viteDevServer.config.root,\n    fetchModule: (id) => viteNodeServer.fetchModule(id, \"ssr\"),\n    resolveId: (id, importer) => viteNodeServer.resolveId(id, importer, \"ssr\"),\n  });\n\n  return {\n    common,\n    srcRegex,\n    viteDevServer,\n    viteNodeServer,\n    viteNodeRunner,\n  };\n};\n\n/**\n * Execute, validate, and build the files the make up a Ponder app.\n * If `watch` is true (dev server), then use vite to re-execute changed files,\n * and validate and build again. This function only re-executes changes files,\n * but doesn't attempt to skip any validation or build steps.\n */\nexport const start = async (\n  buildService: Service,\n  {\n    watch,\n    onBuild,\n  }:\n    | { watch: true; onBuild: (buildResult: BuildResult) => void }\n    | { watch: false; onBuild?: never },\n): Promise<BuildResult> => {\n  const { common } = buildService;\n\n  const [configResult, schemaResult, indexingFunctionsResult] =\n    await Promise.all([\n      executeConfig(buildService),\n      executeSchema(buildService),\n      executeIndexingFunctions(buildService),\n    ]);\n\n  if (configResult.status === \"error\") {\n    return { status: \"error\", error: configResult.error };\n  }\n  if (schemaResult.status === \"error\") {\n    return { status: \"error\", error: schemaResult.error };\n  }\n  if (indexingFunctionsResult.status === \"error\") {\n    return { status: \"error\", error: indexingFunctionsResult.error };\n  }\n\n  const rawBuild: RawBuild = {\n    config: configResult,\n    schema: schemaResult,\n    indexingFunctions: indexingFunctionsResult,\n  };\n\n  const buildResult = await validateAndBuild(buildService, rawBuild);\n\n  // If watch is false (`ponder start` or `ponder serve`),\n  // don't register  any event handlers on the watcher.\n  if (watch) {\n    // Define the directories and files to ignore\n    const ignoredDirs = [common.options.generatedDir, common.options.ponderDir];\n    const ignoredFiles = [\n      path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n      path.join(common.options.rootDir, \".env.local\"),\n    ];\n\n    const isFileIgnored = (filePath: string) => {\n      const isInIgnoredDir = ignoredDirs.some((dir) => {\n        const rel = path.relative(dir, filePath);\n        return !rel.startsWith(\"..\") && !path.isAbsolute(rel);\n      });\n\n      const isIgnoredFile = ignoredFiles.includes(filePath);\n      return isInIgnoredDir || isIgnoredFile;\n    };\n\n    const onFileChange = async (_file: string) => {\n      if (isFileIgnored(_file)) return;\n\n      // Note that `toFilePath` always returns a POSIX path, even if you pass a Windows path.\n      const file = toFilePath(\n        normalizeModuleId(_file),\n        common.options.rootDir,\n      ).path;\n\n      // Invalidate all modules that depend on the updated files.\n      // Note that `invalidateDepTree` accepts and returns POSIX paths, even on Windows.\n      const invalidated = [\n        ...buildService.viteNodeRunner.moduleCache.invalidateDepTree([file]),\n      ];\n\n      // If no files were invalidated, no need to reload.\n      if (invalidated.length === 0) return;\n\n      // Note that the paths in `invalidated` are POSIX, so we need to\n      // convert the paths in `options` to POSIX for this comparison.\n      // The `srcDir` regex is already converted to POSIX.\n      const hasConfigUpdate = invalidated.includes(\n        common.options.configFile.replace(/\\\\/g, \"/\"),\n      );\n      const hasSchemaUpdate = invalidated.includes(\n        common.options.schemaFile.replace(/\\\\/g, \"/\"),\n      );\n      const hasIndexingFunctionUpdate = invalidated.some((file) =>\n        buildService.srcRegex.test(file),\n      );\n\n      // This branch could trigger if you change a `note.txt` file within `src/`.\n      // Note: We could probably do a better job filtering out files in `isFileIgnored`.\n      if (!hasConfigUpdate && !hasSchemaUpdate && !hasIndexingFunctionUpdate) {\n        return;\n      }\n\n      common.logger.info({\n        service: \"build\",\n        msg: `Hot reload ${invalidated\n          .map((f) => `'${path.relative(common.options.rootDir, f)}'`)\n          .join(\", \")}`,\n      });\n\n      if (hasConfigUpdate) {\n        const result = await executeConfig(buildService);\n        if (result.status === \"error\") {\n          onBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        rawBuild.config = result;\n      }\n\n      if (hasSchemaUpdate) {\n        const result = await executeSchema(buildService);\n        if (result.status === \"error\") {\n          onBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        rawBuild.schema = result;\n      }\n\n      if (hasIndexingFunctionUpdate) {\n        const result = await executeIndexingFunctions(buildService);\n        if (result.status === \"error\") {\n          onBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        rawBuild.indexingFunctions = result;\n      }\n\n      const buildResult = await validateAndBuild(buildService, rawBuild);\n      onBuild(buildResult);\n    };\n\n    buildService.viteDevServer.watcher.on(\"change\", onFileChange);\n  }\n\n  return buildResult;\n};\n\nexport const kill = async (buildService: Service): Promise<void> => {\n  await buildService.viteDevServer?.close();\n  buildService.common.logger.debug({\n    service: \"build\",\n    msg: \"Killed build service\",\n  });\n};\n\nconst executeConfig = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; config: Config; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.configFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.config.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const config = executeResult.exports.default as Config;\n\n  const contentHash = createHash(\"sha256\")\n    .update(JSON.stringify(config))\n    .digest(\"hex\");\n\n  return { status: \"success\", config, contentHash } as const;\n};\n\nconst executeSchema = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; schema: Schema; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.schemaFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.schema.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const schema = executeResult.exports.default as Schema;\n\n  const contentHash = createHash(\"sha256\")\n    .update(JSON.stringify(schema))\n    .digest(\"hex\");\n\n  return { status: \"success\", schema, contentHash };\n};\n\nconst executeIndexingFunctions = async (\n  buildService: Service,\n): Promise<\n  | {\n      status: \"success\";\n      indexingFunctions: RawIndexingFunctions;\n      contentHash: string;\n    }\n  | { status: \"error\"; error: Error }\n> => {\n  const pattern = path\n    .join(buildService.common.options.srcDir, \"**/*.{js,mjs,ts,mts}\")\n    .replace(/\\\\/g, \"/\");\n  const files = glob.sync(pattern);\n\n  const executeResults = await Promise.all(\n    files.map(async (file) => ({\n      ...(await executeFile(buildService, { file })),\n      file,\n    })),\n  );\n\n  const indexingFunctions: RawIndexingFunctions = [];\n\n  for (const executeResult of executeResults) {\n    if (executeResult.status === \"error\") {\n      buildService.common.logger.error({\n        service: \"build\",\n        msg: `Error while executing '${path.relative(\n          buildService.common.options.rootDir,\n          executeResult.file,\n        )}':`,\n        error: executeResult.error,\n      });\n\n      return executeResult;\n    }\n\n    indexingFunctions.push(...(executeResult.exports?.ponder?.fns ?? []));\n  }\n\n  // Note that we are only hashing the file contents, not the exports. This is\n  // different from the config/schema, where we include the serializable object itself.\n  const hash = createHash(\"sha256\");\n  for (const file of files) {\n    try {\n      const contents = readFileSync(file, \"utf-8\");\n      hash.update(contents);\n    } catch (e) {\n      buildService.common.logger.warn({\n        service: \"build\",\n        msg: `Unable to read contents of file '${file}' while constructin build ID`,\n      });\n      hash.update(file);\n    }\n  }\n  const contentHash = hash.digest(\"hex\");\n\n  return { status: \"success\", indexingFunctions, contentHash };\n};\n\nconst validateAndBuild = async (\n  { common }: Pick<Service, \"common\">,\n  rawBuild: RawBuild,\n): Promise<BuildResult> => {\n  // Validate and build the schema\n  const buildSchemaResult = safeBuildSchema({\n    schema: rawBuild.schema.schema,\n  });\n  if (buildSchemaResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Error while building schema:\",\n      error: buildSchemaResult.error,\n    });\n\n    return buildSchemaResult;\n  }\n\n  for (const log of buildSchemaResult.logs) {\n    common.logger[log.level]({ service: \"build\", msg: log.msg });\n  }\n\n  const graphqlSchema = buildGraphqlSchema(buildSchemaResult.schema);\n\n  // Validates and build the config\n  const buildConfigAndIndexingFunctionsResult =\n    await safeBuildConfigAndIndexingFunctions({\n      config: rawBuild.config.config,\n      rawIndexingFunctions: rawBuild.indexingFunctions.indexingFunctions,\n      options: common.options,\n    });\n  if (buildConfigAndIndexingFunctionsResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Failed build with error:\",\n      error: buildConfigAndIndexingFunctionsResult.error,\n    });\n\n    return buildConfigAndIndexingFunctionsResult;\n  }\n\n  for (const log of buildConfigAndIndexingFunctionsResult.logs) {\n    common.logger[log.level]({ service: \"build\", msg: log.msg });\n  }\n\n  const buildId = createHash(\"sha256\")\n    .update(BUILD_ID_VERSION)\n    .update(rawBuild.config.contentHash)\n    .update(rawBuild.schema.contentHash)\n    .update(rawBuild.indexingFunctions.contentHash)\n    .digest(\"hex\")\n    .slice(0, 10);\n\n  common.logger.debug({\n    service: \"build\",\n    msg: `Completed build with ID '${buildId}' (hash of project file contents)`,\n  });\n\n  return {\n    status: \"success\",\n    build: {\n      buildId,\n      databaseConfig: buildConfigAndIndexingFunctionsResult.databaseConfig,\n      optionsConfig: buildConfigAndIndexingFunctionsResult.optionsConfig,\n      networks: buildConfigAndIndexingFunctionsResult.networks,\n      sources: buildConfigAndIndexingFunctionsResult.sources,\n      schema: buildSchemaResult.schema,\n      graphqlSchema,\n      indexingFunctions:\n        buildConfigAndIndexingFunctionsResult.indexingFunctions,\n    },\n  };\n};\n\nconst executeFile = async (\n  { common, viteNodeRunner }: Service,\n  { file }: { file: string },\n): Promise<\n  { status: \"success\"; exports: any } | { status: \"error\"; error: Error }\n> => {\n  try {\n    const exports = await viteNodeRunner.executeFile(file);\n    return { status: \"success\", exports } as const;\n  } catch (error_) {\n    const relativePath = path.relative(common.options.rootDir, file);\n    const error = parseViteNodeError(relativePath, error_ as Error);\n    return { status: \"error\", error } as const;\n  }\n};\n","import type {\n  Column,\n  Constraints,\n  Enum,\n  EnumColumn,\n  JSONColumn,\n  ManyColumn,\n  OneColumn,\n  ReferenceColumn,\n  ScalarColumn,\n  Schema,\n  Table,\n} from \"./common.js\";\n\nexport const isScalarColumn = (column: Column): column is ScalarColumn =>\n  column[\" type\"] === \"scalar\";\n\nexport const isReferenceColumn = (column: Column): column is ReferenceColumn =>\n  column[\" type\"] === \"reference\";\n\nexport const isOneColumn = (column: Column): column is OneColumn =>\n  column[\" type\"] === \"one\";\n\nexport const isManyColumn = (column: Column): column is ManyColumn =>\n  column[\" type\"] === \"many\";\n\nexport const isJSONColumn = (column: Column): column is JSONColumn =>\n  column[\" type\"] === \"json\";\n\nexport const isEnumColumn = (column: Column): column is EnumColumn =>\n  column[\" type\"] === \"enum\";\n\nexport const isOptionalColumn = (column: Column): boolean => {\n  if (isManyColumn(column) || isOneColumn(column)) return false;\n  return column[\" optional\"];\n};\n\nexport const isListColumn = (column: Column): boolean => {\n  if (\n    isManyColumn(column) ||\n    isOneColumn(column) ||\n    isReferenceColumn(column) ||\n    isJSONColumn(column)\n  )\n    return false;\n  return column[\" list\"];\n};\n\nexport const isTable = (\n  tableOrEnum: Schema[string],\n): tableOrEnum is { table: Table; constraints: Constraints } =>\n  !Array.isArray(tableOrEnum);\n\nexport const isEnum = (tableOrEnum: Schema[string]): tableOrEnum is Enum =>\n  Array.isArray(tableOrEnum);\n\nexport const getTables = (\n  schema: Schema,\n): { [tableName: string]: { table: Table; constraints: Constraints } } => {\n  const tables: {\n    [tableName: string]: { table: Table; constraints: Constraints };\n  } = {};\n\n  for (const [name, tableOrEnum] of Object.entries(schema)) {\n    if (isTable(tableOrEnum)) {\n      tables[name] = tableOrEnum;\n    }\n  }\n\n  return tables;\n};\n\nexport const getEnums = (schema: Schema): { [enumName: string]: Enum } => {\n  const enums: { [enumName: string]: Enum } = {};\n\n  for (const [name, tableOrEnum] of Object.entries(schema)) {\n    if (isEnum(tableOrEnum)) {\n      enums[name] = tableOrEnum;\n    }\n  }\n\n  return enums;\n};\n\nexport const extractReferenceTable = (ref: ReferenceColumn): string => {\n  return ref[\" reference\"].split(\".\")[0];\n};\n\nexport const encodeSchema = (schema: Schema) => {\n  return JSON.stringify({\n    tables: getTables(schema),\n    enums: getEnums(schema),\n  });\n};\n","import type { IndexingStore } from \"@/indexing-store/store.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport { getTables } from \"@/schema/utils.js\";\nimport {\n  type GraphQLFieldConfig,\n  GraphQLObjectType,\n  GraphQLSchema,\n} from \"graphql\";\nimport type { GetLoader } from \"./buildLoaderCache.js\";\nimport { buildEntityTypes } from \"./entity.js\";\nimport { buildEnumTypes } from \"./enum.js\";\nimport { buildEntityFilterTypes } from \"./filter.js\";\nimport { buildPluralField } from \"./plural.js\";\nimport { buildSingularField } from \"./singular.js\";\n\n// TODO(kyle) stricter type\nexport type Parent = Record<string, any>;\nexport type Context = { store: IndexingStore; getLoader: GetLoader };\n\nexport const buildGraphqlSchema = (schema: Schema): GraphQLSchema => {\n  const queryFields: Record<string, GraphQLFieldConfig<Parent, Context>> = {};\n\n  const { enumTypes } = buildEnumTypes({ schema });\n  const { entityFilterTypes } = buildEntityFilterTypes({ schema, enumTypes });\n  const { entityTypes, entityPageTypes } = buildEntityTypes({\n    schema,\n    enumTypes,\n    entityFilterTypes,\n  });\n\n  for (const [tableName, { table }] of Object.entries(getTables(schema))) {\n    const entityType = entityTypes[tableName];\n    const entityPageType = entityPageTypes[tableName];\n    const entityFilterType = entityFilterTypes[tableName];\n\n    const singularFieldName =\n      tableName.charAt(0).toLowerCase() + tableName.slice(1);\n    queryFields[singularFieldName] = buildSingularField({\n      tableName,\n      table,\n      entityType,\n    });\n\n    const pluralFieldName = `${singularFieldName}s`;\n    queryFields[pluralFieldName] = buildPluralField({\n      tableName,\n      entityPageType,\n      entityFilterType,\n    });\n  }\n\n  return new GraphQLSchema({\n    query: new GraphQLObjectType({\n      name: \"Query\",\n      fields: queryFields,\n    }),\n  });\n};\n","import type { ReferenceColumn, Schema } from \"@/schema/common.js\";\nimport {\n  extractReferenceTable,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n} from \"@/schema/utils.js\";\nimport {\n  GraphQLBoolean,\n  type GraphQLFieldResolver,\n  GraphQLInputObjectType,\n} from \"graphql\";\nimport {\n  GraphQLEnumType,\n  type GraphQLFieldConfigMap,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from \"graphql\";\nimport { GraphQLJSON } from \"graphql-type-json\";\nimport type { Context, Parent } from \"./buildGraphqlSchema.js\";\nimport { buildWhereObject } from \"./filter.js\";\nimport type { PluralResolver } from \"./plural.js\";\nimport { SCALARS } from \"./scalar.js\";\n\nconst GraphQLPageInfo = new GraphQLObjectType({\n  name: \"PageInfo\",\n  fields: {\n    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    startCursor: { type: GraphQLString },\n    endCursor: { type: GraphQLString },\n  },\n});\n\nexport const buildEntityTypes = ({\n  schema,\n  enumTypes,\n  entityFilterTypes,\n}: {\n  schema: Schema;\n  enumTypes: Record<string, GraphQLEnumType>;\n  entityFilterTypes: Record<string, GraphQLInputObjectType>;\n}) => {\n  const entityTypes: Record<string, GraphQLObjectType<Parent, Context>> = {};\n  const entityPageTypes: Record<string, GraphQLObjectType> = {};\n\n  for (const [tableName, { table }] of Object.entries(getTables(schema))) {\n    entityTypes[tableName] = new GraphQLObjectType({\n      name: tableName,\n      fields: () => {\n        const fieldConfigMap: GraphQLFieldConfigMap<Parent, Context> = {};\n\n        Object.entries(table).forEach(([columnName, column]) => {\n          if (isOneColumn(column)) {\n            // Column must resolve the foreign key of the referenced column\n            // Note: this relies on the fact that reference columns can't be lists.\n            const referenceColumn = table[\n              column[\" reference\"]\n            ] as ReferenceColumn;\n            const referencedTable = extractReferenceTable(referenceColumn);\n\n            const resolver: GraphQLFieldResolver<Parent, Context> = async (\n              parent,\n              _args,\n              context,\n            ) => {\n              // The parent object gets passed in here containing reference column values.\n              const relatedRecordId = parent[column[\" reference\"]];\n              // Note: Don't query with a null or undefined id, indexing store will throw error.\n              if (relatedRecordId === null || relatedRecordId === undefined)\n                return null;\n\n              const loader = context.getLoader({\n                tableName: referencedTable,\n              });\n\n              return await loader.load(relatedRecordId);\n            };\n\n            fieldConfigMap[columnName] = {\n              type: isOptionalColumn(referenceColumn)\n                ? entityTypes[referencedTable]\n                : new GraphQLNonNull(entityTypes[referencedTable]),\n              resolve: resolver,\n            };\n          } else if (isManyColumn(column)) {\n            const resolver: PluralResolver = async (parent, args, context) => {\n              const { where, orderBy, orderDirection, limit, after, before } =\n                args;\n\n              const whereObject = where ? buildWhereObject(where) : {};\n              // Add the parent record ID to the where object.\n              // Note that this overrides any existing equals condition.\n              (whereObject[column[\" referenceColumn\"]] ??= {}).equals =\n                parent.id;\n\n              const orderByObject = orderBy\n                ? { [orderBy]: orderDirection ?? \"asc\" }\n                : undefined;\n\n              // Query for the IDs of the matching records.\n              // TODO: Update query to only fetch IDs, not entire records.\n              const result = await context.store.findMany({\n                tableName: column[\" referenceTable\"],\n                where: whereObject,\n                orderBy: orderByObject,\n                limit,\n                before,\n                after,\n              });\n\n              // Load entire records objects using the loader.\n              const loader = context.getLoader({\n                tableName: column[\" referenceTable\"],\n              });\n\n              const ids = result.items.map((item) => item.id);\n              const items = await loader.loadMany(ids);\n\n              return { items, pageInfo: result.pageInfo };\n            };\n\n            fieldConfigMap[columnName] = {\n              type: entityPageTypes[column[\" referenceTable\"]],\n              args: {\n                where: { type: entityFilterTypes[column[\" referenceTable\"]] },\n                orderBy: { type: GraphQLString },\n                orderDirection: { type: GraphQLString },\n                before: { type: GraphQLString },\n                after: { type: GraphQLString },\n                limit: { type: GraphQLInt },\n              },\n              resolve: resolver,\n            };\n          } else if (isJSONColumn(column)) {\n            fieldConfigMap[columnName] = {\n              type: isOptionalColumn(column)\n                ? GraphQLJSON\n                : new GraphQLNonNull(GraphQLJSON),\n            };\n          } else {\n            const type = isEnumColumn(column)\n              ? enumTypes[column[\" enum\"]]\n              : SCALARS[column[\" scalar\"]];\n            if (isListColumn(column)) {\n              const listType = new GraphQLList(new GraphQLNonNull(type));\n              fieldConfigMap[columnName] = {\n                type: isOptionalColumn(column)\n                  ? listType\n                  : new GraphQLNonNull(listType),\n              };\n            } else {\n              fieldConfigMap[columnName] = {\n                type: isOptionalColumn(column)\n                  ? type\n                  : new GraphQLNonNull(type),\n              };\n            }\n          }\n        });\n\n        return fieldConfigMap;\n      },\n    });\n\n    entityPageTypes[tableName] = new GraphQLObjectType({\n      name: `${tableName}Page`,\n      fields: () => ({\n        items: {\n          type: new GraphQLNonNull(\n            new GraphQLList(new GraphQLNonNull(entityTypes[tableName])),\n          ),\n        },\n        pageInfo: { type: new GraphQLNonNull(GraphQLPageInfo) },\n      }),\n    });\n  }\n\n  return { entityTypes, entityPageTypes };\n};\n","import type { Schema } from \"@/schema/common.js\";\nimport {\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport {\n  type GraphQLEnumType,\n  type GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n} from \"graphql\";\nimport { GraphQLList } from \"graphql\";\nimport { SCALARS } from \"./scalar.js\";\n\nconst filterOperators = {\n  universal: [\"\", \"_not\"],\n  singular: [\"_in\", \"_not_in\"],\n  plural: [\"_has\", \"_not_has\"],\n  numeric: [\"_gt\", \"_lt\", \"_gte\", \"_lte\"],\n  string: [\n    \"_contains\",\n    \"_not_contains\",\n    \"_starts_with\",\n    \"_ends_with\",\n    \"_not_starts_with\",\n    \"_not_ends_with\",\n  ],\n} as const;\n\nexport const buildEntityFilterTypes = ({\n  schema,\n  enumTypes,\n}: { schema: Schema; enumTypes: Record<string, GraphQLEnumType> }) => {\n  const entityFilterTypes: Record<string, GraphQLInputObjectType> = {};\n\n  for (const [tableName, { table }] of Object.entries(getTables(schema))) {\n    const filterType = new GraphQLInputObjectType({\n      name: `${tableName}Filter`,\n      fields: () => {\n        const filterFields: GraphQLInputFieldConfigMap = {\n          // Logical operators\n          AND: { type: new GraphQLList(filterType) },\n          OR: { type: new GraphQLList(filterType) },\n        };\n\n        Object.entries(table).forEach(([columnName, column]) => {\n          // Note: Only include non-virtual columns in plural fields\n          if (isOneColumn(column)) return;\n          if (isManyColumn(column)) return;\n          if (isJSONColumn(column)) return;\n\n          const type = isEnumColumn(column)\n            ? enumTypes[column[\" enum\"]]\n            : SCALARS[column[\" scalar\"]];\n\n          if (isListColumn(column)) {\n            // List fields => universal, plural\n            filterOperators.universal.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: new GraphQLList(type),\n              };\n            });\n\n            filterOperators.plural.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: type,\n              };\n            });\n          } else {\n            // Scalar fields => universal, singular, numeric OR string depending on base type\n            // Note: Booleans => universal and singular only.\n            filterOperators.universal.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: type,\n              };\n            });\n\n            filterOperators.singular.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: new GraphQLList(type),\n              };\n            });\n\n            if (\n              (isScalarColumn(column) || isReferenceColumn(column)) &&\n              [\"int\", \"bigint\", \"float\", \"hex\"].includes(column[\" scalar\"])\n            ) {\n              filterOperators.numeric.forEach((suffix) => {\n                filterFields[`${columnName}${suffix}`] = {\n                  type: type,\n                };\n              });\n            }\n\n            if (\n              (isScalarColumn(column) || isReferenceColumn(column)) &&\n              \"string\" === column[\" scalar\"]\n            ) {\n              filterOperators.string.forEach((suffix) => {\n                filterFields[`${columnName}${suffix}`] = {\n                  type: type,\n                };\n              });\n            }\n          }\n        });\n\n        return filterFields;\n      },\n    });\n\n    entityFilterTypes[tableName] = filterType;\n  }\n\n  return { entityFilterTypes };\n};\n\nconst graphqlFilterToStoreCondition = {\n  \"\": \"equals\",\n  not: \"not\",\n  in: \"in\",\n  not_in: \"notIn\",\n  has: \"has\",\n  not_has: \"notHas\",\n  gt: \"gt\",\n  lt: \"lt\",\n  gte: \"gte\",\n  lte: \"lte\",\n  contains: \"contains\",\n  not_contains: \"notContains\",\n  starts_with: \"startsWith\",\n  not_starts_with: \"notStartsWith\",\n  ends_with: \"endsWith\",\n  not_ends_with: \"notEndsWith\",\n} as const;\n\nexport function buildWhereObject(where: Record<string, any>) {\n  const whereObject: Record<string, any> = {};\n\n  for (const [whereKey, rawValue] of Object.entries(where)) {\n    // Handle the `and` and `or` operators.\n    if (whereKey === \"AND\" || whereKey === \"OR\") {\n      if (!Array.isArray(rawValue)) {\n        throw new Error(\n          `Invalid query: Expected an array for the ${whereKey} operator. Got: ${rawValue}`,\n        );\n      }\n\n      whereObject[whereKey] = rawValue.map(buildWhereObject);\n      continue;\n    }\n\n    const [fieldName, condition_] = whereKey.split(/_(.*)/s);\n    // This is a hack to handle the \"\" operator, which the regex above doesn't handle\n    const condition = (\n      condition_ === undefined ? \"\" : condition_\n    ) as keyof typeof graphqlFilterToStoreCondition;\n\n    const storeCondition = graphqlFilterToStoreCondition[condition];\n    if (!storeCondition) {\n      throw new Error(\n        `Invalid query: Unknown where condition: ${fieldName}_${condition}`,\n      );\n    }\n\n    whereObject[fieldName] ||= {};\n    whereObject[fieldName][storeCondition] = rawValue;\n  }\n\n  return whereObject;\n}\n","import type { Scalar } from \"@/schema/common.js\";\nimport {\n  GraphQLBoolean,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLScalarType,\n  GraphQLString,\n} from \"graphql\";\n\nconst GraphQLBigInt = new GraphQLScalarType({\n  name: \"BigInt\",\n  serialize: (value) => String(value),\n  parseValue: (value) => BigInt(value as any),\n  parseLiteral: (value) => {\n    if (value.kind === \"StringValue\") {\n      return BigInt(value.value);\n    } else {\n      throw new Error(\n        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`,\n      );\n    }\n  },\n});\n\nexport const SCALARS: { [type in Scalar]: GraphQLScalarType } = {\n  int: GraphQLInt,\n  float: GraphQLFloat,\n  string: GraphQLString,\n  boolean: GraphQLBoolean,\n  bigint: GraphQLBigInt,\n  hex: GraphQLString,\n};\n","import type { Schema } from \"@/schema/common.js\";\nimport { getEnums } from \"@/schema/utils.js\";\nimport { GraphQLEnumType } from \"graphql\";\n\nexport function buildEnumTypes({ schema }: { schema: Schema }) {\n  const enumTypes: Record<string, GraphQLEnumType> = {};\n\n  for (const [enumName, _enum] of Object.entries(getEnums(schema))) {\n    enumTypes[enumName] = new GraphQLEnumType({\n      name: enumName,\n      values: _enum.reduce(\n        (acc: Record<string, {}>, cur) => ({ ...acc, [cur]: {} }),\n        {},\n      ),\n    });\n  }\n\n  return { enumTypes };\n}\n","import {\n  type GraphQLFieldConfig,\n  type GraphQLFieldResolver,\n  GraphQLInputObjectType,\n  GraphQLInt,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from \"graphql\";\nimport type { Context, Parent } from \"./buildGraphqlSchema.js\";\nimport { buildWhereObject } from \"./filter.js\";\n\ntype PluralArgs = {\n  where?: { [key: string]: number | string };\n  after?: string;\n  before?: string;\n  limit?: number;\n  orderBy?: string;\n  orderDirection?: \"asc\" | \"desc\";\n};\n\nexport type PluralResolver = GraphQLFieldResolver<Parent, Context, PluralArgs>;\n\nexport const buildPluralField = ({\n  tableName,\n  entityPageType,\n  entityFilterType,\n}: {\n  tableName: string;\n  entityPageType: GraphQLObjectType;\n  entityFilterType: GraphQLInputObjectType;\n}): GraphQLFieldConfig<Parent, Context> => {\n  const resolver: PluralResolver = async (_, args, context) => {\n    const { where, orderBy, orderDirection, before, limit, after } = args;\n\n    const whereObject = where ? buildWhereObject(where) : {};\n\n    const orderByObject = orderBy\n      ? { [orderBy]: orderDirection || \"asc\" }\n      : undefined;\n\n    return await context.store.findMany({\n      tableName,\n      where: whereObject,\n      orderBy: orderByObject,\n      limit,\n      before,\n      after,\n    });\n  };\n\n  return {\n    type: new GraphQLNonNull(entityPageType),\n    args: {\n      where: { type: entityFilterType },\n      orderBy: { type: GraphQLString },\n      orderDirection: { type: GraphQLString },\n      before: { type: GraphQLString },\n      after: { type: GraphQLString },\n      limit: { type: GraphQLInt },\n    },\n    resolve: resolver,\n  };\n};\n","import type { Table } from \"@/schema/common.js\";\nimport type { GraphQLObjectType } from \"graphql\";\nimport {\n  type GraphQLFieldConfig,\n  type GraphQLFieldResolver,\n  GraphQLNonNull,\n} from \"graphql\";\nimport type { Context, Parent } from \"./buildGraphqlSchema.js\";\nimport { SCALARS } from \"./scalar.js\";\n\ntype SingularArgs = {\n  id?: string;\n};\ntype SingularResolver = GraphQLFieldResolver<Parent, Context, SingularArgs>;\n\nexport const buildSingularField = ({\n  tableName,\n  table,\n  entityType,\n}: {\n  tableName: string;\n  table: Table;\n  entityType: GraphQLObjectType<Parent, Context>;\n}): GraphQLFieldConfig<Parent, Context> => {\n  const resolver: SingularResolver = async (_, args, context) => {\n    const { id } = args;\n\n    if (id === undefined) return null;\n\n    const entityInstance = await context.store.findUnique({ tableName, id });\n\n    return entityInstance;\n  };\n\n  return {\n    type: entityType,\n    args: {\n      id: { type: new GraphQLNonNull(SCALARS[table.id[\" scalar\"]]) },\n    },\n    resolve: resolver,\n  };\n};\n","import path from \"node:path\";\nimport type { Options } from \"@/common/options.js\";\nimport {\n  buildAbiEvents,\n  buildAbiFunctions,\n  buildTopics,\n} from \"@/config/abi.js\";\nimport type { Config } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport { buildChildAddressCriteria } from \"@/config/factories.js\";\nimport {\n  type Network,\n  getDefaultMaxBlockRange,\n  getFinalityBlockCount,\n  getRpcUrlsForClient,\n  isRpcUrlPublic,\n} from \"@/config/networks.js\";\nimport {\n  type BlockSource,\n  type CallTraceSource,\n  type FactoryCallTraceSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n} from \"@/config/sources.js\";\nimport { chains } from \"@/utils/chains.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { dedupe } from \"@ponder/common\";\nimport parse from \"pg-connection-string\";\nimport type { Hex, LogTopic } from \"viem\";\n\nexport type RawIndexingFunctions = {\n  name: string;\n  fn: (...args: any) => any;\n}[];\n\nexport type IndexingFunctions = {\n  [eventName: string]: (...args: any) => any;\n};\n\nexport async function buildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options: { rootDir, ponderDir },\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"ponderDir\" | \"rootDir\">;\n}) {\n  const logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[] = [];\n\n  // Build database.\n  let databaseConfig: DatabaseConfig;\n\n  const sqliteDir = path.join(ponderDir, \"sqlite\");\n  const sqlitePrintPath = path.relative(rootDir, sqliteDir);\n\n  if (config.database?.kind) {\n    if (config.database.kind === \"postgres\") {\n      let connectionString: string | undefined = undefined;\n      let source: string | undefined = undefined;\n\n      if (config.database.connectionString) {\n        connectionString = config.database.connectionString;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.DATABASE_PRIVATE_URL) {\n        connectionString = process.env.DATABASE_PRIVATE_URL;\n        source = \"from DATABASE_PRIVATE_URL env var\";\n      } else if (process.env.DATABASE_URL) {\n        connectionString = process.env.DATABASE_URL;\n        source = \"from DATABASE_URL env var\";\n      } else {\n        throw new Error(\n          `Invalid database configuration: 'kind' is set to 'postgres' but no connection string was provided.`,\n        );\n      }\n\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database '${getDatabaseName(\n          connectionString,\n        )}' (${source})`,\n      });\n\n      let schema: string | undefined = undefined;\n      if (config.database.schema) {\n        schema = config.database.schema;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.RAILWAY_DEPLOYMENT_ID) {\n        if (process.env.RAILWAY_SERVICE_NAME === undefined) {\n          throw new Error(\n            \"Invalid database configuration: RAILWAY_DEPLOYMENT_ID env var is defined, but RAILWAY_SERVICE_NAME env var is not.\",\n          );\n        }\n        schema = `${\n          process.env.RAILWAY_SERVICE_NAME\n        }_${process.env.RAILWAY_DEPLOYMENT_ID.slice(0, 8)}`;\n        source = \"from RAILWAY_DEPLOYMENT_ID env var\";\n      } else {\n        schema = \"public\";\n        source = \"default\";\n      }\n      logs.push({\n        level: \"info\",\n        msg: `Using '${schema}' database schema for indexed tables (${source})`,\n      });\n\n      let publishSchema: string | undefined = undefined;\n      if (config.database.publishSchema !== undefined) {\n        publishSchema = config.database.publishSchema;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        publishSchema = \"public\";\n        source = \"default for Railway deployment\";\n      }\n      if (publishSchema !== undefined) {\n        logs.push({\n          level: \"info\",\n          msg: `Using '${publishSchema}' database schema for published views (${source})`,\n        });\n      } else {\n        logs.push({\n          level: \"debug\",\n          msg: \"Will not publish views (publish schema was not set in ponder.config.ts)\",\n        });\n      }\n\n      if (schema !== undefined && schema === publishSchema) {\n        throw new Error(\n          `Invalid database configuration: 'publishSchema' cannot be the same as 'schema' ('${schema}').`,\n        );\n      }\n\n      const poolConfig = {\n        max: config.database.poolConfig?.max ?? 30,\n        connectionString,\n      };\n\n      databaseConfig = {\n        kind: \"postgres\",\n        poolConfig,\n        schema,\n        publishSchema,\n      };\n    } else {\n      logs.push({\n        level: \"info\",\n        msg: `Using SQLite database in '${sqlitePrintPath}' (from ponder.config.ts)`,\n      });\n\n      databaseConfig = { kind: \"sqlite\", directory: sqliteDir };\n    }\n  } else {\n    let connectionString: string | undefined = undefined;\n    let source: string | undefined = undefined;\n    if (process.env.DATABASE_PRIVATE_URL) {\n      connectionString = process.env.DATABASE_PRIVATE_URL;\n      source = \"from DATABASE_PRIVATE_URL env var\";\n    } else if (process.env.DATABASE_URL) {\n      connectionString = process.env.DATABASE_URL;\n      source = \"from DATABASE_URL env var\";\n    }\n\n    // If either of the DATABASE_URL env vars are set, use Postgres.\n    if (connectionString !== undefined) {\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database ${getDatabaseName(\n          connectionString,\n        )} (${source})`,\n      });\n\n      let schema: string | undefined = undefined;\n      if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        schema = process.env.RAILWAY_DEPLOYMENT_ID;\n        if (process.env.RAILWAY_SERVICE_NAME === undefined) {\n          throw new Error(\n            \"Invalid database configuration: RAILWAY_DEPLOYMENT_ID env var is defined, but RAILWAY_SERVICE_NAME env var is not.\",\n          );\n        }\n        schema = `${\n          process.env.RAILWAY_SERVICE_NAME\n        }_${process.env.RAILWAY_DEPLOYMENT_ID.slice(0, 8)}`;\n        source = \"from RAILWAY_DEPLOYMENT_ID env var\";\n      } else {\n        schema = \"public\";\n        source = \"default\";\n      }\n      logs.push({\n        level: \"info\",\n        msg: `Using '${schema}' database schema for indexed tables (${source})`,\n      });\n\n      let publishSchema: string | undefined = undefined;\n      if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        publishSchema = \"public\";\n        source = \"default for Railway deployment\";\n      }\n      if (publishSchema !== undefined) {\n        logs.push({\n          level: \"info\",\n          msg: `Using '${publishSchema}' database schema for published views (${source})`,\n        });\n      } else {\n        logs.push({\n          level: \"debug\",\n          msg: \"Will not publish views (publish schema was not set in ponder.config.ts)\",\n        });\n      }\n\n      if (schema !== undefined && schema === publishSchema) {\n        throw new Error(\n          `Invalid database configuration: 'publishSchema' cannot be the same as 'schema' ('${schema}').`,\n        );\n      }\n\n      const poolConfig = { max: 30, connectionString };\n\n      databaseConfig = {\n        kind: \"postgres\",\n        poolConfig,\n        schema,\n        publishSchema,\n      };\n    } else {\n      // Fall back to SQLite.\n      logs.push({\n        level: \"info\",\n        msg: `Using SQLite database at ${sqlitePrintPath} (default)`,\n      });\n\n      databaseConfig = { kind: \"sqlite\", directory: sqliteDir };\n    }\n  }\n\n  const networks: Network[] = await Promise.all(\n    Object.entries(config.networks).map(async ([networkName, network]) => {\n      const { chainId, transport } = network;\n\n      const defaultChain =\n        Object.values(chains).find((c) =>\n          \"id\" in c ? c.id === chainId : false,\n        ) ?? chains.mainnet;\n      const chain = { ...defaultChain, name: networkName, id: chainId };\n\n      // Note: This can throw.\n      const rpcUrls = await getRpcUrlsForClient({ transport, chain });\n      rpcUrls.forEach((rpcUrl) => {\n        if (isRpcUrlPublic(rpcUrl)) {\n          logs.push({\n            level: \"warn\",\n            msg: `Network '${networkName}' is using a public RPC URL (${rpcUrl}). Most apps require an RPC URL with a higher rate limit.`,\n          });\n        }\n      });\n\n      return {\n        name: networkName,\n        chainId,\n        chain,\n        transport: network.transport({ chain }),\n        maxRequestsPerSecond: network.maxRequestsPerSecond ?? 50,\n        pollingInterval: network.pollingInterval ?? 1_000,\n        defaultMaxBlockRange: getDefaultMaxBlockRange({ chainId, rpcUrls }),\n        finalityBlockCount: getFinalityBlockCount({ chainId }),\n        maxHistoricalTaskConcurrency:\n          network.maxHistoricalTaskConcurrency ?? 20,\n      } satisfies Network;\n    }),\n  );\n\n  // Validate and build indexing functions\n  let indexingFunctionCount = 0;\n  const indexingFunctions: IndexingFunctions = {};\n\n  for (const { name: eventName, fn } of rawIndexingFunctions) {\n    const eventNameComponents = eventName.includes(\".\")\n      ? eventName.split(\".\")\n      : eventName.split(\":\");\n    const [sourceName, sourceEventName] = eventNameComponents;\n    if (eventNameComponents.length !== 2 || !sourceName || !sourceEventName) {\n      throw new Error(\n        `Validation failed: Invalid event '${eventName}', expected format '{sourceName}:{eventName}' or '{sourceName}.{eventName}'.`,\n      );\n    }\n\n    if (eventName in indexingFunctions) {\n      throw new Error(\n        `Validation failed: Multiple indexing functions registered for event '${eventName}'.`,\n      );\n    }\n\n    // Validate that the indexing function uses a sourceName that is present in the config.\n    const matchedSourceName = Object.keys({\n      ...(config.contracts ?? {}),\n      ...(config.blocks ?? {}),\n    }).find((_sourceName) => _sourceName === sourceName);\n\n    if (!matchedSourceName) {\n      // Multi-network has N sources, but the hint here should not have duplicates.\n      const uniqueSourceNames = dedupe(\n        Object.keys({ ...(config.contracts ?? {}), ...(config.blocks ?? {}) }),\n      );\n      throw new Error(\n        `Validation failed: Invalid source name '${sourceName}'. Got '${sourceName}', expected one of [${uniqueSourceNames\n          .map((n) => `'${n}'`)\n          .join(\", \")}].`,\n      );\n    }\n\n    indexingFunctions[eventName] = fn;\n    indexingFunctionCount += 1;\n  }\n\n  if (indexingFunctionCount === 0) {\n    logs.push({ level: \"warn\", msg: \"No indexing functions were registered.\" });\n  }\n\n  const contractSources: (\n    | LogSource\n    | FactoryLogSource\n    | CallTraceSource\n    | FactoryCallTraceSource\n  )[] = Object.entries(config.contracts ?? {})\n    // First, apply any network-specific overrides and flatten the result.\n    .flatMap(([contractName, contract]) => {\n      if (contract.network === null || contract.network === undefined) {\n        throw new Error(\n          `Validation failed: Network for contract '${contractName}' is null or undefined. Expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      const startBlockMaybeNan = contract.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = contract.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      // Single network case.\n      if (typeof contract.network === \"string\") {\n        return {\n          id: `log_${contractName}_${contract.network}`,\n          contractName,\n          networkName: contract.network,\n          abi: contract.abi,\n\n          address: \"address\" in contract ? contract.address : undefined,\n          factory: \"factory\" in contract ? contract.factory : undefined,\n          filter: contract.filter,\n\n          includeTransactionReceipts:\n            contract.includeTransactionReceipts ?? false,\n          includeCallTraces: contract.includeCallTraces ?? false,\n\n          startBlock,\n          endBlock,\n          maxBlockRange: contract.maxBlockRange,\n        };\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"contracts\"][string][\"network\"], string>[string]\n      >;\n\n      // Multiple networks case.\n      return Object.entries(contract.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const startBlockMaybeNan =\n            overrides.startBlock ?? contract.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan = overrides.endBlock ?? contract.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          return {\n            contractName,\n            networkName,\n            abi: contract.abi,\n\n            address:\n              (\"address\" in overrides ? overrides?.address : undefined) ??\n              (\"address\" in contract ? contract.address : undefined),\n            factory:\n              (\"factory\" in overrides ? overrides.factory : undefined) ??\n              (\"factory\" in contract ? contract.factory : undefined),\n            filter: overrides.filter ?? contract.filter,\n\n            includeTransactionReceipts:\n              overrides.includeTransactionReceipts ??\n              contract.includeTransactionReceipts ??\n              false,\n            includeCallTraces:\n              overrides.includeCallTraces ??\n              contract.includeCallTraces ??\n              false,\n\n            startBlock,\n            endBlock,\n            maxBlockRange: overrides.maxBlockRange ?? contract.maxBlockRange,\n          };\n        });\n    })\n    // Second, build and validate the factory or log source.\n    .flatMap(\n      (\n        rawContract,\n      ): (\n        | LogSource\n        | FactoryLogSource\n        | CallTraceSource\n        | FactoryCallTraceSource\n      )[] => {\n        const network = networks.find(\n          (n) => n.name === rawContract.networkName,\n        );\n        if (!network) {\n          throw new Error(\n            `Validation failed: Invalid network for contract '${\n              rawContract.contractName\n            }'. Got '${rawContract.networkName}', expected one of [${networks\n              .map((n) => `'${n.name}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        // Get indexing function that were registered for this contract\n        const registeredLogEvents: string[] = [];\n        const registeredCallTraceEvents: string[] = [];\n        for (const eventName of Object.keys(indexingFunctions)) {\n          // log event\n          if (eventName.includes(\":\")) {\n            const [logContractName, logEventName] = eventName.split(\":\");\n            if (\n              logContractName === rawContract.contractName &&\n              logEventName !== \"setup\"\n            ) {\n              registeredLogEvents.push(logEventName);\n            }\n          }\n\n          // call trace event\n          if (eventName.includes(\".\")) {\n            const [functionContractName, functionName] = eventName.split(\".\");\n            if (functionContractName === rawContract.contractName) {\n              registeredCallTraceEvents.push(functionName);\n            }\n          }\n        }\n\n        // Note: This can probably throw for invalid ABIs. Consider adding explicit ABI validation before this line.\n        const abiEvents = buildAbiEvents({ abi: rawContract.abi });\n        const abiFunctions = buildAbiFunctions({ abi: rawContract.abi });\n\n        const registeredEventSelectors: Hex[] = [];\n        // Validate that the registered log events exist in the abi\n        for (const logEvent of registeredLogEvents) {\n          const abiEvent = abiEvents.bySafeName[logEvent];\n          if (abiEvent === undefined) {\n            throw new Error(\n              `Validation failed: Event name for event '${logEvent}' not found in the contract ABI. Got '${logEvent}', expected one of [${Object.keys(\n                abiEvents.bySafeName,\n              )\n                .map((eventName) => `'${eventName}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          registeredEventSelectors.push(abiEvent.selector);\n        }\n\n        const registeredFunctionSelectors: Hex[] = [];\n        for (const _function of registeredCallTraceEvents) {\n          const abiFunction = abiFunctions.bySafeName[_function];\n          if (abiFunction === undefined) {\n            throw new Error(\n              `Validation failed: Function name for function '${_function}' not found in the contract ABI. Got '${_function}', expected one of [${Object.keys(\n                abiFunctions.bySafeName,\n              )\n                .map((eventName) => `'${eventName}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          registeredFunctionSelectors.push(abiFunction.selector);\n        }\n\n        let topics: LogTopic[] = [registeredEventSelectors];\n\n        if (rawContract.filter !== undefined) {\n          if (\n            Array.isArray(rawContract.filter.event) &&\n            rawContract.filter.args !== undefined\n          ) {\n            throw new Error(\n              `Validation failed: Event filter for contract '${rawContract.contractName}' cannot contain indexed argument values if multiple events are provided.`,\n            );\n          }\n\n          const filterSafeEventNames = Array.isArray(rawContract.filter.event)\n            ? rawContract.filter.event\n            : [rawContract.filter.event];\n\n          for (const filterSafeEventName of filterSafeEventNames) {\n            const abiEvent = abiEvents.bySafeName[filterSafeEventName];\n            if (!abiEvent) {\n              throw new Error(\n                `Validation failed: Invalid filter for contract '${\n                  rawContract.contractName\n                }'. Got event name '${filterSafeEventName}', expected one of [${Object.keys(\n                  abiEvents.bySafeName,\n                )\n                  .map((n) => `'${n}'`)\n                  .join(\", \")}].`,\n              );\n            }\n          }\n\n          // TODO: Explicit validation of indexed argument value format (array or object).\n          // The first element of the array return from `buildTopics` being defined\n          // is an invariant of the current filter design.\n          // Note: This can throw.\n          const [topic0FromFilter, ...topicsFromFilter] = buildTopics(\n            rawContract.abi,\n            rawContract.filter,\n          ) as [Exclude<LogTopic, null>, ...LogTopic[]];\n\n          const filteredEventSelectors = Array.isArray(topic0FromFilter)\n            ? topic0FromFilter\n            : [topic0FromFilter];\n\n          // Validate that the topic0 value defined by the `eventFilter` is a superset of the\n          // registered indexing functions. Simply put, confirm that no indexing function is\n          // defined for a log event that is excluded by the filter.\n          for (const registeredEventSelector of registeredEventSelectors) {\n            if (!filteredEventSelectors.includes(registeredEventSelector)) {\n              const logEventName =\n                abiEvents.bySelector[registeredEventSelector]!.safeName;\n\n              throw new Error(\n                `Validation failed: Event '${logEventName}' is excluded by the event filter defined on the contract '${\n                  rawContract.contractName\n                }'. Got '${logEventName}', expected one of [${filteredEventSelectors\n                  .map((s) => abiEvents.bySelector[s]!.safeName)\n                  .map((eventName) => `'${eventName}'`)\n                  .join(\", \")}].`,\n              );\n            }\n          }\n\n          topics = [registeredEventSelectors, ...topicsFromFilter];\n        }\n\n        const baseContract = {\n          contractName: rawContract.contractName,\n          networkName: rawContract.networkName,\n          chainId: network.chainId,\n          abi: rawContract.abi,\n          startBlock: rawContract.startBlock,\n          endBlock: rawContract.endBlock,\n          maxBlockRange: rawContract.maxBlockRange,\n        };\n\n        const resolvedFactory = rawContract?.factory;\n        const resolvedAddress = rawContract?.address;\n\n        if (resolvedFactory !== undefined && resolvedAddress !== undefined) {\n          throw new Error(\n            `Validation failed: Contract '${baseContract.contractName}' cannot specify both 'factory' and 'address' options.`,\n          );\n        }\n\n        if (resolvedFactory) {\n          // Note that this can throw.\n          const childAddressCriteria = buildChildAddressCriteria(resolvedFactory);\n\n          const factoryLogSource = {\n            ...baseContract,\n            id: `log_${rawContract.contractName}_${rawContract.networkName}`,\n            type: \"factoryLog\",\n            abiEvents: abiEvents,\n            criteria: {\n              ...childAddressCriteria,\n              includeTransactionReceipts: rawContract.includeTransactionReceipts,\n              topics,\n            },\n          } satisfies FactoryLogSource;\n\n          if (rawContract.includeCallTraces) {\n            return [\n              factoryLogSource,\n              {\n                ...baseContract,\n                id: `callTrace_${rawContract.contractName}_${rawContract.networkName}`,\n                type: \"factoryCallTrace\",\n                abiFunctions,\n                criteria: {\n                  ...childAddressCriteria,\n                  functionSelectors: registeredFunctionSelectors,\n                  includeTransactionReceipts:\n                    rawContract.includeTransactionReceipts,\n                },\n              } satisfies FactoryCallTraceSource,\n            ];\n          }\n\n          return [factoryLogSource];\n        }\n\n        const validatedAddress = Array.isArray(resolvedAddress)\n          ? resolvedAddress.map((r) => toLowerCase(r))\n          : resolvedAddress\n            ? toLowerCase(resolvedAddress)\n            : undefined;\n\n        if (validatedAddress !== undefined) {\n          for (const address of Array.isArray(validatedAddress)\n            ? validatedAddress\n            : [validatedAddress]) {\n            if (!address.startsWith(\"0x\"))\n              throw new Error(\n                `Validation failed: Invalid prefix for address '${address}'. Got '${address.slice(\n                  0,\n                  2,\n                )}', expected '0x'.`,\n              );\n            if (address.length !== 42)\n              throw new Error(\n                `Validation failed: Invalid length for address '${address}'. Got ${address.length}, expected 42 characters.`,\n              );\n          }\n        }\n\n        const logSource = {\n          ...baseContract,\n          id: `log_${rawContract.contractName}_${rawContract.networkName}`,\n          type: \"log\",\n          abiEvents: abiEvents,\n          criteria: {\n            address: validatedAddress,\n            topics,\n            includeTransactionReceipts: rawContract.includeTransactionReceipts,\n          },\n        } satisfies LogSource;\n\n        if (rawContract.includeCallTraces) {\n          return [\n            logSource,\n            {\n              ...baseContract,\n              id: `callTrace_${rawContract.contractName}_${rawContract.networkName}`,\n              type: \"callTrace\",\n              abiFunctions,\n              criteria: {\n                toAddress: Array.isArray(validatedAddress)\n                  ? validatedAddress\n                  : validatedAddress === undefined\n                    ? undefined\n                    : [validatedAddress],\n                functionSelectors: registeredFunctionSelectors,\n                includeTransactionReceipts:\n                  rawContract.includeTransactionReceipts,\n              },\n            } satisfies CallTraceSource,\n          ];\n        } else return [logSource];\n      },\n    )\n    // Remove sources with no registered indexing functions\n    .filter((source) => {\n      const hasRegisteredIndexingFunctions =\n        sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source)\n          ? source.criteria.functionSelectors.length !== 0\n          : source.criteria.topics[0]?.length !== 0;\n      if (!hasRegisteredIndexingFunctions) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${\n            source.contractName\n          }' ${sourceIsCallTrace(source) ? \"call traces\" : \"logs\"}`,\n        });\n      }\n      return hasRegisteredIndexingFunctions;\n    });\n\n  const blockSources: BlockSource[] = Object.entries(config.blocks ?? {})\n    .flatMap(([sourceName, blockSourceConfig]) => {\n      const startBlockMaybeNan = blockSourceConfig.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = blockSourceConfig.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      const intervalMaybeNan = blockSourceConfig.interval;\n      const interval = Number.isNaN(intervalMaybeNan) ? 0 : intervalMaybeNan;\n\n      if (!Number.isInteger(interval) || interval === 0) {\n        throw Error(\n          `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n        );\n      }\n\n      if (typeof blockSourceConfig.network === \"string\") {\n        const network = networks.find(\n          (n) => n.name === blockSourceConfig.network,\n        );\n        if (!network) {\n          throw new Error(\n            `Validation failed: Invalid network for block source '${sourceName}'. Got '${\n              blockSourceConfig.network\n            }', expected one of [${networks\n              .map((n) => `'${n.name}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        return {\n          type: \"block\",\n          id: `block_${sourceName}_${blockSourceConfig.network}`,\n          sourceName,\n          networkName: blockSourceConfig.network,\n          chainId: network.chainId,\n          startBlock,\n          endBlock,\n          criteria: {\n            interval: interval,\n            offset: startBlock % interval,\n          },\n        } as const;\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"blocks\"][string][\"network\"], string>[string]\n      >;\n\n      return Object.entries(blockSourceConfig.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const network = networks.find((n) => n.name === networkName);\n          if (!network) {\n            throw new Error(\n              `Validation failed: Invalid network for block source '${sourceName}'. Got '${networkName}', expected one of [${networks\n                .map((n) => `'${n.name}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          const startBlockMaybeNan =\n            overrides.startBlock ?? blockSourceConfig.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan =\n            overrides.endBlock ?? blockSourceConfig.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          const intervalMaybeNan =\n            overrides.interval ?? blockSourceConfig.interval;\n          const interval = Number.isNaN(intervalMaybeNan)\n            ? 0\n            : intervalMaybeNan;\n\n          if (!Number.isInteger(interval) || interval === 0) {\n            throw Error(\n              `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n            );\n          }\n\n          return {\n            type: \"block\",\n            id: `block_${sourceName}_${networkName}`,\n            sourceName,\n            networkName,\n            chainId: network.chainId,\n            startBlock,\n            endBlock,\n            criteria: {\n              interval: interval,\n              offset: startBlock % interval,\n            },\n          } as const;\n        });\n    })\n    .filter((blockSource) => {\n      const hasRegisteredIndexingFunction =\n        indexingFunctions[`${blockSource.sourceName}:block`] !== undefined;\n      if (!hasRegisteredIndexingFunction) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${blockSource.sourceName}' blocks`,\n        });\n      }\n      return hasRegisteredIndexingFunction;\n    });\n\n  const sources = [...contractSources, ...blockSources];\n\n  // Filter out any networks that don't have any sources registered.\n  const networksWithSources = networks.filter((network) => {\n    const hasSources = sources.some(\n      (source) => source.networkName === network.name,\n    );\n    if (!hasSources) {\n      logs.push({\n        level: \"warn\",\n        msg: `No sources registered for network '${network.name}'`,\n      });\n    }\n    return hasSources;\n  });\n\n  const optionsConfig: Partial<Options> = {};\n  if (config.options?.maxHealthcheckDuration !== undefined) {\n    optionsConfig.maxHealthcheckDuration =\n      config.options.maxHealthcheckDuration;\n    logs.push({\n      level: \"info\",\n      msg: `Set max healthcheck duration to ${optionsConfig.maxHealthcheckDuration} seconds (from ponder.config.ts)`,\n    });\n  }\n\n  return {\n    databaseConfig,\n    optionsConfig,\n    networks: networksWithSources,\n    sources,\n    indexingFunctions,\n    logs,\n  };\n}\n\nexport async function safeBuildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options,\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"rootDir\" | \"ponderDir\">;\n}) {\n  try {\n    const result = await buildConfigAndIndexingFunctions({\n      config,\n      rawIndexingFunctions,\n      options,\n    });\n\n    return {\n      status: \"success\",\n      sources: result.sources,\n      networks: result.networks,\n      indexingFunctions: result.indexingFunctions,\n      databaseConfig: result.databaseConfig,\n      optionsConfig: result.optionsConfig,\n      logs: result.logs,\n    } as const;\n  } catch (error_) {\n    const error = error_ as Error;\n    return { status: \"error\", error } as const;\n  }\n}\n\nfunction getDatabaseName(connectionString: string) {\n  const parsed = (parse as unknown as typeof parse.parse)(connectionString);\n  return `${parsed.host}:${parsed.port}/${parsed.database}`;\n}\n","/**\n * Returns a Set containing all the duplicate elements in an array of strings.\n * @param arr - The input array of strings.\n * @returns A Set object containing the duplicate elements found in the input array.\n */\nexport function getDuplicateElements(arr: string[]): Set<string> {\n  const uniqueElements = new Set<string>();\n  const duplicates = new Set<string>();\n\n  arr.forEach((element: string) => {\n    if (uniqueElements.has(element)) {\n      duplicates.add(element);\n    } else {\n      uniqueElements.add(element);\n    }\n  });\n\n  return duplicates;\n}\n","import { getDuplicateElements } from \"@/utils/duplicates.js\";\nimport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  formatAbiItem,\n} from \"abitype\";\nimport {\n  type GetEventArgs,\n  type Hex,\n  type LogTopic,\n  encodeEventTopics,\n  getAbiItem,\n  getEventSelector,\n  getFunctionSelector,\n  parseAbiItem,\n} from \"viem\";\nimport type { Config } from \"./config.js\";\n\n/**\n * Fix issue with Array.isArray not checking readonly arrays\n * {@link https://github.com/microsoft/TypeScript/issues/17002}\n */\ndeclare global {\n  interface ArrayConstructor {\n    isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;\n  }\n}\n\ntype AbiEventMeta = {\n  // Event name (if no overloads) or full event signature (if name is overloaded).\n  // This is the event name used when registering indexing functions using `ponder.on(\"ContractName:EventName\", ...)`\n  safeName: string;\n  // Full event signature, e.g. `event Deposit(address indexed from,bytes32 indexed id,uint value);`\n  signature: string;\n  // Keccak256 hash of the event signature (topic[0]).\n  selector: Hex;\n  // ABI item used for decoding raw logs.\n  item: AbiEvent;\n};\n\ntype AbiFunctionMeta = {\n  // Function name (if no overloads) or full function signature (if name is overloaded).\n  // This is the function name used when registering indexing functions using `ponder.on(\"ContractName.FunctionName\", ...)`\n  safeName: string;\n  // Full function signature, e.g. `function transfer(address to,uint256 amount)`\n  signature: string;\n  // Keccak256 hash of the function signature.\n  selector: Hex;\n  // ABI item used for decoding input and output data.\n  item: AbiFunction;\n};\n\nexport type AbiEvents = {\n  bySafeName: { [key: string]: AbiEventMeta | undefined };\n  bySelector: { [key: Hex]: AbiEventMeta | undefined };\n};\n\nexport type AbiFunctions = {\n  bySafeName: { [key: string]: AbiFunctionMeta | undefined };\n  bySelector: { [key: Hex]: AbiFunctionMeta | undefined };\n};\n\nexport const buildAbiEvents = ({ abi }: { abi: Abi }) => {\n  const abiEvents = abi\n    .filter((item): item is AbiEvent => item.type === \"event\")\n    .filter((item) => item.anonymous === undefined || item.anonymous === false);\n\n  const overloadedEventNames = getDuplicateElements(\n    abiEvents.map((item) => item.name),\n  );\n\n  return abiEvents.reduce<AbiEvents>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedEventNames.has(item.name)\n        ? signature.split(\"event \")[1]\n        : item.name;\n      const selector = getEventSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n\nexport function buildTopics(\n  abi: Abi,\n  filter: NonNullable<Config[\"contracts\"][string][\"filter\"]>,\n): LogTopic[] {\n  if (Array.isArray(filter.event)) {\n    // List of event signatures\n    return [\n      filter.event.map((event) => getEventSelector(findAbiEvent(abi, event))),\n    ];\n  } else {\n    // Single event with args\n    return encodeEventTopics({\n      abi: [findAbiEvent(abi, filter.event)],\n      args: filter.args as GetEventArgs<Abi, string>,\n    });\n  }\n}\n\n/**\n * Finds the event ABI item for the event name or event signature.\n *\n * @param eventName Event name or event signature if there are duplicates\n */\nconst findAbiEvent = (abi: Abi, eventName: string): AbiEvent => {\n  if (eventName.includes(\"(\")) {\n    // full event signature\n    return parseAbiItem(`event ${eventName}`) as AbiEvent;\n  } else {\n    return getAbiItem({ abi, name: eventName }) as AbiEvent;\n  }\n};\n\nexport const buildAbiFunctions = ({ abi }: { abi: Abi }) => {\n  const abiFunctions = abi.filter(\n    (item): item is AbiFunction => item.type === \"function\",\n  );\n\n  const overloadedFunctionNames = getDuplicateElements(\n    abiFunctions.map((item) => item.name),\n  );\n\n  return abiFunctions.reduce<AbiFunctions>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedFunctionNames.has(item.name)\n        ? signature.split(\"function \")[1]\n        : `${item.name}()`;\n      const selector = getFunctionSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n","/**\n * Transforms the input string to lower case.\n */\nexport function toLowerCase<T extends string>(value: T) {\n  return value.toLowerCase() as Lowercase<T>;\n}\n","import type { AbiParameter } from \"abitype\";\nimport { InvalidAbiDecodingTypeError } from \"viem\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/5c95fafceffe7f399b5b5ee32119e2d78a0c8acd/src/utils/abi/decodeEventLog.ts\n\nexport function getBytesConsumedByParam(param: AbiParameter): number {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, innerType] = arrayComponents;\n\n    // If the array is dynamic or has dynamic children, it uses the\n    // dynamic encoding scheme (32 byte header).\n    if (!length || hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // If the length of the array is known in advance,\n    // and the length of each element in the array is known,\n    // the array data is encoded contiguously after the array.\n    const bytesConsumedByInnerType = getBytesConsumedByParam({\n      ...param,\n      type: innerType,\n    });\n    return length * bytesConsumedByInnerType;\n  }\n\n  if (param.type === \"tuple\") {\n    // If the tuple has dynamic children, it uses the dynamic encoding\n    // scheme (32 byte header).\n    if (hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // Otherwise the tuple has static children, so we can just decode\n    // each component in sequence.\n    let consumed = 0;\n    for (const component of (param as any).components ?? []) {\n      consumed += getBytesConsumedByParam(component);\n    }\n    return consumed;\n  }\n\n  // Otherwise, it's a dynamic string or bytes (32 bytes),\n  // or a static number, address, or bool (32 bytes).\n  if (\n    param.type === \"string\" ||\n    param.type.startsWith(\"bytes\") ||\n    param.type.startsWith(\"uint\") ||\n    param.type.startsWith(\"int\") ||\n    param.type === \"address\" ||\n    param.type === \"bool\"\n  ) {\n    return 32;\n  }\n\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: \"/docs/contract/decodeAbiParameters\",\n  });\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param;\n  if (type === \"string\") return true;\n  if (type === \"bytes\") return true;\n  if (type.endsWith(\"[]\")) return true;\n\n  if (type === \"tuple\") return (param as any).components?.some(hasDynamicChild);\n\n  const arrayComponents = getArrayComponents(param.type);\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true;\n\n  return false;\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined;\n}\n","import { toLowerCase } from \"@/utils/lowercase.js\";\nimport { getBytesConsumedByParam } from \"@/utils/offset.js\";\nimport type { AbiEvent } from \"abitype\";\nimport { getEventSelector } from \"viem\";\nimport type { ChildAddressCriteria } from \"./sources.js\";\n\nexport function buildChildAddressCriteria({\n  address: _address,\n  event,\n  parameter,\n}: {\n  address: `0x${string}`;\n  event: AbiEvent;\n  parameter: string;\n}): ChildAddressCriteria {\n  const address = toLowerCase(_address);\n  const eventSelector = getEventSelector(event);\n\n  // Check if the provided parameter is present in the list of indexed inputs.\n  const indexedInputPosition = event.inputs\n    .filter((x) => \"indexed\" in x && x.indexed)\n    .findIndex((input) => input.name === parameter);\n\n  if (indexedInputPosition > -1) {\n    return {\n      address,\n      eventSelector,\n      // Add 1 because inputs will not contain an element for topic0 (the signature).\n      childAddressLocation: `topic${(indexedInputPosition + 1) as 1 | 2 | 3}`,\n    };\n  }\n\n  const nonIndexedInputs = event.inputs.filter(\n    (x) => !(\"indexed\" in x && x.indexed),\n  );\n  const nonIndexedInputPosition = nonIndexedInputs.findIndex(\n    (input) => input.name === parameter,\n  );\n\n  if (nonIndexedInputPosition === -1) {\n    throw new Error(\n      `Factory event parameter not found in factory event signature. Got '${parameter}', expected one of [${event.inputs\n        .map((i) => `'${i.name}'`)\n        .join(\", \")}].`,\n    );\n  }\n\n  let offset = 0;\n  for (let i = 0; i < nonIndexedInputPosition; i++) {\n    offset += getBytesConsumedByParam(nonIndexedInputs[i]);\n  }\n\n  return {\n    address,\n    eventSelector,\n    childAddressLocation: `offset${offset}`,\n  };\n}\n","import * as _chains from \"viem/chains\";\n\nexport const chains = _chains as unknown as Record<string, _chains.Chain>;\n","import { chains } from \"@/utils/chains.js\";\nimport type { Chain, Client, Transport } from \"viem\";\n\nexport type Network = {\n  name: string;\n  chainId: number;\n  chain: Chain;\n  transport: ReturnType<Transport>;\n  pollingInterval: number;\n  maxRequestsPerSecond: number;\n  maxHistoricalTaskConcurrency: number;\n  defaultMaxBlockRange: number;\n  finalityBlockCount: number;\n};\n\nexport function getDefaultMaxBlockRange({\n  chainId,\n  rpcUrls,\n}: {\n  chainId: number;\n  rpcUrls: (string | undefined)[];\n}) {\n  let maxBlockRange: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      maxBlockRange = 2_000;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      maxBlockRange = 50_000;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      maxBlockRange = 50_000;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      maxBlockRange = 50_000;\n      break;\n    default:\n      maxBlockRange = 50_000;\n  }\n\n  const isQuickNode = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"quiknode\"));\n\n  const isCloudflare = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"cloudflare-eth\"));\n\n  if (isQuickNode) {\n    maxBlockRange = Math.min(maxBlockRange, 10_000);\n  } else if (isCloudflare) {\n    maxBlockRange = Math.min(maxBlockRange, 800);\n  }\n\n  return maxBlockRange;\n}\n\n/**\n * Returns the number of blocks that must pass before a block is considered final.\n * Note that a value of `0` indicates that blocks are considered final immediately.\n *\n * @param network The network to get the finality block count for.\n * @returns The finality block count.\n */\nexport function getFinalityBlockCount({ chainId }: { chainId: number }) {\n  let finalityBlockCount: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      finalityBlockCount = 65;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      finalityBlockCount = 200;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 42170:\n    case 421611:\n    case 421613:\n      finalityBlockCount = 240;\n      break;\n    default:\n      // Assume a 2-second block time, e.g. OP stack chains.\n      finalityBlockCount = 30;\n  }\n\n  return finalityBlockCount;\n}\n\n/**\n * Returns the list of RPC URLs backing a Transport.\n *\n * @param transport A viem Transport.\n * @returns Array of RPC URLs.\n */\nexport async function getRpcUrlsForClient(parameters: {\n  transport: Transport;\n  chain: Chain;\n}) {\n  // This is how viem converts a Transport into the Client.transport type.\n  const { config, value } = parameters.transport({\n    chain: parameters.chain,\n    pollingInterval: 4_000, // default viem value\n    retryCount: 0,\n  });\n  const transport = { ...config, ...value } as Client[\"transport\"];\n\n  async function getRpcUrlsForTransport(transport: Client[\"transport\"]) {\n    switch (transport.type) {\n      case \"http\": {\n        return [transport.url ?? parameters.chain.rpcUrls.default.http[0]];\n      }\n      case \"webSocket\": {\n        try {\n          const socket = await transport.getSocket();\n          return [socket.url];\n        } catch (e) {\n          const symbol = Object.getOwnPropertySymbols(e).find(\n            (symbol) => symbol.toString() === \"Symbol(kTarget)\",\n          );\n          if (!symbol) return [];\n          const url = (e as any)[symbol]?._url;\n          if (!url) return [];\n          return [url.replace(/\\/$/, \"\")];\n        }\n      }\n      case \"fallback\": {\n        // This is how viem converts a TransportConfig into the Client.transport type.\n        const fallbackTransports = transport.transports.map((t: any) => ({\n          ...t.config,\n          ...t.value,\n        })) as Client[\"transport\"][];\n\n        const urls: (string | undefined)[] = [];\n        for (const fallbackTransport of fallbackTransports) {\n          urls.push(...(await getRpcUrlsForTransport(fallbackTransport)));\n        }\n\n        return urls;\n      }\n      default: {\n        // TODO: Consider logging a warning here. This will catch \"custom\" and unknown transports,\n        // which we might not want to support.\n        return [];\n      }\n    }\n  }\n\n  return getRpcUrlsForTransport(transport);\n}\n\nlet publicRpcUrls: Set<string> | undefined = undefined;\n\n/**\n * Returns `true` if the RPC URL is found in the list of public RPC URLs\n * included in viem/chains. Handles both HTTP and WebSocket RPC URLs.\n *\n * @param rpcUrl An RPC URL.\n * @returns Boolean indicating if the RPC URL is public.\n */\nexport function isRpcUrlPublic(rpcUrl: string | undefined) {\n  if (rpcUrl === undefined) return true;\n\n  if (!publicRpcUrls) {\n    // By default, viem uses `chain.default.{http|webSocket}.[0]` if it exists.\n    publicRpcUrls = Object.values(chains).reduce<Set<string>>((acc, chain) => {\n      chain.rpcUrls.default.http.forEach((httpRpcUrl) => {\n        acc.add(httpRpcUrl);\n      });\n\n      (\n        (chain.rpcUrls.default as unknown as { webSocket?: string[] })\n          .webSocket ?? []\n      ).forEach((webSocketRpcUrl) => {\n        acc.add(webSocketRpcUrl);\n      });\n\n      return acc;\n    }, new Set<string>());\n  }\n\n  return publicRpcUrls.has(rpcUrl);\n}\n","import type { Abi, Address, Hex, LogTopic } from \"viem\";\nimport type { AbiEvents, AbiFunctions } from \"./abi.js\";\n\nexport type ChildAddressCriteria = {\n  address: Address;\n  eventSelector: Hex;\n  childAddressLocation: \"topic1\" | \"topic2\" | \"topic3\" | `offset${number}`;\n};\n\nexport type LogFilterCriteria = {\n  address?: Address | Address[];\n  topics: LogTopic[];\n  includeTransactionReceipts: boolean;\n};\n\nexport type FactoryLogFilterCriteria = ChildAddressCriteria & {\n  topics: LogTopic[];\n  includeTransactionReceipts: boolean;\n};\n\nexport type BlockFilterCriteria = {\n  interval: number;\n  offset: number;\n};\n\nexport type CallTraceFilterCriteria = {\n  fromAddress?: Address[];\n  toAddress?: Address[];\n  includeTransactionReceipts: boolean;\n  functionSelectors: Hex[];\n};\n\nexport type FactoryCallTraceFilterCriteria = ChildAddressCriteria & {\n  fromAddress?: Address[];\n  includeTransactionReceipts: boolean;\n  functionSelectors: Hex[];\n};\n\nexport type LogSource = {\n  type: \"log\";\n  /** `log_${contractName}_${networkName}` */\n  id: string;\n  criteria: LogFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiEvents: AbiEvents;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type FactoryLogSource = {\n  type: \"factoryLog\";\n  /** `log_${contractName}_${networkName}` */\n  id: string;\n  criteria: FactoryLogFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiEvents: AbiEvents;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type BlockSource = {\n  type: \"block\";\n  /** `block_${sourceName}_${networkName}` */\n  id: string;\n  criteria: BlockFilterCriteria;\n  sourceName: string;\n  networkName: string;\n  chainId: number;\n  startBlock: number;\n  endBlock?: number;\n};\n\nexport type CallTraceSource = {\n  type: \"callTrace\";\n  /** `callTrace_${contractName}_${networkName}` */\n  id: string;\n  criteria: CallTraceFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiFunctions: AbiFunctions;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type FactoryCallTraceSource = {\n  type: \"factoryCallTrace\";\n  /** `callTrace_${contractName}_${networkName}` */\n  id: string;\n  criteria: FactoryCallTraceFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiFunctions: AbiFunctions;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type EventSource =\n  | LogSource\n  | FactoryLogSource\n  | CallTraceSource\n  | FactoryCallTraceSource\n  | BlockSource;\n\nexport const sourceIsLog = (\n  source: Pick<EventSource, \"type\">,\n): source is LogSource => source.type === \"log\";\n\nexport const sourceIsFactoryLog = (\n  source: Pick<EventSource, \"type\">,\n): source is FactoryLogSource => source.type === \"factoryLog\";\n\nexport const sourceIsCallTrace = (\n  source: Pick<EventSource, \"type\">,\n): source is CallTraceSource => source.type === \"callTrace\";\n\nexport const sourceIsFactoryCallTrace = (\n  source: Pick<EventSource, \"type\">,\n): source is FactoryCallTraceSource => source.type === \"factoryCallTrace\";\n\nexport const sourceIsBlock = (\n  source: Pick<EventSource, \"type\">,\n): source is BlockSource => source.type === \"block\";\n","export type PromiseWithResolvers<TPromise> = {\n  resolve: (arg: TPromise) => void;\n  reject: (error: Error) => void;\n  promise: Promise<TPromise>;\n};\n\n/**\n * @description Application level polyfill.\n */\nexport const promiseWithResolvers = <\n  TPromise,\n>(): PromiseWithResolvers<TPromise> => {\n  let resolve: (arg: TPromise) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<TPromise>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { resolve: resolve!, reject: reject!, promise };\n};\n","/**\n * Creates a debounced function that waits ms milliseconds between invocations.\n * If the function is called multiple times between invocations, the latest\n * arguments passed to the function will be used.\n */\nexport function debounce<param extends unknown[], returnType>(\n  ms: number,\n  fn: (...x: param) => returnType,\n) {\n  let args: param;\n  let timeoutSet = false;\n  let timeout: NodeJS.Timeout;\n\n  return {\n    call: (..._args: param) => {\n      args = _args;\n\n      if (!timeoutSet) {\n        timeoutSet = true;\n        timeout = setTimeout(() => {\n          timeoutSet = false;\n          fn(...args);\n        }, ms);\n      }\n    },\n    cancel: () => {\n      clearTimeout(timeout);\n    },\n  };\n}\n","/**\n * Remove duplicate values from an array.\n *\n * @param getId callback used to calculate a unique value for an element of the array.\n *\n * @example\n * dedupe([1,1,2,3]) // [1,2,3]\n *\n * dedupe(\n *   [\n *     { a: 1, b: 2 },\n *     { a: 1, b: 2 },\n *     { a: 2, b: 2 },\n *   ],\n *   (e) => `${e.a}_${e.b}`,\n * ) // [{a: 1, b: 2}, {a: 2, b: 2}]\n *\n */\nexport function dedupe<item, id>(arr: item[], getId?: (x: item) => id): item[] {\n  const seen = new Set<id | item>();\n\n  return arr.filter((x) => {\n    if (seen.has(getId ? getId(x) : x)) return false;\n\n    seen.add(x);\n    return true;\n  });\n}\n\ndedupe(\n  [\n    { a: 1, b: 2 },\n    { a: 1, b: 2 },\n    { a: 2, b: 2 },\n  ],\n  (e) => `${e.a}_${e.b}`,\n);\n","import {\n  type PromiseWithResolvers,\n  promiseWithResolvers,\n} from \"./promiseWithResolvers.js\";\n\nexport type InnerQueue<returnType, taskType> = {\n  task: taskType;\n  resolve: (arg: returnType) => void;\n  reject: (error: Error) => void;\n}[];\n\nexport type Queue<returnType, taskType> = {\n  size: () => number;\n  pending: () => Promise<number>;\n  add: (task: taskType) => Promise<returnType>;\n  clear: () => void;\n  isStarted: () => boolean;\n  start: () => Promise<void>;\n  pause: () => void;\n  onIdle: () => Promise<void>;\n  onEmpty: () => Promise<void>;\n  setParameters: (\n    parameters: Pick<\n      CreateQueueParameters<unknown, unknown>,\n      \"frequency\" | \"concurrency\"\n    >,\n  ) => void;\n};\n\nexport type CreateQueueParameters<returnType, taskType> = {\n  worker: (task: taskType) => Promise<returnType>;\n  initialStart?: boolean;\n  browser?: boolean;\n} & (\n  | {\n      concurrency: number;\n      frequency: number;\n    }\n  | { concurrency: number; frequency?: undefined }\n  | { concurrency?: undefined; frequency: number }\n);\n\nconst validateParameters = ({\n  concurrency,\n  frequency,\n}: Pick<\n  CreateQueueParameters<unknown, unknown>,\n  \"frequency\" | \"concurrency\"\n>) => {\n  if (concurrency === undefined && frequency === undefined) {\n    throw Error(\n      \"Invalid queue configuration, must specify either 'concurrency' or 'frequency'.\",\n    );\n  }\n\n  if (concurrency !== undefined && concurrency <= 0) {\n    throw Error(\n      `Invalid value for queue 'concurrency' option. Got ${concurrency}, expected a number greater than zero.`,\n    );\n  }\n\n  if (frequency !== undefined && frequency <= 0) {\n    throw Error(\n      `Invalid value for queue 'frequency' option. Got ${frequency}, expected a number greater than zero.`,\n    );\n  }\n};\n\nexport const createQueue = <returnType, taskType = void>({\n  worker,\n  initialStart = false,\n  browser = true,\n  ..._parameters\n}: CreateQueueParameters<returnType, taskType>): Queue<\n  returnType,\n  taskType\n> => {\n  validateParameters(_parameters);\n\n  const parameters: Pick<\n    CreateQueueParameters<unknown, unknown>,\n    \"frequency\" | \"concurrency\"\n  > = _parameters;\n  let queue = new Array<InnerQueue<returnType, taskType>[number]>();\n  let pending = 0;\n  let timestamp = 0;\n  let requests = 0;\n  let isStarted = initialStart;\n\n  let timer: NodeJS.Timeout | undefined;\n\n  let emptyPromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n  let idlePromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n\n  const next = () => {\n    if (!isStarted) return;\n\n    const _timestamp = Date.now();\n\n    if (Math.floor(_timestamp / 1_000) !== timestamp) {\n      requests = 0;\n      timestamp = Math.floor(_timestamp / 1_000);\n    }\n\n    if (timer) return;\n\n    while (\n      (parameters.frequency !== undefined\n        ? requests < parameters.frequency\n        : true) &&\n      (parameters.concurrency !== undefined\n        ? pending < parameters.concurrency\n        : true) &&\n      queue.length > 0\n    ) {\n      const { task, resolve, reject } = queue.shift()!;\n\n      requests++;\n      pending++;\n\n      worker(task)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          pending--;\n\n          if (\n            idlePromiseWithResolvers !== undefined &&\n            queue.length === 0 &&\n            pending === 0\n          ) {\n            idlePromiseWithResolvers.resolve();\n            idlePromiseWithResolvers.completed = true;\n          }\n\n          browser ? next() : process.nextTick(next);\n        });\n\n      if (emptyPromiseWithResolvers !== undefined && queue.length === 0) {\n        emptyPromiseWithResolvers.resolve();\n        emptyPromiseWithResolvers.completed = true;\n      }\n    }\n\n    if (\n      parameters.frequency !== undefined &&\n      requests >= parameters.frequency\n    ) {\n      timer = setTimeout(\n        () => {\n          timer = undefined;\n          next();\n        },\n        1_000 - (_timestamp % 1_000),\n      );\n      return;\n    }\n  };\n\n  return {\n    size: () => queue.length,\n    pending: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        );\n      } else {\n        return new Promise<number>((resolve) =>\n          setImmediate(() => resolve(pending)),\n        );\n      }\n    },\n    add: (task: taskType) => {\n      const { promise, resolve, reject } = promiseWithResolvers<returnType>();\n      queue.push({ task, resolve, reject });\n\n      next();\n\n      return promise;\n    },\n    clear: () => {\n      queue = new Array<InnerQueue<returnType, taskType>[number]>();\n      clearTimeout(timer);\n      timer = undefined;\n    },\n    isStarted: () => isStarted,\n    start: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      } else {\n        return new Promise<number>((resolve) =>\n          process.nextTick(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      }\n    },\n    pause: () => {\n      isStarted = false;\n    },\n    onIdle: () => {\n      if (\n        idlePromiseWithResolvers === undefined ||\n        idlePromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0 && pending === 0) return Promise.resolve();\n\n        idlePromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return idlePromiseWithResolvers.promise;\n    },\n    onEmpty: () => {\n      if (\n        emptyPromiseWithResolvers === undefined ||\n        emptyPromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0) return Promise.resolve();\n\n        emptyPromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return emptyPromiseWithResolvers.promise;\n    },\n    setParameters: (_parameters) => {\n      validateParameters(_parameters);\n\n      if (\"frequency\" in _parameters) {\n        parameters.frequency = _parameters.frequency;\n      }\n      if (\"concurrency\" in _parameters) {\n        parameters.concurrency = _parameters.concurrency;\n      }\n    },\n  } as Queue<returnType, taskType>;\n};\n","import MagicString from \"magic-string\";\nimport type { Plugin } from \"vite\";\n\nexport const regex =\n  /^import\\s+\\{[^}]*\\bponder\\b[^}]*\\}\\s+from\\s+[\"']@\\/generated[\"'];?.*$/gm;\n\nexport const shim = `export let ponder = {\n  fns: [],\n  on(name, fn) {\n    this.fns.push({ name, fn });\n  },\n};\n`;\n\nexport function replaceStateless(code: string) {\n  const s = new MagicString(code);\n  // MagicString.replace calls regex.exec(), which increments `lastIndex`\n  // on a match. We have to set this back to zero to use the same regex\n  // multiple times.\n  regex.lastIndex = 0;\n  s.replace(regex, shim);\n  return s;\n}\n\nexport const vitePluginPonder = (): Plugin => {\n  return {\n    name: \"ponder\",\n    transform: (code, id) => {\n      if (regex.test(code)) {\n        const s = replaceStateless(code);\n        const transformed = s.toString();\n        const sourcemap = s.generateMap({ source: id });\n\n        return { code: transformed, map: sourcemap };\n      } else {\n        return null;\n      }\n    },\n  };\n};\n","import type { Schema } from \"@/schema/common.js\";\nimport {\n  extractReferenceTable,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n  isReferenceColumn,\n} from \"@/schema/utils.js\";\nimport { dedupe } from \"@ponder/common\";\n\nexport const buildSchema = ({ schema }: { schema: Schema }) => {\n  const logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[] = [];\n\n  // Validate enums\n  Object.entries(getEnums(schema)).forEach(([name, _enum]) => {\n    validateTableOrColumnName(name, \"Enum\");\n\n    const enumValues = new Set<string>();\n    for (const enumValue of _enum) {\n      if (enumValues.has(enumValue)) {\n        throw new Error(\n          `Validation failed: Enum '${name}' contains duplicate value '${enumValue}'.`,\n        );\n      }\n      enumValues.add(enumValue);\n    }\n  });\n\n  // Validate tables\n  Object.entries(getTables(schema)).forEach(\n    ([tableName, { table, constraints }]) => {\n      validateTableOrColumnName(tableName, \"Table\");\n\n      // Validate the id column\n      if (table.id === undefined)\n        throw new Error(\n          `Validation failed: Table '${tableName}' does not have an 'id' column.`,\n        );\n\n      if (isJSONColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isEnumColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'enum', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isOneColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isManyColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isReferenceColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot use the '.references' modifier.`,\n        );\n\n      if (\n        table.id[\" scalar\"] !== \"bigint\" &&\n        table.id[\" scalar\"] !== \"string\" &&\n        table.id[\" scalar\"] !== \"hex\" &&\n        table.id[\" scalar\"] !== \"int\"\n      )\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got '${table.id[\" scalar\"]}', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n\n      if (isOptionalColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be optional.`,\n        );\n      if (isListColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be a list.`,\n        );\n\n      // Validate all other columns\n      Object.entries(table).forEach(([columnName, column]) => {\n        if (columnName === \"id\") return;\n\n        validateTableOrColumnName(columnName, \"Column\");\n\n        if (isOneColumn(column)) {\n          const usedColumn = Object.entries(table).find(\n            ([c]) => c === column[\" reference\"],\n          );\n\n          if (usedColumn === undefined) {\n            const otherColumns = Object.keys(table).filter(\n              (c) => c !== columnName,\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n                column[\" reference\"]\n              }', expected one of [${otherColumns\n                .map((c) => `'${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          if (!isReferenceColumn(usedColumn[1])) {\n            const foreignKeyColumns = Object.keys(table).filter(\n              (c) => c !== columnName && isReferenceColumn(table[c]),\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n                column[\" reference\"]\n              }', expected one of [${foreignKeyColumns\n                .map((c) => `'${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isManyColumn(column)) {\n          const usedTable = Object.entries(getTables(schema)).find(\n            ([name]) => name === column[\" referenceTable\"],\n          );\n\n          if (usedTable === undefined) {\n            const otherTables = Object.keys(getTables(schema)).filter(\n              (t) => t !== tableName,\n            );\n\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a table that does not exist. Got '${\n                column[\" referenceTable\"]\n              }', expected one of [${otherTables\n                .map((t) => `'${t}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          const usedTableColumns = Object.entries(usedTable[1].table);\n          const usedColumn = usedTableColumns.find(\n            ([columnName]) => columnName === column[\" referenceColumn\"],\n          );\n\n          if (usedColumn === undefined) {\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n                column[\" referenceTable\"]\n              }.${\n                column[\" referenceTable\"]\n              }', expected one of [${usedTableColumns\n                .map((c) => `'${usedTable[0]}.${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          if (!isReferenceColumn(usedColumn[1])) {\n            const foreignKeyColumnNames = usedTableColumns.filter(([, c]) =>\n              isReferenceColumn(c),\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n                column[\" referenceTable\"]\n              }.${\n                column[\" referenceTable\"]\n              }', expected one of [${foreignKeyColumnNames\n                .map((c) => `'${usedTable[0]}.${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isEnumColumn(column)) {\n          const referencedEnum = Object.entries(getEnums(schema)).find(\n            ([enumName]) => enumName === column[\" enum\"],\n          );\n          if (referencedEnum === undefined) {\n            throw new Error(\n              `Validation failed: Enum column '${tableName}.${columnName}' doesn't reference a valid enum. Got '${\n                column[\" enum\"]\n              }', expected one of [${Object.keys(getEnums(schema))\n                .map((e) => `'${e}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isReferenceColumn(column)) {\n          const referencedTable = Object.entries(getTables(schema)).find(\n            ([tableName]) => tableName === extractReferenceTable(column),\n          );\n\n          if (referencedTable === undefined) {\n            throw new Error(\n              `Validation failed: Foreign key column '${tableName}.${columnName}' does not reference a valid ID column. Got '${extractReferenceTable(\n                column,\n              )}', expected one of [${Object.keys(getTables(schema))\n                .map((t) => `'${t}.id'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          if (referencedTable[1].table.id[\" scalar\"] !== column[\" scalar\"]) {\n            throw new Error(\n              `Validation failed: Foreign key column '${tableName}.${columnName}' type does not match the referenced table's ID column type. Got '${column[\" scalar\"]}', expected '${referencedTable[1].table.id[\" scalar\"]}'.`,\n            );\n          }\n\n          // NOTE: This is unreachable, but worth documenting here.\n          // if (column.list) {\n          //   throw new Error(\n          //     `Validation failed: Foreign key column '${tableName}.${columnName}' cannot use the 'list' modifier.`,\n          //   );\n          // }\n        }\n\n        // NOTE: This is unreachable, but worth documenting here.\n        // if (isPrimitiveColumn(column)) {\n        //   if (\n        //     column.type !== \"bigint\" &&\n        //     column.type !== \"string\" &&\n        //     column.type !== \"boolean\" &&\n        //     column.type !== \"int\" &&\n        //     column.type !== \"float\" &&\n        //     column.type !== \"hex\"\n        //   ) {\n        //     throw new Error(\n        //       `Validation failed: Primitive column '${tableName}.${columnName}' type is invalid. Got '${column.type}', expected one of ['bigint', 'string', 'boolean', 'int', 'float', 'hex'].`,\n        //     );\n        //   }\n        // }\n      });\n\n      // Validate constraints\n      if (constraints === undefined) return;\n\n      for (const [name, index] of Object.entries(constraints)) {\n        validateTableOrColumnName(name, \"index\");\n        const column = index[\" column\"];\n\n        if (Array.isArray(column)) {\n          if (column.length === 0)\n            throw new Error(\n              `Validation failed: Index '${name}' cannot be empty.`,\n            );\n\n          if (column.length !== dedupe(column as string[]).length)\n            throw new Error(\n              `Validation failed: Index '${name}' cannot contain duplicate columns.`,\n            );\n\n          for (const c of column) {\n            if (table[c] === undefined)\n              throw new Error(\n                `Validation failed: Index '${name}' does not reference a valid column. Got '${c}', expected one of [${Object.keys(\n                  table,\n                ).join(\", \")}].`,\n              );\n\n            if (isJSONColumn(table[c]))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n\n            if (isOneColumn(table[c]))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n\n            if (isManyColumn(table[c]))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n          }\n        } else {\n          if (column === \"id\") {\n            logs.push({\n              level: \"warn\",\n              msg: `Ignoring index '${name}'. Column 'id' has a primary key constraint by default.`,\n            });\n            delete constraints[name];\n            continue;\n          }\n\n          if (table[column] === undefined)\n            throw new Error(\n              `Validation failed: Index '${name}' does not reference a valid column. Got '${column}', expected one of [${Object.entries(\n                table,\n              )\n                .filter(\n                  ([_, column]) =>\n                    !isOneColumn(column) && !isManyColumn(column),\n                )\n                .map(([columnName]) => columnName)\n                .join(\", \")}].`,\n            );\n\n          if (isJSONColumn(table[column]))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n\n          if (isOneColumn(table[column]))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n\n          if (isManyColumn(table[column]))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n        }\n      }\n    },\n  );\n\n  return { schema, logs };\n};\n\nconst validateTableOrColumnName = (key: string, type: string) => {\n  if (key === \"\")\n    throw new Error(\n      `Validation failed: ${type} name can't be an empty string.`,\n    );\n\n  if (!/^[a-z|A-Z|0-9]+$/.test(key))\n    throw new Error(\n      `Validation failed: ${type} name '${key}' contains an invalid character.`,\n    );\n};\n\nexport function safeBuildSchema({ schema }: { schema: Schema }) {\n  try {\n    const result = buildSchema({ schema });\n    return {\n      status: \"success\",\n      schema: result.schema,\n      logs: result.logs,\n    } as const;\n  } catch (error_) {\n    const error = error_ as Error;\n    return { status: \"error\", error } as const;\n  }\n}\n","import { readFileSync } from \"node:fs\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { parse as parseStackTrace } from \"stacktrace-parser\";\n\nclass ESBuildTransformError extends Error {\n  override name = \"ESBuildTransformError\";\n}\n\nclass ESBuildBuildError extends Error {\n  override name = \"ESBuildBuildError\";\n}\n\nclass ESBuildContextError extends Error {\n  override name = \"ESBuildContextError\";\n}\n\ntype ViteNodeError =\n  | ESBuildTransformError\n  | ESBuildBuildError\n  | ESBuildContextError\n  | Error;\n\nexport function parseViteNodeError(file: string, error: Error): ViteNodeError {\n  let resolvedError: ViteNodeError;\n\n  if (/^(Transform failed|Build failed|Context failed)/.test(error.message)) {\n    // Handle ESBuild errors based on this error message construction logic:\n    // https://github.com/evanw/esbuild/blob/4e11b50fe3178ed0a78c077df78788d66304d379/lib/shared/common.ts#L1659\n    const errorKind = error.message.split(\" with \")[0] as\n      | \"Transform failed\"\n      | \"Build failed\"\n      | \"Context failed\";\n    const innerError = error.message\n      .split(\"\\n\")\n      .slice(1)\n      .map((message) => {\n        let location: string | undefined = undefined;\n        let detail: string | undefined = undefined;\n        if (message.includes(\": ERROR: \")) {\n          // /path/to/file.ts:11:9: ERROR: Expected \")\" but found \";\"\n          const s = message.split(\": ERROR: \");\n          location = s[0];\n          detail = s[1];\n        } else {\n          // error: some error without a location\n          detail = message.slice(7);\n        }\n        return { location, detail };\n      })[0];\n\n    // If we aren't able to extract an inner error, just return the original.\n    if (!innerError) return error;\n\n    resolvedError =\n      errorKind === \"Transform failed\"\n        ? new ESBuildTransformError(innerError.detail)\n        : errorKind === \"Build failed\"\n          ? new ESBuildBuildError(innerError.detail)\n          : new ESBuildContextError(innerError.detail);\n    if (innerError.location)\n      resolvedError.stack = `    at ${innerError.location}`;\n  }\n  // If it's not an ESBuild error, it's a user-land vm.runModuleInContext execution error.\n  // Attempt to build a user-land stack trace.\n  else if (error.stack) {\n    const stackFrames = parseStackTrace(error.stack);\n\n    const userStackFrames = [];\n    for (const rawStackFrame of stackFrames) {\n      if (rawStackFrame.methodName.includes(\"ViteNodeRunner.runModule\")) break;\n      userStackFrames.push(rawStackFrame);\n    }\n\n    const userStack = userStackFrames\n      .map(({ file, lineNumber, column, methodName }) => {\n        const prefix = \"    at\";\n        const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n          column !== null ? `:${column}` : \"\"\n        }`;\n        if (methodName === null || methodName === \"<unknown>\") {\n          return `${prefix} ${path}`;\n        } else {\n          return `${prefix} ${methodName} (${path})`;\n        }\n      })\n      .join(\"\\n\");\n\n    resolvedError = error;\n    resolvedError.stack = userStack;\n  }\n  // Still a vm.runModuleInContext execution error, but no stack.\n  else {\n    resolvedError = error;\n  }\n\n  // Attempt to build a code frame for the top of the user stack. This works for\n  // both ESBuild and vm.runModuleInContext errors.\n  if (resolvedError.stack) {\n    const userStackFrames = parseStackTrace(resolvedError.stack);\n\n    let codeFrame: string | undefined = undefined;\n    for (const { file, lineNumber, column } of userStackFrames) {\n      if (file !== null && lineNumber !== null) {\n        try {\n          const sourceFileContents = readFileSync(file, { encoding: \"utf-8\" });\n          codeFrame = codeFrameColumns(\n            sourceFileContents,\n            { start: { line: lineNumber, column: column ?? undefined } },\n            { highlightCode: true },\n          );\n          break;\n        } catch (err) {\n          // No-op.\n        }\n      }\n    }\n\n    resolvedError.stack = `${resolvedError.name}: ${resolvedError.message}\\n${resolvedError.stack}`;\n    if (codeFrame) resolvedError.stack += `\\n${codeFrame}`;\n  }\n\n  // Finally, add a useful relative file name and verb to the error message.\n  const verb =\n    resolvedError.name === \"ESBuildTransformError\"\n      ? \"transforming\"\n      : resolvedError.name === \"ESBuildBuildError\" ||\n          resolvedError.name === \"ESBuildContextError\"\n        ? \"building\"\n        : \"executing\";\n  resolvedError.message = `Error while ${verb} ${file}: ${resolvedError.message}`;\n\n  return resolvedError;\n}\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport { create, kill, start } from \"./service.js\";\nimport type { Build, BuildResult, Service } from \"./service.js\";\n\nconst methods = {\n  start,\n  kill,\n};\n\nexport const createBuildService = extend(create, methods);\n\nexport type BuildService = Extend<Service, typeof methods>;\n\nexport type { BuildResult, Build };\n","import { mkdirSync, writeFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport type { GraphQLSchema } from \"graphql\";\nimport { printSchema } from \"graphql\";\n\nexport const ponderEnv = `// This file enables type checking and editor autocomplete for this Ponder project.\n// After upgrading, you may find that changes have been made to this file.\n// If this happens, please commit the changes. Do not manually edit this file.\n// See https://ponder.sh/docs/guides/typescript for more information.\n\ndeclare module \"@/generated\" {\n  import type { Virtual } from \"@ponder/core\";\n\n  type config = typeof import(\"./ponder.config.ts\").default;\n  type schema = typeof import(\"./ponder.schema.ts\").default;\n\n  export const ponder: Virtual.Registry<config, schema>;\n\n  export type EventNames = Virtual.EventNames<config>;\n  export type Event<name extends EventNames = EventNames> = Virtual.Event<\n    config,\n    name\n  >;\n  export type Context<name extends EventNames = EventNames> = Virtual.Context<\n    config,\n    schema,\n    name\n  >;\n  export type IndexingFunctionArgs<name extends EventNames = EventNames> =\n    Virtual.IndexingFunctionArgs<config, schema, name>;\n  export type Schema = Virtual.Schema<schema>;\n}\n`;\n\nexport function runCodegen({\n  common,\n  graphqlSchema,\n}: {\n  common: Common;\n  graphqlSchema: GraphQLSchema;\n}) {\n  writeFileSync(\n    path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n    ponderEnv,\n    \"utf8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at ponder-env.d.ts\",\n  });\n\n  mkdirSync(common.options.generatedDir, { recursive: true });\n  writeFileSync(\n    path.join(common.options.generatedDir, \"schema.graphql\"),\n    printSchema(graphqlSchema),\n    \"utf-8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at generated/schema.graphql\",\n  });\n}\n","import type { Prettify } from \"@/types/utils.js\";\nimport pc from \"picocolors\";\nimport { type DestinationStream, type LevelWithSilent, pino } from \"pino\";\n\nexport type LogMode = \"pretty\" | \"structured\";\nexport type LogLevel = Prettify<LevelWithSilent>;\nexport type Logger = ReturnType<typeof createLogger>;\n\ntype LogOptions = { msg: string; service: string } & { [key: string]: any };\n\nexport function createLogger({\n  level,\n  mode = \"pretty\",\n}: { level: LogLevel; mode?: LogMode }) {\n  const stream: DestinationStream = {\n    write(logString: string) {\n      if (mode === \"structured\") {\n        // Remove trailing newline character. Note that this is bad for performance.\n        console.log(logString.trimEnd());\n        return;\n      }\n\n      const log = JSON.parse(logString);\n      const prettyLog = format(log);\n      console.log(prettyLog);\n\n      // If there is an \"error\" property, log the stack trace.\n      if (log.error) {\n        const message = log.error.stack ?? log.error.message ?? log.error;\n        console.log(message);\n        if (typeof log.error?.meta === \"string\") console.log(log.error.meta);\n        if (Array.isArray(log.error?.meta))\n          console.log(log.error.meta.join(\"\\n\"));\n      }\n    },\n  };\n\n  const logger = pino(\n    {\n      level,\n      serializers: { error: pino.stdSerializers.errWithCause },\n      // Removes \"pid\" and \"hostname\" properties from the log.\n      base: undefined,\n    },\n    stream,\n  );\n\n  return {\n    fatal(options: LogOptions) {\n      logger.fatal(options);\n    },\n    error(options: LogOptions & { error: Error }) {\n      logger.error(options);\n    },\n    warn(options: LogOptions) {\n      logger.warn(options);\n    },\n    info(options: LogOptions) {\n      logger.info(options);\n    },\n    debug(options: LogOptions) {\n      logger.debug(options);\n    },\n    trace(options: LogOptions) {\n      logger.trace(options);\n    },\n    async kill() {\n      // TODO: Ask kyle about this\n      // return new Promise<void>((resolve, reject) => {\n      //   logger.flush((error) => {\n      //     if (error) {\n      //       reject(error);\n      //     } else {\n      //       resolve();\n      //     }\n      //   });\n      // }),\n    },\n  };\n}\n\nconst levels = {\n  60: { label: \"FATAL\", colorLabel: pc.bgRed(\"FATAL\") },\n  50: { label: \"ERROR\", colorLabel: pc.red(\"ERROR\") },\n  40: { label: \"WARN \", colorLabel: pc.yellow(\"WARN \") },\n  30: { label: \"INFO \", colorLabel: pc.green(\"INFO \") },\n  20: { label: \"DEBUG\", colorLabel: pc.blue(\"DEBUG\") },\n  10: { label: \"TRACE\", colorLabel: pc.gray(\"TRACE\") },\n} as const;\n\nconst timeFormatter = new Intl.DateTimeFormat(undefined, {\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\",\n});\n\nconst format = (log: LogOptions) => {\n  const time = timeFormatter.format(new Date(log.time));\n  const message = log.msg ?? log.error?.message;\n\n  const levelObject =\n    levels[(log.level as keyof typeof levels) ?? 30] ?? levels[30];\n\n  if (pc.isColorSupported) {\n    const level = levelObject.colorLabel;\n    const service = log.service ? pc.cyan(log.service.padEnd(10, \" \")) : \"\";\n    const messageText = pc.reset(message);\n    return `${pc.gray(time)} ${level} ${service} ${messageText}`;\n  } else {\n    const level = levelObject.label;\n    const service = log.service ? log.service.padEnd(10, \" \") : \"\";\n    return `${time} ${level} ${service} ${message}`;\n  }\n};\n","import prometheus from \"prom-client\";\n\nconst databaseQueryDurationMs = [\n  0.05, 0.1, 1, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000,\n  7_500, 10_000, 25_000,\n];\n\nconst httpRequestDurationMs = [\n  5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000, 7_500, 10_000,\n  25_000,\n];\n\nconst httpRequestSizeBytes = [\n  10, 100, 1_000, 5_000, 10_000, 50_000, 100_000, 500_000, 1_000_000, 5_000_000,\n  10_000_000,\n];\n\nexport class MetricsService {\n  registry: prometheus.Registry;\n\n  ponder_indexing_total_seconds: prometheus.Gauge;\n  ponder_indexing_completed_seconds: prometheus.Gauge;\n  ponder_indexing_completed_events: prometheus.Gauge<\"network\" | \"event\">;\n\n  ponder_indexing_completed_timestamp: prometheus.Gauge;\n  ponder_indexing_has_error: prometheus.Gauge;\n\n  ponder_indexing_function_duration: prometheus.Histogram<\"network\" | \"event\">;\n  ponder_indexing_function_error_total: prometheus.Counter<\"network\" | \"event\">;\n\n  ponder_historical_start_timestamp: prometheus.Gauge<\"network\">;\n  ponder_historical_total_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n  ponder_historical_cached_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n  ponder_historical_completed_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n\n  ponder_realtime_is_connected: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_number: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_timestamp: prometheus.Gauge<\"network\">;\n  ponder_realtime_reorg_total: prometheus.Counter<\"network\">;\n\n  ponder_database_method_duration: prometheus.Histogram<\"service\" | \"method\">;\n  ponder_database_method_error_total: prometheus.Counter<\"service\" | \"method\">;\n\n  ponder_http_server_port: prometheus.Gauge;\n  ponder_http_server_active_requests: prometheus.Gauge<\"method\" | \"path\">;\n  ponder_http_server_request_duration_ms: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_request_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_response_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n\n  ponder_rpc_request_duration: prometheus.Histogram<\"network\" | \"method\">;\n  ponder_rpc_request_lag: prometheus.Histogram<\"network\" | \"method\">;\n\n  ponder_postgres_pool_connections: prometheus.Gauge<\"pool\" | \"kind\"> = null!;\n  ponder_postgres_query_queue_size: prometheus.Gauge<\"pool\"> = null!;\n  ponder_postgres_query_total: prometheus.Counter<\"pool\"> = null!;\n\n  ponder_sqlite_query_total: prometheus.Counter<\"database\"> = null!;\n\n  constructor() {\n    this.registry = new prometheus.Registry();\n\n    this.ponder_indexing_total_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_total_seconds\",\n      help: \"Total number of seconds that are required\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_seconds\",\n      help: \"Number of seconds that have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_events = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_events\",\n      help: \"Number of events that have been processed\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_timestamp = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_timestamp\",\n      help: \"Timestamp through which all events have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_has_error = new prometheus.Gauge({\n      name: \"ponder_indexing_has_error\",\n      help: \"Boolean (0 or 1) indicating if there is an indexing error\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_function_duration = new prometheus.Histogram({\n      name: \"ponder_indexing_function_duration\",\n      help: \"Duration of indexing function execution\",\n      labelNames: [\"network\", \"event\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_function_error_total = new prometheus.Counter({\n      name: \"ponder_indexing_function_error_total\",\n      help: \"Total number of errors encountered during indexing function execution\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_historical_start_timestamp = new prometheus.Gauge({\n      name: \"ponder_historical_start_timestamp\",\n      help: \"Unix timestamp (ms) when the historical sync service started\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_total_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_total_blocks\",\n      help: \"Number of blocks required for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_cached_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_cached_blocks\",\n      help: \"Number of blocks that were found in the cache for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_completed_blocks\",\n      help: \"Number of blocks that have been processed for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_realtime_is_connected = new prometheus.Gauge({\n      name: \"ponder_realtime_is_connected\",\n      help: \"Boolean (0 or 1) indicating if the historical sync service is connected\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_number = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_number\",\n      help: \"Block number of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_timestamp = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_timestamp\",\n      help: \"Block timestamp of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_reorg_total = new prometheus.Counter({\n      name: \"ponder_realtime_reorg_total\",\n      help: \"Count of how many re-orgs have occurred.\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_database_method_duration = new prometheus.Histogram({\n      name: \"ponder_database_method_duration\",\n      help: \"Duration of database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_database_method_error_total = new prometheus.Counter({\n      name: \"ponder_database_method_error_total\",\n      help: \"Total number of errors encountered during database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_http_server_port = new prometheus.Gauge({\n      name: \"ponder_http_server_port\",\n      help: \"Port that the server is listening on\",\n      registers: [this.registry],\n    });\n    this.ponder_http_server_active_requests = new prometheus.Gauge({\n      name: \"ponder_http_server_active_requests\",\n      help: \"Number of active HTTP server requests\",\n      labelNames: [\"method\", \"path\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_duration_ms = new prometheus.Histogram({\n      name: \"ponder_http_server_request_duration_ms\",\n      help: \"Duration of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_request_size_bytes\",\n      help: \"Size of HTTP requests received by the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_response_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_response_size_bytes\",\n      help: \"Size of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n\n    this.ponder_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_rpc_request_duration\",\n      help: \"Duration of RPC requests\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_rpc_request_lag = new prometheus.Histogram({\n      name: \"ponder_rpc_request_lag\",\n      help: \"Time RPC requests spend waiting in the request queue\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n\n    prometheus.collectDefaultMetrics({ register: this.registry });\n  }\n\n  /**\n   * Get string representation for all metrics.\n   * @returns Metrics encoded using Prometheus v0.0.4 format.\n   */\n  async getMetrics() {\n    return await this.registry.metrics();\n  }\n\n  resetMetrics() {\n    this.registry.resetMetrics();\n  }\n}\n\nexport async function getHistoricalSyncProgress(metrics: MetricsService) {\n  // Historical sync table\n  const startTimestampMetric =\n    (await metrics.ponder_historical_start_timestamp.get()).values?.[0]\n      ?.value ?? Date.now();\n\n  /** Aggregate block metrics for different \"types\" of sources. */\n  const reduceBlockMetrics = (\n    values: prometheus.MetricValue<\"network\" | \"source\" | \"type\">[],\n  ) =>\n    values.reduce<{\n      [id: string]: {\n        labels: { source: string; network: string };\n        value: number;\n      };\n    }>((acc, cur) => {\n      const id = `${cur.labels.source}_${cur.labels.network}_${\n        cur.labels.type === \"block\" ? \"block\" : \"contract\"\n      }`;\n\n      if (acc[id] === undefined) {\n        acc[id] = {\n          labels: {\n            source: cur.labels.source as string,\n            network: cur.labels.network as string,\n          },\n          value: cur.value,\n        };\n      } else {\n        // Note: entries in `values` with the same `id` have the same \"total\"\n        // block range. Using `Math.min()` ensures that a contract with both\n        // \"callTrace\" and \"log\" type sources are displayed correctly.\n        acc[id].value = Math.min(acc[id].value, cur.value);\n      }\n\n      return acc;\n    }, {});\n\n  const cachedBlocksMetric = await metrics.ponder_historical_cached_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n  const totalBlocksMetric = await metrics.ponder_historical_total_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n  const completedBlocksMetric = await metrics.ponder_historical_completed_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n\n  const sources = Object.entries(totalBlocksMetric).map(\n    ([\n      id,\n      {\n        labels: { source, network },\n        value: totalBlocks,\n      },\n    ]) => {\n      const cachedBlocks = cachedBlocksMetric[id]?.value;\n      const completedBlocks = completedBlocksMetric[id]?.value ?? 0;\n\n      // If cachedBlocks is not set, setup is not complete.\n      if (cachedBlocks === undefined) {\n        return {\n          sourceName: source,\n          networkName: network,\n          totalBlocks,\n          completedBlocks,\n        };\n      }\n\n      const progress = (completedBlocks + cachedBlocks) / totalBlocks;\n\n      const elapsed = Date.now() - startTimestampMetric;\n      const total = elapsed / (completedBlocks / (totalBlocks - cachedBlocks));\n      // The ETA is low quality if we've completed only one or two blocks.\n      const eta = completedBlocks >= 3 ? total - elapsed : undefined;\n\n      return {\n        sourceName: source,\n        networkName: network,\n        totalBlocks,\n        cachedBlocks,\n        completedBlocks,\n        progress,\n        eta,\n      };\n    },\n  );\n\n  const totalBlocks = sources.reduce((a, c) => a + c.totalBlocks, 0);\n  const cachedBlocks = sources.reduce((a, c) => a + (c.cachedBlocks ?? 0), 0);\n  const completedBlocks = sources.reduce(\n    (a, c) => a + (c.completedBlocks ?? 0),\n    0,\n  );\n  const progress =\n    totalBlocks === 0 ? 0 : (completedBlocks + cachedBlocks) / totalBlocks;\n\n  return {\n    overall: { totalBlocks, cachedBlocks, completedBlocks, progress },\n    sources,\n  };\n}\n\nexport async function getIndexingProgress(metrics: MetricsService) {\n  const hasErrorMetric = (await metrics.ponder_indexing_has_error.get())\n    .values[0]?.value;\n  const hasError = hasErrorMetric === 1;\n\n  const totalSeconds =\n    (await metrics.ponder_indexing_total_seconds.get()).values[0]?.value ?? 0;\n  const completedSeconds =\n    (await metrics.ponder_indexing_completed_seconds.get()).values[0]?.value ??\n    0;\n  const completedToTimestamp =\n    (await metrics.ponder_indexing_completed_timestamp.get()).values[0].value ??\n    0;\n\n  const progress = totalSeconds === 0 ? 0 : completedSeconds / totalSeconds;\n\n  const indexingCompletedEventsMetric = (\n    await metrics.ponder_indexing_completed_events.get()\n  ).values;\n  const indexingFunctionErrorMetric = (\n    await metrics.ponder_indexing_function_error_total.get()\n  ).values;\n  const indexingFunctionDurationMetric = (\n    await metrics.ponder_indexing_function_duration.get()\n  ).values;\n\n  const indexingDurationSum: Record<string, Record<string, number>> = {};\n  const indexingDurationCount: Record<string, Record<string, number>> = {};\n  for (const m of indexingFunctionDurationMetric) {\n    if (m.metricName === \"ponder_indexing_function_duration_sum\")\n      (indexingDurationSum[m.labels.event!] ??= {})[m.labels.network!] =\n        m.value;\n    if (m.metricName === \"ponder_indexing_function_duration_count\")\n      (indexingDurationCount[m.labels.event!] ??= {})[m.labels.network!] =\n        m.value;\n  }\n\n  const events = indexingCompletedEventsMetric.map((m) => {\n    const eventName = m.labels.event as string;\n    const networkName = m.labels.network as string;\n    const count = m.value;\n\n    const durationSum = indexingDurationSum[eventName]?.[networkName] ?? 0;\n    const durationCount = indexingDurationCount[eventName]?.[networkName] ?? 0;\n    const averageDuration =\n      durationCount === 0 ? 0 : durationSum / durationCount;\n\n    const errorCount =\n      indexingFunctionErrorMetric.find(\n        (e) => e.labels.event === eventName && e.labels.network === networkName,\n      )?.value ?? 0;\n\n    return { eventName, networkName, count, averageDuration, errorCount };\n  });\n\n  const totalEvents = events.reduce((a, e) => a + e.count, 0);\n\n  return {\n    hasError,\n    overall: {\n      completedSeconds,\n      totalSeconds,\n      progress,\n      completedToTimestamp,\n      totalEvents,\n    },\n    events,\n  };\n}\n","import path from \"node:path\";\nimport type { CliOptions } from \"@/bin/ponder.js\";\nimport type { LevelWithSilent } from \"pino\";\n\nexport type Options = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n\n  configFile: string;\n  schemaFile: string;\n  rootDir: string;\n  srcDir: string;\n  generatedDir: string;\n  ponderDir: string;\n  logDir: string;\n\n  port: number;\n  hostname?: string;\n  maxHealthcheckDuration: number;\n\n  graphqlMaxOperationTokens: number;\n  graphqlMaxOperationDepth: number;\n  graphqlMaxOperationAliases: number;\n\n  telemetryUrl: string;\n  telemetryDisabled: boolean;\n  telemetryConfigDir: string | undefined;\n\n  logLevel: LevelWithSilent;\n\n  databaseHeartbeatInterval: number;\n  databaseHeartbeatTimeout: number;\n};\n\nexport const buildOptions = ({ cliOptions }: { cliOptions: CliOptions }) => {\n  let rootDir: string;\n  if (cliOptions.root !== undefined) {\n    rootDir = path.resolve(cliOptions.root);\n  } else {\n    rootDir = path.resolve(\".\");\n  }\n\n  let logLevel: LevelWithSilent;\n  if (cliOptions.trace === true) {\n    logLevel = \"trace\";\n  } else if (cliOptions.debug === true) {\n    logLevel = \"debug\";\n  } else if (\n    process.env.PONDER_LOG_LEVEL !== undefined &&\n    [\"silent\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"].includes(\n      process.env.PONDER_LOG_LEVEL,\n    )\n  ) {\n    logLevel = process.env.PONDER_LOG_LEVEL as LevelWithSilent;\n  } else {\n    logLevel = \"info\";\n  }\n\n  const port =\n    process.env.PORT !== undefined\n      ? Number(process.env.PORT)\n      : cliOptions.port !== undefined\n        ? cliOptions.port\n        : 42069;\n\n  const hostname = cliOptions.hostname;\n\n  return {\n    command: cliOptions.command,\n\n    rootDir,\n    configFile: path.join(rootDir, cliOptions.config),\n    schemaFile: path.join(rootDir, \"ponder.schema.ts\"),\n    srcDir: path.join(rootDir, \"src\"),\n    generatedDir: path.join(rootDir, \"generated\"),\n    ponderDir: path.join(rootDir, \".ponder\"),\n    logDir: path.join(rootDir, \".ponder\", \"logs\"),\n\n    port,\n    hostname,\n    maxHealthcheckDuration: 240, // 4 minutes\n\n    // Default limits are from Apollo:\n    // https://www.apollographql.com/blog/prevent-graph-misuse-with-operation-size-and-complexity-limits\n    graphqlMaxOperationTokens: 1000,\n    graphqlMaxOperationDepth: 100,\n    graphqlMaxOperationAliases: 30,\n\n    telemetryUrl: \"https://ponder.sh/api/telemetry\",\n    telemetryDisabled: Boolean(process.env.PONDER_TELEMETRY_DISABLED),\n    telemetryConfigDir: undefined,\n\n    logLevel,\n\n    databaseHeartbeatInterval: 10 * 1000,\n    databaseHeartbeatTimeout: 25 * 1000,\n  } satisfies Options;\n};\n","import { exec } from \"child_process\";\nimport { createHash, randomBytes } from \"node:crypto\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { promisify } from \"util\";\nimport type { Build } from \"@/build/service.js\";\nimport type { Options } from \"@/common/options.js\";\nimport { getTables } from \"@/schema/utils.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { createQueue } from \"@ponder/common\";\nimport Conf from \"conf\";\nimport { type PM, detect, getNpmVersion } from \"detect-package-manager\";\nimport type { Logger } from \"./logger.js\";\n\nconst HEARTBEAT_INTERVAL_MS = 60_000;\n\ntype TelemetryEvent =\n  | {\n      name: \"lifecycle:session_start\";\n      properties: { cli_command: string };\n    }\n  | {\n      name: \"lifecycle:session_end\";\n      properties: { duration_seconds: number };\n    }\n  | {\n      name: \"lifecycle:heartbeat_send\";\n      properties: { duration_seconds: number };\n    };\n\ntype CommonProperties = {\n  // Identification\n  project_id: string;\n  session_id: string;\n  is_internal: boolean;\n};\n\ntype SessionProperties = {\n  // Environment and package versions\n  package_manager: string;\n  package_manager_version: string;\n  node_version: string;\n  ponder_core_version: string;\n  viem_version: string;\n  // System and hardware\n  system_platform: NodeJS.Platform;\n  system_release: string;\n  system_architecture: string;\n  cpu_count: number;\n  cpu_model: string;\n  cpu_speed: number;\n  total_memory_bytes: number;\n};\n\ntype DeviceConf = {\n  notifiedAt?: string;\n  anonymousId?: string;\n  salt?: string;\n};\n\nexport type Telemetry = ReturnType<typeof createTelemetry>;\n\nexport function createTelemetry({\n  options,\n  logger,\n}: { options: Options; logger: Logger }) {\n  if (options.telemetryDisabled) {\n    return { record: (_event: TelemetryEvent) => {}, kill: async () => {} };\n  }\n\n  const conf = new Conf<DeviceConf>({\n    projectName: \"ponder\",\n    cwd: options.telemetryConfigDir,\n  });\n\n  if (conf.get(\"notifiedAt\") === undefined) {\n    conf.set(\"notifiedAt\", Date.now().toString());\n    logger.info({\n      service: \"telemetry\",\n      msg: \"Ponder collects anonymous telemetry data to identify issues and prioritize features. See https://ponder.sh/advanced/telemetry for more information.\",\n    });\n  }\n\n  const sessionId = randomBytes(8).toString(\"hex\");\n\n  let anonymousId = conf.get(\"anonymousId\") as string;\n  if (anonymousId === undefined) {\n    anonymousId = randomBytes(8).toString(\"hex\");\n    conf.set(\"anonymousId\", anonymousId);\n  }\n  // Before 0.4.3, the anonymous ID was 64 characters long. Truncate it to 16\n  // here to align with new ID lengths.\n  if (anonymousId.length > 16) anonymousId = anonymousId.slice(0, 16);\n\n  let salt = conf.get(\"salt\") as string;\n  if (salt === undefined) {\n    salt = randomBytes(8).toString(\"hex\");\n    conf.set(\"salt\", salt);\n  }\n\n  // Prepend the value with a secret salt to ensure a credible one-way hash.\n  const oneWayHash = (value: string) => {\n    const hash = createHash(\"sha256\");\n    hash.update(salt);\n    hash.update(value);\n    return hash.digest(\"hex\").slice(0, 16);\n  };\n\n  const buildContext = async () => {\n    // Project ID is a one-way hash of the git remote URL OR the current working directory.\n    const gitRemoteUrl = await getGitRemoteUrl();\n    const projectIdRaw = gitRemoteUrl ?? process.cwd();\n    const projectId = oneWayHash(projectIdRaw);\n\n    const { packageManager, packageManagerVersion } = await getPackageManager();\n\n    // Attempt to find and read the users package.json file.\n    const packageJson = getPackageJson(options.rootDir);\n    const ponderCoreVersion =\n      packageJson?.dependencies?.[\"@ponder/core\"] ?? \"unknown\";\n    const viemVersion = packageJson?.dependencies?.viem ?? \"unknown\";\n\n    // Make a guess as to whether the project is internal (within the monorepo) or not.\n    const isInternal = ponderCoreVersion === \"workspace:*\";\n\n    const cpus = os.cpus();\n\n    return {\n      common: {\n        session_id: sessionId,\n        project_id: projectId,\n        is_internal: isInternal,\n      } satisfies CommonProperties,\n      session: {\n        ponder_core_version: ponderCoreVersion,\n        viem_version: viemVersion,\n        package_manager: packageManager,\n        package_manager_version: packageManagerVersion,\n        node_version: process.versions.node,\n        system_platform: os.platform(),\n        system_release: os.release(),\n        system_architecture: os.arch(),\n        cpu_count: cpus.length,\n        cpu_model: cpus.length > 0 ? cpus[0].model : \"unknown\",\n        cpu_speed: cpus.length > 0 ? cpus[0].speed : 0,\n        total_memory_bytes: os.totalmem(),\n      } satisfies SessionProperties,\n    };\n  };\n\n  let context: Awaited<ReturnType<typeof buildContext>> | undefined = undefined;\n  const contextPromise = buildContext();\n\n  const controller = new AbortController();\n  let isKilled = false;\n\n  const queue = createQueue({\n    initialStart: true,\n    concurrency: 10,\n    worker: async (event: TelemetryEvent) => {\n      const endClock = startClock();\n      try {\n        if (context === undefined) context = await contextPromise;\n\n        const properties =\n          event.name === \"lifecycle:session_start\"\n            ? { ...event.properties, ...context.common, ...context.session }\n            : { ...event.properties, ...context.common };\n\n        const body = JSON.stringify({\n          distinctId: anonymousId,\n          event: event.name,\n          properties,\n        });\n\n        await fetch(options.telemetryUrl, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body,\n          signal: controller.signal,\n        });\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Sent '${event.name}' event in ${endClock()}ms`,\n        });\n      } catch (error_) {\n        const error = error_ as Error;\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Failed to send '${\n            event.name\n          }' event after ${endClock()}ms due to error: ${error.message}`,\n        });\n      }\n    },\n  });\n\n  const record = (event: TelemetryEvent) => {\n    if (isKilled) return;\n    queue.add(event);\n  };\n\n  const heartbeatInterval = setInterval(() => {\n    record({\n      name: \"lifecycle:heartbeat_send\",\n      properties: { duration_seconds: process.uptime() },\n    });\n  }, HEARTBEAT_INTERVAL_MS);\n\n  const kill = async () => {\n    clearInterval(heartbeatInterval);\n    isKilled = true;\n    // If there are any events in the queue that have not started, drop them.\n    queue.clear();\n    // Wait at most 1 second for any in-flight events to complete.\n    await Promise.race([queue.onIdle(), wait(1_000)]);\n  };\n\n  return { record, kill };\n}\n\nasync function getPackageManager() {\n  let packageManager: PM = \"unknown\" as PM;\n  let packageManagerVersion = \"unknown\";\n  try {\n    packageManager = await detect();\n    packageManagerVersion = await getNpmVersion(packageManager);\n  } catch (e) {}\n  return { packageManager, packageManagerVersion };\n}\n\nconst execa = promisify(exec);\n\nasync function getGitRemoteUrl() {\n  const result = await execa(\"git config --local --get remote.origin.url\", {\n    timeout: 250,\n    windowsHide: true,\n  }).catch(() => undefined);\n\n  return result?.stdout.trim();\n}\n\ntype PackageJson = {\n  name?: string;\n  version?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n};\n\nfunction getPackageJson(rootDir: string) {\n  try {\n    const rootPath = path.join(rootDir, \"package.json\");\n    const cwdPath = path.join(process.cwd(), \"package.json\");\n\n    const packageJsonPath = existsSync(rootPath)\n      ? rootPath\n      : existsSync(cwdPath)\n        ? cwdPath\n        : undefined;\n    if (packageJsonPath === undefined) return undefined;\n\n    const packageJsonString = readFileSync(packageJsonPath, \"utf8\");\n    const packageJson = JSON.parse(packageJsonString) as PackageJson;\n\n    return packageJson;\n  } catch (e) {\n    return undefined;\n  }\n}\n\nexport function buildPayload(build: Build) {\n  const table_count = Object.keys(getTables(build.schema)).length;\n  const indexing_function_count = Object.values(build.indexingFunctions).reduce(\n    (acc, f) => acc + Object.keys(f).length,\n    0,\n  );\n\n  return {\n    database_kind: build.databaseConfig.kind,\n    contract_count: build.sources.length,\n    network_count: build.networks.length,\n    table_count,\n    indexing_function_count,\n  };\n}\n","/**\n * Measures the elapsed wall clock time in milliseconds (ms) between two points.\n * @returns A function returning the elapsed time in milliseconds (ms).\n */\nexport function startClock() {\n  const start = process.hrtime();\n  return () => hrTimeToMs(process.hrtime(start));\n}\n\n/**\n * Converts a process.hrtime() measurement to milliseconds (ms).\n * @returns The timestamp in milliseconds (ms).\n */\nexport function hrTimeToMs(diff: [number, number]) {\n  return Math.round(diff[0] * 1000 + diff[1] / 1_000) / 1_000;\n}\n","/** Waits at least a specified amount of time.\n *\n * @param milliseconds Minimum number of milliseconds to wait.\n */\nexport async function wait(milliseconds: number) {\n  return new Promise<void>((res) => setTimeout(res, milliseconds));\n}\n","import os from \"node:os\";\nimport readline from \"node:readline\";\nimport type { Common } from \"@/common/common.js\";\nimport { IgnorableError } from \"@/common/errors.js\";\n\nconst SHUTDOWN_GRACE_PERIOD_MS = 5_000;\n\n/**\n * Sets up shutdown handlers for the process. Accepts additional cleanup logic to run.\n */\nexport function setupShutdown({\n  common,\n  cleanup,\n}: {\n  common: Common;\n  cleanup: () => Promise<void>;\n}) {\n  let isShuttingDown = false;\n\n  const shutdown = async ({\n    reason,\n    code,\n  }: { reason: string; code: 0 | 1 }) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    setTimeout(async () => {\n      common.logger.fatal({\n        service: \"process\",\n        msg: \"Failed to shutdown within 5 seconds, terminating (exit code 1)\",\n      });\n      await common.logger.kill();\n      process.exit(1);\n    }, SHUTDOWN_GRACE_PERIOD_MS);\n\n    if (reason !== undefined) {\n      common.logger.warn({\n        service: \"process\",\n        msg: `${reason}, starting shutdown sequence`,\n      });\n    }\n    common.telemetry.record({\n      name: \"lifecycle:session_end\",\n      properties: { duration_seconds: process.uptime() },\n    });\n\n    await cleanup();\n\n    const level = code === 0 ? \"info\" : \"fatal\";\n    common.logger[level]({\n      service: \"process\",\n      msg: `Finished shutdown sequence, terminating (exit code ${code})`,\n    });\n\n    await common.logger.kill();\n    process.exit(code);\n  };\n\n  if (os.platform() === \"win32\") {\n    const readlineInterface = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n    readlineInterface.on(\"SIGINT\", () =>\n      shutdown({ reason: \"Received SIGINT\", code: 0 }),\n    );\n  }\n\n  process.on(\"SIGINT\", () => shutdown({ reason: \"Received SIGINT\", code: 0 }));\n  process.on(\"SIGTERM\", () =>\n    shutdown({ reason: \"Received SIGTERM\", code: 0 }),\n  );\n  process.on(\"SIGQUIT\", () =>\n    shutdown({ reason: \"Received SIGQUIT\", code: 0 }),\n  );\n\n  process.on(\"uncaughtException\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught uncaughtException event with error:\",\n      error,\n    });\n    shutdown({ reason: \"Received uncaughtException\", code: 1 });\n  });\n  process.on(\"unhandledRejection\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught unhandledRejection event with error:\",\n      error,\n    });\n    shutdown({ reason: \"Received unhandledRejection\", code: 1 });\n  });\n\n  return shutdown;\n}\n","export class BaseError extends Error {\n  override name = \"BaseError\";\n\n  meta: string[] = [];\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, BaseError.prototype);\n  }\n}\n\nexport function getBaseError(err: any) {\n  if (err instanceof BaseError) return err;\n  if (err instanceof Error) return new BaseError(err.message);\n  if (typeof err?.message === \"string\") return new BaseError(err.message);\n  if (typeof err === \"string\") return new BaseError(err);\n  return new BaseError(\"unknown error\");\n}\n\nexport class NonRetryableError extends BaseError {\n  override name = \"NonRetryableError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, NonRetryableError.prototype);\n  }\n}\n\nexport class IgnorableError extends BaseError {\n  override name = \"IgnorableError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, IgnorableError.prototype);\n  }\n}\n\nexport class StoreError extends NonRetryableError {\n  override name = \"StoreError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, StoreError.prototype);\n  }\n}\n\nexport class UniqueConstraintError extends NonRetryableError {\n  override name = \"UniqueConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, UniqueConstraintError.prototype);\n  }\n}\n\nexport class NotNullConstraintError extends NonRetryableError {\n  override name = \"NotNullConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, NotNullConstraintError.prototype);\n  }\n}\n\nexport class RecordNotFoundError extends NonRetryableError {\n  override name = \"RecordNotFoundError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, RecordNotFoundError.prototype);\n  }\n}\n\nexport class CheckConstraintError extends NonRetryableError {\n  override name = \"CheckConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, CheckConstraintError.prototype);\n  }\n}\n\nexport class BigIntSerializationError extends NonRetryableError {\n  override name = \"BigIntSerializationError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, BigIntSerializationError.prototype);\n  }\n}\n","import { createBuildService } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { createTelemetry } from \"@/common/telemetry.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function codegen({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({ level: options.logLevel });\n\n  const [major, minor, _patch] = process.versions.node.split(\".\").map(Number);\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const cleanup = async () => {\n    await buildService.kill();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildResult = await buildService.start({ watch: false });\n\n  if (buildResult.status === \"error\") {\n    logger.error({\n      service: \"process\",\n      msg: \"Failed schema build with error:\",\n      error: buildResult.error,\n    });\n    await shutdown({ reason: \"Failed schema build\", code: 1 });\n    return;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"codegen\" },\n  });\n\n  runCodegen({ common, graphqlSchema: buildResult.build.graphqlSchema });\n\n  logger.info({ service: \"codegen\", msg: \"Wrote ponder-env.d.ts\" });\n  logger.info({ service: \"codegen\", msg: \"Wrote schema.graphql\" });\n\n  await shutdown({ reason: \"Success\", code: 0 });\n}\n","import { existsSync } from \"node:fs\";\nimport path from \"node:path\";\nimport { type BuildResult, createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { UiService } from \"@/ui/service.js\";\nimport { createQueue } from \"@ponder/common\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function dev({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({ level: options.logLevel });\n\n  const [major, minor, _patch] = process.versions.node.split(\".\").map(Number);\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  if (!existsSync(path.join(options.rootDir, \".env.local\"))) {\n    logger.warn({\n      service: \"app\",\n      msg: \"Local environment file (.env.local) not found\",\n    });\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const uiService = new UiService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await buildService.kill();\n    await telemetry.kill();\n    uiService.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildQueue = createQueue({\n    initialStart: true,\n    concurrency: 1,\n    worker: async (result: BuildResult) => {\n      await cleanupReloadable();\n\n      if (result.status === \"success\") {\n        uiService.reset();\n        metrics.resetMetrics();\n\n        cleanupReloadable = await run({\n          common,\n          build: result.build,\n          onFatalError: () => {\n            shutdown({ reason: \"Received fatal error\", code: 1 });\n          },\n          onReloadableError: (error) => {\n            buildQueue.clear();\n            buildQueue.add({ status: \"error\", error });\n          },\n        });\n      } else {\n        // This handles build failures and indexing errors on hot reload.\n        uiService.setReloadableError();\n        cleanupReloadable = () => Promise.resolve();\n      }\n    },\n  });\n\n  const initialResult = await buildService.start({\n    watch: true,\n    onBuild: (buildResult) => {\n      buildQueue.clear();\n      buildQueue.add(buildResult);\n    },\n  });\n\n  if (initialResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"dev\", ...buildPayload(initialResult.build) },\n  });\n\n  buildQueue.add(initialResult);\n\n  return async () => {\n    buildQueue.pause();\n    await cleanup();\n  };\n}\n","export const formatEta = (ms: number) => {\n  // If less than 1 second, return ms.\n  if (ms < 1000) return `${Math.round(ms)}ms`;\n  const seconds = Math.floor(ms / 1000);\n\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds - h * 3600) / 60);\n  const s = seconds - h * 3600 - m * 60;\n\n  const hstr = h > 0 ? `${h}h ` : \"\";\n  const mstr = m > 0 || h > 0 ? `${m}m ` : \"\";\n  const sstr = s > 0 || m > 0 ? `${s}s` : \"\";\n\n  return `${hstr}${mstr}${sstr}`;\n};\n\nexport const formatPercentage = (cacheRate: number) => {\n  const decimal = Math.round(cacheRate * 1000) / 10;\n  return Number.isInteger(decimal) && decimal < 100\n    ? `${decimal}.0%`\n    : `${decimal}%`;\n};\n","import { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport { Box, Text, render as inkRender } from \"ink\";\nimport React from \"react\";\nimport { ProgressBar } from \"./ProgressBar.js\";\nimport Table from \"./Table.js\";\n\nexport type UiState = {\n  port: number;\n\n  historical: {\n    overall: {\n      totalBlocks: number;\n      cachedBlocks: number;\n      completedBlocks: number;\n      progress: number;\n    };\n    sources: {\n      sourceName: string;\n      networkName: string;\n      totalBlocks: number;\n      completedBlocks: number;\n      cachedBlocks?: number;\n      progress?: number;\n      eta?: number;\n    }[];\n  };\n\n  indexing: {\n    hasError: boolean;\n    overall: {\n      completedSeconds: number;\n      totalSeconds: number;\n      progress: number;\n      completedToTimestamp: number;\n      totalEvents: number;\n    };\n    events: {\n      eventName: string;\n      networkName: string;\n      count: number;\n      averageDuration: number;\n      errorCount: number;\n    }[];\n  };\n\n  realtimeSyncNetworks: {\n    name: string;\n    isConnected: boolean;\n  }[];\n};\n\nexport const buildUiState = () => {\n  const ui: UiState = {\n    historical: {\n      overall: {\n        totalBlocks: 0,\n        cachedBlocks: 0,\n        completedBlocks: 0,\n        progress: 0,\n      },\n      sources: [],\n    },\n\n    realtimeSyncNetworks: [],\n\n    indexing: {\n      hasError: false,\n      overall: {\n        completedSeconds: 0,\n        totalSeconds: 0,\n        progress: 0,\n        completedToTimestamp: 0,\n        totalEvents: 0,\n      },\n      events: [],\n    },\n\n    port: 0,\n  };\n\n  return ui;\n};\n\nconst App = (ui: UiState) => {\n  const { historical, indexing, port } = ui;\n\n  if (indexing.hasError) {\n    return (\n      <Box flexDirection=\"column\">\n        <Text> </Text>\n\n        <Text color=\"cyan\">\n          Resolve the error and save your changes to reload the server.\n        </Text>\n      </Box>\n    );\n  }\n\n  let historicalElement: JSX.Element;\n  if (historical.overall.progress === 0) {\n    historicalElement = (\n      <>\n        <Text bold={true}>Historical sync</Text>\n        <Text>Waiting to start...</Text>\n        <Text> </Text>\n      </>\n    );\n  } else if (historical.overall.progress === 1) {\n    historicalElement = (\n      <>\n        <Text>\n          <Text bold={true}>Historical sync </Text>(\n          <Text color=\"greenBright\">done</Text>)\n        </Text>\n        <Text> </Text>\n      </>\n    );\n  } else {\n    historicalElement = (\n      <>\n        <Text>\n          <Text bold={true}>Historical sync </Text>(\n          <Text color=\"yellowBright\">in progress</Text>)\n        </Text>\n        <Box flexDirection=\"row\">\n          <ProgressBar\n            current={historical.overall.progress}\n            end={1}\n            width={50}\n          />\n          <Text>\n            {\" \"}\n            {historical.overall.progress === 1 ? (\n              <Text color=\"greenBright\">done</Text>\n            ) : (\n              formatPercentage(historical.overall.progress)\n            )}{\" \"}\n            (\n            {historical.overall.cachedBlocks +\n              historical.overall.completedBlocks}{\" \"}\n            blocks)\n          </Text>\n        </Box>\n        <Text> </Text>\n\n        <Table\n          rows={historical.sources}\n          columns={[\n            { title: \"Source\", key: \"sourceName\", align: \"left\" },\n            { title: \"Network\", key: \"networkName\", align: \"left\" },\n            {\n              title: \"Cached\",\n              key: \"cachedBlocks\",\n              align: \"right\",\n              format: (_, row) =>\n                row.cachedBlocks !== undefined ? row.cachedBlocks : \"-\",\n            },\n            {\n              title: \"Completed\",\n              key: \"completedBlocks\",\n              align: \"right\",\n            },\n            { title: \"Total\", key: \"totalBlocks\", align: \"right\" },\n            {\n              title: \"Progress\",\n              key: \"progress\",\n              align: \"right\",\n              format: (v) => (v ? formatPercentage(v) : \"-\"),\n            },\n            {\n              title: \"ETA\",\n              key: \"eta\",\n              align: \"right\",\n              format: (v) => (v ? formatEta(v) : \"-\"),\n            },\n          ]}\n        />\n        <Text> </Text>\n      </>\n    );\n  }\n\n  let indexingElement: JSX.Element;\n  if (indexing.overall.progress === 0) {\n    indexingElement = (\n      <>\n        <Text bold={true}>Indexing </Text>\n        <Text>Waiting to start...</Text>\n        <Text> </Text>\n      </>\n    );\n  } else {\n    const effectiveProgress =\n      indexing.overall.progress * historical.overall.progress;\n\n    indexingElement = (\n      <>\n        <Text>\n          <Text bold={true}>Indexing </Text>(\n          {effectiveProgress === 1 ? (\n            <Text color=\"greenBright\">done</Text>\n          ) : (\n            <Text color=\"yellowBright\">in progress</Text>\n          )}\n          )\n        </Text>\n        <Box flexDirection=\"row\">\n          <ProgressBar current={effectiveProgress} end={1} width={50} />\n          <Text> ({indexing.overall.totalEvents} events)</Text>\n        </Box>\n        <Text> </Text>\n\n        <Table\n          rows={indexing.events}\n          columns={[\n            { title: \"Event\", key: \"eventName\", align: \"left\" },\n            { title: \"Network\", key: \"networkName\", align: \"left\" },\n            { title: \"Count\", key: \"count\", align: \"right\" },\n            {\n              title: \"Error count\",\n              key: \"errorCount\",\n              align: \"right\",\n              format: (v, row) => (row.count > 0 ? v : \"-\"),\n            },\n            {\n              title: \"Duration (avg)\",\n              key: \"averageDuration\",\n              align: \"right\",\n              format: (v) => (v > 0 ? `${v.toFixed(2)}ms` : \"-\"),\n            },\n          ]}\n        />\n        <Text> </Text>\n      </>\n    );\n  }\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text> </Text>\n\n      {historicalElement}\n\n      {indexingElement}\n\n      {/* <Text bold={true}>Historical sync</Text>\n      {historical.overall.progress > 0 ? (\n        <>\n          <Box flexDirection=\"row\">\n            <ProgressBar\n              current={historical.overall.progress}\n              end={1}\n              width={40}\n            />\n            <Text>\n              {\" \"}\n              {historical.overall.progress === 1 ? (\n                <Text color=\"greenBright\">done</Text>\n              ) : (\n                formatPercentage(historical.overall.progress)\n              )}{\" \"}\n              ({historical.overall.totalBlocks} blocks)\n            </Text>\n          </Box>\n          <Text> </Text>\n\n          <Table\n            rows={historical.contracts}\n            columns={[\n              { title: \"Contract\", key: \"contractName\", align: \"left\" },\n              { title: \"Network\", key: \"networkName\", align: \"left\" },\n              { title: \"Total blocks\", key: \"totalBlocks\", align: \"right\" },\n              {\n                title: \"Cached %\",\n                key: \"cachedBlocks\",\n                align: \"right\",\n                format: (_, row) =>\n                  row.cachedBlocks !== undefined\n                    ? formatPercentage(row.cachedBlocks / row.totalBlocks)\n                    : \"-\",\n              },\n              {\n                title: \"Progress\",\n                key: \"progress\",\n                align: \"right\",\n                format: (v) => (v ? formatPercentage(v) : \"-\"),\n              },\n              {\n                title: \"ETA\",\n                key: \"eta\",\n                align: \"right\",\n                format: (v) => (v ? formatEta(v) : \"-\"),\n              },\n            ]}\n          />\n        </>\n      ) : (\n        <Text>Waiting to start...</Text>\n      )} */}\n\n      {/* <Text bold={true}>Indexing</Text>\n      {indexing.overall.progress > 0 ? (\n        <>\n          <Box flexDirection=\"row\">\n            <ProgressBar\n              current={indexing.overall.progress}\n              end={1}\n              width={40}\n            />\n            <Text>\n              {\" \"}\n              {indexing.overall.progress === 1 ? (\n                <Text color=\"greenBright\">up to date</Text>\n              ) : (\n                formatPercentage(indexing.overall.progress)\n              )}{\" \"}\n              ({indexing.overall.totalEvents} events)\n            </Text>\n          </Box>\n          <Text> </Text>\n\n          <Table\n            rows={indexing.events}\n            columns={[\n              { title: \"Event\", key: \"eventName\", align: \"left\" },\n              { title: \"Network\", key: \"networkName\", align: \"left\" },\n              { title: \"Count\", key: \"count\", align: \"right\" },\n              {\n                title: \"Error count\",\n                key: \"errorCount\",\n                align: \"right\",\n                format: (v, row) => (row.count > 0 ? v : \"-\"),\n              },\n              {\n                title: \"Duration (avg)\",\n                key: \"averageDuration\",\n                align: \"right\",\n                format: (v) => (v > 0 ? `${v.toFixed(2)}ms` : \"-\"),\n              },\n            ]}\n          />\n        </>\n      ) : (\n        <Text>Waiting to start...</Text>\n      )}\n      <Text> </Text> */}\n\n      {/* {realtimeSyncNetworks.length > 0 && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>Realtime sync </Text>\n          {realtimeSyncNetworks.map(({ name, isConnected }) => (\n            <Box flexDirection=\"row\" key={name}>\n              <Text>\n                {name.slice(0, 1).toUpperCase() + name.slice(1)} (\n                {isConnected ? \"live\" : \"disconnected\"})\n              </Text>\n            </Box>\n          ))}\n          <Text> </Text>\n        </Box>\n      )} */}\n\n      <Box flexDirection=\"column\">\n        <Text bold>GraphQL </Text>\n        <Box flexDirection=\"row\">\n          <Text>Server live at http://localhost:{port}</Text>\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nexport const setupInkApp = (ui: UiState) => {\n  const { rerender, unmount: inkUnmount, clear } = inkRender(<App {...ui} />);\n\n  const render = (ui: UiState) => {\n    rerender(<App {...ui} />);\n  };\n\n  const unmount = () => {\n    clear();\n    inkUnmount();\n  };\n  return { render, unmount };\n};\n","import { Text } from \"ink\";\nimport React from \"react\";\n\nexport const ProgressBar = ({ current = 5, end = 10, width = 36 }) => {\n  const maxCount = width || process.stdout.columns || 80;\n\n  const fraction = current / end;\n  const count = Math.min(Math.floor(maxCount * fraction), maxCount);\n\n  return (\n    <Text>\n      <Text>{\"█\".repeat(count)}</Text>\n      <Text>{\"░\".repeat(maxCount - count)}</Text>\n    </Text>\n  );\n};\n","import { Box, Text } from \"ink\"; // Assuming you're using ink for CLI UI components\nimport React from \"react\";\n\nconst MAX_COLUMN_WIDTH = 24;\n\nexport function Table<TRow extends { [key: string]: any }>(props: {\n  columns: {\n    title: string;\n    key: keyof TRow;\n    align: \"left\" | \"right\";\n    format?: (value: any, row: TRow) => string | number | React.JSX.Element;\n  }[];\n  rows: TRow[];\n}) {\n  const { columns, rows } = props;\n\n  const formattedRows = rows.map((row) =>\n    columns.reduce(\n      (acc, column) => ({\n        ...acc,\n        [column.key.toString()]: column.format\n          ? column.format(row[column.key], row)\n          : row[column.key],\n      }),\n      {} as TRow,\n    ),\n  );\n\n  const columnWidths = columns.map((column) => {\n    let maxWidth = Math.max(\n      ...formattedRows.map((row) =>\n        row[column.key] !== undefined ? row[column.key].toString().length : 9,\n      ),\n      column.title.length,\n    );\n    maxWidth = Math.min(maxWidth, MAX_COLUMN_WIDTH);\n    return maxWidth;\n  });\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Column Titles */}\n      <Box flexDirection=\"row\" key=\"title\">\n        {columns.map(({ title, align }, index) => (\n          <React.Fragment key={`title-${index}`}>\n            <Text>│</Text>\n            <Box\n              width={columnWidths[index]}\n              justifyContent={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n              marginX={1}\n            >\n              <Text bold wrap=\"truncate-end\">\n                {title}\n              </Text>\n            </Box>\n          </React.Fragment>\n        ))}\n        <Text>│</Text>\n      </Box>\n\n      {/* Separator Line */}\n      <Box flexDirection=\"row\" key=\"border\">\n        <Text>├</Text>\n        {columnWidths.map((width, index) => (\n          <Text key={`separator-${index}`}>\n            {\"─\".repeat(width + 2)}\n            {index < columns.length - 1 ? \"┼\" : \"┤\"}\n          </Text>\n        ))}\n      </Box>\n\n      {/* Rows of Data */}\n      {formattedRows.map((row, rowIndex) => (\n        <Box flexDirection=\"row\" key={`row-${rowIndex}`}>\n          {columns.map(({ key, align }, index) => (\n            <React.Fragment key={`cell-${rowIndex}-${index}`}>\n              <Text>│</Text>\n              <Box\n                width={columnWidths[index]}\n                justifyContent={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n                marginX={1}\n              >\n                <Text wrap=\"truncate-end\">{row[key]}</Text>\n              </Box>\n            </React.Fragment>\n          ))}\n          <Text>│</Text>\n        </Box>\n      ))}\n    </Box>\n  );\n}\n\nexport default Table;\n","import type { Common } from \"@/common/common.js\";\nimport {\n  getHistoricalSyncProgress,\n  getIndexingProgress,\n} from \"@/common/metrics.js\";\nimport { buildUiState, setupInkApp } from \"./app.js\";\n\nexport class UiService {\n  private common: Common;\n\n  private ui = buildUiState();\n  private renderInterval?: NodeJS.Timeout;\n  private render?: () => void;\n  private unmount?: () => void;\n  private isKilled = false;\n\n  constructor({ common }: { common: Common }) {\n    this.common = common;\n\n    const { render, unmount } = setupInkApp(this.ui);\n    this.render = () => render(this.ui);\n    this.unmount = unmount;\n  }\n\n  reset() {\n    this.ui = buildUiState();\n    const metrics = this.common.metrics;\n\n    this.renderInterval = setInterval(async () => {\n      // Historical sync\n      this.ui.historical = await getHistoricalSyncProgress(metrics);\n\n      // Realtime sync\n      // const connectedNetworks = (\n      //   await metrics.ponder_realtime_is_connected.get()\n      // ).values\n      //   .filter((m) => m.value === 1)\n      //   .map((m) => m.labels.network)\n      //   .filter((n): n is string => typeof n === \"string\");\n      // const allNetworks = [\n      //   ...new Set(\n      //     sources\n      //       .filter((s) => s.endBlock === undefined)\n      //       .map((s) => s.networkName),\n      //   ),\n      // ];\n      // this.ui.realtimeSyncNetworks = allNetworks.map((networkName) => ({\n      //   name: networkName,\n      //   isConnected: connectedNetworks.includes(networkName),\n      // }));\n\n      // Indexing\n      this.ui.indexing = await getIndexingProgress(metrics);\n\n      // Server\n      const port = (await metrics.ponder_http_server_port.get()).values[0]\n        .value;\n      this.ui.port = port;\n\n      if (this.isKilled) return;\n      this.render?.();\n    }, 17);\n  }\n\n  setReloadableError() {\n    this.ui.indexing.hasError = true;\n    this.render?.();\n  }\n\n  kill() {\n    this.isKilled = true;\n    clearInterval(this.renderInterval);\n    this.unmount?.();\n  }\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { Kysely, Migration, MigrationProvider } from \"kysely\";\nimport { sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", sql`bytea`) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses Postgres SERIAL type which autoincrements.\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"numeric(78, 0)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"v\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_01_30_0_change_chain_id_type\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logs\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"rpcRequestResults\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"mixHash\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"nonce\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_00_0_log_transaction_hash_index\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_transaction_hash_index\")\n        .on(\"logs\")\n        .column(\"transactionHash\")\n        .execute();\n    },\n  },\n  \"2024_03_13_0_nullable_block_columns_sha3uncles\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"sha3Uncles\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_14_0_nullable_transaction_rsv\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"r\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"s\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"v\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_20_0_checkpoint_in_logs_table\": {\n    async up(_db: Kysely<any>) {\n      // no-op migration to avoid crashing databases that successfully ran this migration\n      return;\n    },\n  },\n  \"2024_04_04_0_log_events_indexes\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropIndex(\"blockNumberIndex\").ifExists().execute();\n      await db.schema.dropIndex(\"blockTimestampIndex\").ifExists().execute();\n\n      await db.schema\n        .createIndex(\"logBlockNumberIndex\")\n        .on(\"logs\")\n        .column(\"blockNumber\")\n        .execute();\n    },\n  },\n  \"2024_04_14_0_nullable_block_total_difficulty\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"totalDifficulty\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_04_14_1_add_checkpoint_column_to_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(\n        sql`\n        ALTER TABLE ponder_sync.logs \n        ADD COLUMN IF NOT EXISTS \n        checkpoint varchar(75)`.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_2_set_checkpoint_in_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(sql`SET statement_timeout = 3600000;`.compile(db));\n      await db.executeQuery(\n        sql`\n        CREATE TEMP TABLE cp_vals AS \n        SELECT\n          logs.id,\n          (lpad(blocks.timestamp::text, 10, '0') ||\n          lpad(blocks.\"chainId\"::text, 16, '0') ||\n          lpad(blocks.number::text, 16, '0') ||\n          lpad(logs.\"transactionIndex\"::text, 16, '0') ||\n          '5' ||\n          lpad(logs.\"logIndex\"::text, 16, '0')) AS checkpoint\n        FROM ponder_sync.logs logs\n        JOIN ponder_sync.blocks blocks ON logs.\"blockHash\" = blocks.hash;\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n        CREATE INDEX ON cp_vals(id)\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.logs\n          SET checkpoint=cp_vals.checkpoint\n          FROM cp_vals\n          WHERE ponder_sync.logs.id = cp_vals.id\n        `.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_3_index_on_logs_checkpoint\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"logs_checkpoint_index\")\n        .ifNotExists()\n        .on(\"logs\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_04_22_0_transaction_receipts\": {\n    async up(db: Kysely<any>) {\n      // Update the log filter ID keys to include the integer includeTransactionReceipts value.\n      // Note that we have to remove the FK constraint, which is fine given our app logic.\n      await db.schema\n        .alterTable(\"logFilterIntervals\")\n        .dropConstraint(\"logFilterIntervals_logFilterId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"logFilters\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"logFilterIntervals\")\n        .set({ logFilterId: sql`\"logFilterId\" || '_0'` })\n        .execute();\n      // Add the includeTransactionReceipts column. By setting a default in the ADD COLUMN statement,\n      // Postgres will automatically populate all existing rows with the default value. But, we don't\n      // actually want a default (want to require a value on insertion), so immediately drop the default.\n      await db.schema\n        .alterTable(\"logFilters\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      // Repeat the same 2 steps for the factory tables.\n      await db.schema\n        .alterTable(\"factoryLogFilterIntervals\")\n        .dropConstraint(\"factoryLogFilterIntervals_factoryId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"factories\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"factoryLogFilterIntervals\")\n        .set({ factoryId: sql`\"factoryId\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactionReceipts\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"contractAddress\", \"varchar(66)\")\n        .addColumn(\"cumulativeGasUsed\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"effectiveGasPrice\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"logs\", \"text\", (col) => col.notNull())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"status\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) =>\n          col.notNull().primaryKey(),\n        )\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .execute();\n    },\n  },\n  \"2024_04_23_0_block_filters\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blockFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${interval}_${offset}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"interval\", \"integer\", (col) => col.notNull())\n        .addColumn(\"offset\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createTable(\"blockFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"blockFilterId\", \"text\", (col) =>\n          col.notNull().references(\"blockFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockFilterIntervalsBlockFilterId\")\n        .on(\"blockFilterIntervals\")\n        .column(\"blockFilterId\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n\n      await db.executeQuery(\n        sql`\n          CREATE TEMP TABLE bcp_vals AS \n          SELECT\n            blocks.hash,\n            (lpad(blocks.timestamp::text, 10, '0') ||\n            lpad(blocks.\"chainId\"::text, 16, '0') ||\n            lpad(blocks.number::text, 16, '0') ||\n            '9999999999999999' ||\n            '5' ||\n            '0000000000000000') AS checkpoint\n          FROM ponder_sync.blocks\n          `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.blocks\n          SET checkpoint=bcp_vals.checkpoint\n          FROM bcp_vals\n          WHERE ponder_sync.blocks.hash = bcp_vals.hash\n        `.compile(db),\n      );\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"checkpoint\", (col) => col.setNotNull())\n        .execute();\n\n      // The blocks.number index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n      // The blocks.chainId index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockChainIdIndex\")\n        .on(\"blocks\")\n        .column(\"chainId\")\n        .execute();\n      // The blocks.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"blockCheckpointIndex\")\n        .on(\"blocks\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_05_07_0_trace_filters\": {\n    async up(db: Kysely<any>) {\n      // TODO(kyle) drop foreign key constraint on \"blockFilterIntervals.blockFilterId\".\n\n      await db.schema\n        .createTable(\"traceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${fromAddress}_${toAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .addColumn(\"toAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"traceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"traceFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"traceFilterIntervalsTraceFilterId\")\n        .on(\"traceFilterIntervals\")\n        .column(\"traceFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"callTraces\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"callType\", \"text\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"error\", \"text\")\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\")\n        .addColumn(\"output\", \"text\")\n        .addColumn(\"subtraces\", \"integer\", (col) => col.notNull())\n        .addColumn(\"traceAddress\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionPosition\", \"integer\", (col) => col.notNull())\n        .addColumn(\"functionSelector\", \"varchar(10)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      // The callTraces.blockNumber index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"callTracesBlockNumberIndex\")\n        .on(\"callTraces\")\n        .column(\"blockNumber\")\n        .execute();\n\n      // The callTraces.functionSelector index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFunctionSelectorIndex\")\n        .on(\"callTraces\")\n        .column(\"functionSelector\")\n        .execute();\n\n      // The callTraces.error index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesErrorIndex\")\n        .on(\"callTraces\")\n        .column(\"error\")\n        .execute();\n\n      // The callTraces.blockHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesBlockHashIndex\")\n        .on(\"callTraces\")\n        .column(\"blockHash\")\n        .execute();\n\n      // The callTraces.transactionHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesTransactionHashIndex\")\n        .on(\"callTraces\")\n        .column(\"transactionHash\")\n        .execute();\n\n      // The callTraces.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesCheckpointIndex\")\n        .on(\"callTraces\")\n        .column(\"checkpoint\")\n        .execute();\n\n      // The callTraces.chainId index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesChainIdIndex\")\n        .on(\"callTraces\")\n        .column(\"chainId\")\n        .execute();\n\n      // The callTraces.from index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFromIndex\")\n        .on(\"callTraces\")\n        .column(\"from\")\n        .execute();\n\n      // The callTraces.to index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesToIndex\")\n        .on(\"callTraces\")\n        .column(\"to\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factoryLogFilters\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factoryTraceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryTraceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\")\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryTraceFilterIntervalsFactoryId\")\n        .on(\"factoryTraceFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport async function moveLegacyTables({\n  common,\n  db,\n  newSchemaName,\n}: {\n  common: Common;\n  db: Kysely<any>;\n  newSchemaName: string;\n}) {\n  // If the database has ponder migration tables present in the public schema,\n  // move them to the new schema.\n  let hasLegacyMigrations = false;\n  try {\n    const { rows } = await db.executeQuery<{ name: string }>(\n      sql`SELECT * FROM public.kysely_migration LIMIT 1`.compile(db),\n    );\n    if (rows[0]?.name === \"2023_05_15_0_initial\") hasLegacyMigrations = true;\n  } catch (e) {\n    const error = e as Error;\n    if (!error.message.includes(\"does not exist\")) throw error;\n  }\n\n  if (!hasLegacyMigrations) return;\n\n  common.logger.warn({\n    service: \"database\",\n    msg: \"Detected legacy sync migrations. Moving tables from 'public' schema to 'ponder_sync'.\",\n  });\n\n  async function moveOrDeleteTable(tableName: string) {\n    try {\n      await db.schema\n        .alterTable(`public.${tableName}`)\n        .setSchema(newSchemaName)\n        .execute();\n    } catch (e) {\n      const error = e as Error;\n      switch (error.message) {\n        case `relation \"${tableName}\" already exists in schema \"${newSchemaName}\"`: {\n          await db.schema\n            .dropTable(`public.${tableName}`)\n            .execute()\n            // Ignore errors if this fails.\n            .catch(() => {});\n          break;\n        }\n        case `relation \"public.${tableName}\" does not exist`: {\n          break;\n        }\n        default: {\n          common.logger.warn({\n            service: \"database\",\n            msg: `Failed to migrate table \"${tableName}\" to \"ponder_sync\" schema: ${error.message}`,\n          });\n        }\n      }\n    }\n\n    common.logger.warn({\n      service: \"database\",\n      msg: `Successfully moved 'public.${tableName}' table to 'ponder_sync' schema.`,\n    });\n  }\n\n  const tableNames = [\n    \"kysely_migration\",\n    \"kysely_migration_lock\",\n    \"blocks\",\n    \"logs\",\n    \"transactions\",\n    \"rpcRequestResults\",\n    // Note that logFilterIntervals has a constraint that uses logFilters,\n    // so the order here matters. Same story with factoryLogFilterIntervals.\n    \"logFilterIntervals\",\n    \"logFilters\",\n    \"factoryLogFilterIntervals\",\n    \"factories\",\n    // Old ones that are no longer being used, but should still be moved\n    // so that older migrations work as expected.\n    \"contractReadResults\",\n    \"logFilterCachedRanges\",\n  ];\n\n  for (const tableName of tableNames) {\n    await moveOrDeleteTable(tableName);\n  }\n}\n","export type Checkpoint = {\n  blockTimestamp: number;\n  chainId: bigint;\n  blockNumber: bigint;\n  transactionIndex: bigint;\n  eventType: number;\n  eventIndex: bigint;\n};\n\n// 10 digits for unix timestamp gets us to the year 2277.\nconst BLOCK_TIMESTAMP_DIGITS = 10;\n// Chain IDs are uint256. As of writing the largest Chain ID on https://chainlist.org\n// is 13 digits. 16 digits should be enough (JavaScript's max safe integer).\nconst CHAIN_ID_DIGITS = 16;\n// Same logic as chain ID.\nconst BLOCK_NUMBER_DIGITS = 16;\n// Same logic as chain ID.\nconst TRANSACTION_INDEX_DIGITS = 16;\n// At time of writing, we only have 2 event types planned, so one digit (10 types) is enough.\nconst EVENT_TYPE_DIGITS = 1;\n// This could contain log index, trace index, etc. 16 digits should be enough.\nconst EVENT_INDEX_DIGITS = 16;\n\nconst CHECKPOINT_LENGTH =\n  BLOCK_TIMESTAMP_DIGITS +\n  CHAIN_ID_DIGITS +\n  BLOCK_NUMBER_DIGITS +\n  TRANSACTION_INDEX_DIGITS +\n  EVENT_TYPE_DIGITS +\n  EVENT_INDEX_DIGITS;\n\nexport const EVENT_TYPES = {\n  blocks: 5,\n  logs: 5,\n  callTraces: 7,\n} as const;\n\nexport const encodeCheckpoint = (checkpoint: Checkpoint) => {\n  const {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  } = checkpoint;\n\n  if (eventType < 0 || eventType > 9)\n    throw new Error(\n      `Got invalid event type ${eventType}, expected a number from 0 to 9`,\n    );\n\n  const result =\n    blockTimestamp.toString().padStart(BLOCK_TIMESTAMP_DIGITS, \"0\") +\n    chainId.toString().padStart(CHAIN_ID_DIGITS, \"0\") +\n    blockNumber.toString().padStart(BLOCK_NUMBER_DIGITS, \"0\") +\n    transactionIndex.toString().padStart(TRANSACTION_INDEX_DIGITS, \"0\") +\n    eventType.toString() +\n    eventIndex.toString().padStart(EVENT_INDEX_DIGITS, \"0\");\n\n  if (result.length !== CHECKPOINT_LENGTH)\n    throw new Error(`Invalid stringified checkpoint: ${result}`);\n\n  return result;\n};\n\nexport const decodeCheckpoint = (checkpoint: string): Checkpoint => {\n  let offset = 0;\n\n  const blockTimestamp = +checkpoint.slice(\n    offset,\n    offset + BLOCK_TIMESTAMP_DIGITS,\n  );\n  offset += BLOCK_TIMESTAMP_DIGITS;\n\n  const chainId = BigInt(checkpoint.slice(offset, offset + CHAIN_ID_DIGITS));\n  offset += CHAIN_ID_DIGITS;\n\n  const blockNumber = BigInt(\n    checkpoint.slice(offset, offset + BLOCK_NUMBER_DIGITS),\n  );\n  offset += BLOCK_NUMBER_DIGITS;\n\n  const transactionIndex = BigInt(\n    checkpoint.slice(offset, offset + TRANSACTION_INDEX_DIGITS),\n  );\n  offset += TRANSACTION_INDEX_DIGITS;\n\n  const eventType = +checkpoint.slice(offset, offset + EVENT_TYPE_DIGITS);\n  offset += EVENT_TYPE_DIGITS;\n\n  const eventIndex = BigInt(\n    checkpoint.slice(offset, offset + EVENT_INDEX_DIGITS),\n  );\n  offset += EVENT_INDEX_DIGITS;\n\n  return {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  };\n};\n\nexport const zeroCheckpoint: Checkpoint = {\n  blockTimestamp: 0,\n  chainId: 0n,\n  blockNumber: 0n,\n  transactionIndex: 0n,\n  eventType: 0,\n  eventIndex: 0n,\n};\n\nexport const maxCheckpoint: Checkpoint = {\n  blockTimestamp: 99999_99999,\n  chainId: 9999_9999_9999_9999n,\n  blockNumber: 9999_9999_9999_9999n,\n  transactionIndex: 9999_9999_9999_9999n,\n  eventType: 9,\n  eventIndex: 9999_9999_9999_9999n,\n};\n\n/**\n * Returns true if two checkpoints are equal.\n */\nexport const isCheckpointEqual = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) === encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than checkpoint b.\n * Returns false if the checkpoints are equal.\n */\nexport const isCheckpointGreaterThan = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) > encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than or equal to checkpoint b.\n */\nexport const isCheckpointGreaterThanOrEqualTo = (\n  a: Checkpoint,\n  b: Checkpoint,\n) => encodeCheckpoint(a) >= encodeCheckpoint(b);\n\nexport const checkpointMax = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((max, checkpoint) => {\n    return isCheckpointGreaterThan(checkpoint, max) ? checkpoint : max;\n  });\n\nexport const checkpointMin = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((min, checkpoint) => {\n    return isCheckpointGreaterThan(min, checkpoint) ? checkpoint : min;\n  });\n\nexport const LATEST = encodeCheckpoint(maxCheckpoint);\n","import { createHash } from \"node:crypto\";\n\n// Adapted from https://stackoverflow.com/questions/77336994/stronger-type-for-value-in-json-stringifyvalue-any\ntype JSONSerializable =\n  | string\n  | number\n  | boolean\n  | null\n  | JSONObject\n  | JSONArray;\ntype JSONObject = { [key: string]: JSONSerializable };\ntype JSONArray = Array<JSONSerializable>;\n\n/**\n * Generates a 10-character hexadecimal hash of a JSON-serializable value.\n */\nexport function hash(value: JSONSerializable): string {\n  return createHash(\"sha256\")\n    .update(JSON.stringify(value))\n    .digest(\"hex\")\n    .slice(0, 10);\n}\n","import pg, { type PoolConfig } from \"pg\";\nimport { prettyPrint } from \"./print.js\";\n\n// See https://github.com/brianc/node-pg-types for details.\n// Use BigInt for `numeric` types.\npg.types.setTypeParser(pg.types.builtins.NUMERIC, BigInt);\n// Use Number for `bigint`/`int8` types. We use these for chain IDs.\npg.types.setTypeParser(pg.types.builtins.INT8, Number);\n\n// Monkeypatch Pool.query to get more informative stack traces. I have no idea why this works.\n// https://stackoverflow.com/a/70601114\nconst originalClientQuery = pg.Client.prototype.query;\n// @ts-ignore\npg.Client.prototype.query = function query(\n  ...args: [queryText: string, values: any[], callback: () => void]\n) {\n  try {\n    return originalClientQuery.apply(this, args);\n  } catch (error_) {\n    const error = error_ as Error & { detail?: string; meta?: string };\n    const [statement, parameters_] = args ?? [\"empty\", []];\n\n    error.name = \"PostgresError\";\n\n    let parameters = parameters_ ?? [];\n    parameters =\n      parameters.length <= 25\n        ? parameters\n        : parameters.slice(0, 26).concat([\"...\"]);\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {},\n    );\n\n    const metaMessages = [];\n    if (error.detail) metaMessages.push(`Detail:\\n  ${error.detail}`);\n    metaMessages.push(`Statement:\\n  ${statement}`);\n    metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    error.meta = metaMessages.join(\"\\n\");\n\n    throw error;\n  }\n};\n\nexport function createPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 2 * 60 * 1000, // 2 minutes\n    ...config,\n  });\n}\n","// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/transaction.ts#L6-L19\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined) return null;\n\n      const trimmedValue =\n        typeof value === \"string\" && value.length > 80\n          ? value.slice(0, 80).concat(\"...\")\n          : value;\n\n      return [key, trimmedValue];\n    })\n    .filter(Boolean) as [string, string][];\n  const maxLength = entries.reduce(\n    (acc, [key]) => Math.max(acc, key.length),\n    0,\n  );\n  return entries\n    .map(([key, value]) => `  ${`${key}`.padEnd(maxLength + 1)}  ${value}`)\n    .join(\"\\n\");\n}\n","import type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { PoolConfig } from \"@/config/database.js\";\nimport type { Enum, Schema, Table } from \"@/schema/common.js\";\nimport {\n  encodeSchema,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n} from \"@/schema/utils.js\";\nimport type { SyncStoreTables } from \"@/sync-store/postgres/encoding.js\";\nimport {\n  migrationProvider as syncMigrationProvider,\n  moveLegacyTables,\n} from \"@/sync-store/postgres/migrations.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { formatEta } from \"@/utils/format.js\";\nimport { hash } from \"@/utils/hash.js\";\nimport { createPool } from \"@/utils/pg.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport {\n  type CreateTableBuilder,\n  type Insertable,\n  Kysely,\n  Migrator,\n  PostgresDialect,\n  Transaction as KyselyTransaction,\n  WithSchemaPlugin,\n  sql,\n} from \"kysely\";\nimport type { Pool } from \"pg\";\nimport prometheus from \"prom-client\";\nimport { HeadlessKysely } from \"../kysely.js\";\nimport { revertIndexingTables } from \"../revert.js\";\nimport type { BaseDatabaseService, NamespaceInfo } from \"../service.js\";\nimport { type InternalTables, migrationProvider } from \"./migrations.js\";\n\nexport class PostgresDatabaseService implements BaseDatabaseService {\n  kind = \"postgres\" as const;\n\n  private internalNamespace = \"ponder\";\n\n  private common: Common;\n  private userNamespace: string;\n  private publishSchema?: string | undefined;\n\n  db: HeadlessKysely<InternalTables>;\n  syncDb: HeadlessKysely<SyncStoreTables>;\n  indexingDb: HeadlessKysely<any>;\n  readonlyDb: HeadlessKysely<any>;\n\n  private schema: Schema = null!;\n  private buildId: string = null!;\n  private heartbeatInterval?: NodeJS.Timeout;\n\n  // Only need these for metrics.\n  private internalPool: Pool;\n  private syncPool: Pool;\n  private indexingPool: Pool;\n  private readonlyPool: Pool;\n\n  constructor({\n    common,\n    poolConfig,\n    userNamespace,\n    publishSchema,\n    isReadonly = false,\n  }: {\n    common: Common;\n    poolConfig: PoolConfig;\n    userNamespace: string;\n    publishSchema?: string | undefined;\n    isReadonly?: boolean;\n  }) {\n    this.common = common;\n    this.userNamespace = userNamespace;\n    this.publishSchema = publishSchema;\n\n    const internalMax = 2;\n    const equalMax = Math.floor((poolConfig.max - internalMax) / 3);\n    const [readonlyMax, indexingMax, syncMax] = isReadonly\n      ? [poolConfig.max - internalMax, 0, 0]\n      : [equalMax, equalMax, equalMax];\n\n    this.internalPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_internal`,\n      max: internalMax,\n      statement_timeout: 10 * 60 * 1000, // 10 minutes to accommodate slow sync store migrations.\n    });\n    this.syncPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_sync`,\n      max: readonlyMax,\n    });\n    this.indexingPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_indexing`,\n      max: indexingMax,\n    });\n    this.readonlyPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_readonly`,\n      max: syncMax,\n    });\n\n    this.db = new HeadlessKysely<InternalTables>({\n      name: \"internal\",\n      common,\n      dialect: new PostgresDialect({ pool: this.internalPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"internal\" });\n        }\n      },\n    });\n\n    this.syncDb = new HeadlessKysely<SyncStoreTables>({\n      name: \"sync\",\n      common,\n      dialect: new PostgresDialect({ pool: this.syncPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"sync\" });\n        }\n      },\n      plugins: [new WithSchemaPlugin(\"ponder_sync\")],\n    });\n\n    this.indexingDb = new HeadlessKysely<InternalTables>({\n      name: \"indexing\",\n      common,\n      dialect: new PostgresDialect({ pool: this.indexingPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"indexing\" });\n        }\n      },\n    });\n\n    this.readonlyDb = new HeadlessKysely<InternalTables>({\n      name: \"readonly\",\n      common,\n      dialect: new PostgresDialect({ pool: this.readonlyPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"readonly\" });\n        }\n      },\n    });\n\n    this.registerMetrics();\n  }\n\n  async setup({ schema, buildId }: { schema: Schema; buildId: string }) {\n    this.schema = schema;\n    this.buildId = buildId;\n\n    await this.db.schema\n      .createSchema(this.userNamespace)\n      .ifNotExists()\n      .execute();\n    await this.db.schema\n      .createSchema(this.internalNamespace)\n      .ifNotExists()\n      .execute();\n\n    const migrator = new Migrator({\n      db: this.db.withPlugin(new WithSchemaPlugin(this.internalNamespace)),\n      provider: migrationProvider,\n      migrationTableSchema: this.internalNamespace,\n    });\n    const result = await migrator.migrateToLatest();\n\n    if (result.error) throw result.error;\n\n    const namespaceInfo = {\n      userNamespace: this.userNamespace,\n      internalNamespace: this.internalNamespace,\n      internalTableIds: Object.keys(getTables(schema)).reduce(\n        (acc, tableName) => {\n          acc[tableName] = hash([this.userNamespace, this.buildId, tableName]);\n          return acc;\n        },\n        {} as { [tableName: string]: string },\n      ),\n    } satisfies NamespaceInfo;\n\n    return this.db.wrap({ method: \"setup\" }, async () => {\n      const attemptSetup = async () => {\n        return await this.db.transaction().execute(async (tx) => {\n          const previousLockRow = await tx\n            .withSchema(this.internalNamespace)\n            .selectFrom(\"namespace_lock\")\n            .selectAll()\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .executeTakeFirst();\n\n          const newLockRow = {\n            namespace: this.userNamespace,\n            is_locked: 1,\n            heartbeat_at: Date.now(),\n            build_id: this.buildId,\n            finalized_checkpoint: encodeCheckpoint(zeroCheckpoint),\n            // Schema is encoded to be backwards compatible with old versions.\n            // `schema` should have to properties \"tables\" and \"enums\".\n            schema: encodeSchema(schema),\n          } satisfies Insertable<InternalTables[\"namespace_lock\"]>;\n\n          // Function to create the operation log tables and user tables.\n          const createTables = async () => {\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              const tableId = namespaceInfo.internalTableIds[tableName];\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createTable(tableId)\n                .$call((builder) =>\n                  this.buildOperationLogColumns(builder, table.table),\n                )\n                .execute();\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createIndex(`${tableId}_checkpointIndex`)\n                .on(tableId)\n                .column(\"checkpoint\")\n                .execute();\n\n              try {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .createTable(tableName)\n                  .$call((builder) =>\n                    this.buildColumns(builder, schema, table.table),\n                  )\n                  .execute();\n              } catch (err) {\n                const error = err as Error;\n                if (!error.message.includes(\"already exists\")) throw error;\n                throw new NonRetryableError(\n                  `Unable to create table '${this.userNamespace}'.'${tableName}' because a table with that name already exists. Is there another application using the '${this.userNamespace}' database schema?`,\n                );\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Created table '${this.userNamespace}'.'${tableName}'`,\n              });\n            }\n          };\n\n          // If no lock row is found for this namespace, we can acquire the lock.\n          if (previousLockRow === undefined) {\n            await tx\n              .withSchema(this.internalNamespace)\n              .insertInto(\"namespace_lock\")\n              .values(newLockRow)\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on new schema '${this.userNamespace}'`,\n            });\n\n            await createTables();\n\n            return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n          }\n\n          // If the lock row is held and has not expired, we cannot proceed.\n          const expiresAt =\n            previousLockRow.heartbeat_at +\n            this.common.options.databaseHeartbeatTimeout;\n\n          if (previousLockRow.is_locked === 1 && Date.now() <= expiresAt) {\n            const expiresInMs = expiresAt - Date.now();\n            return { status: \"locked\", expiresInMs } as const;\n          }\n\n          // If the lock row has the same build ID as the current app AND\n          // has a non-zero finalized checkpoint, we can revert unfinalized\n          // rows and continue where it left off.\n          if (\n            this.common.options.command === \"start\" &&\n            previousLockRow.build_id === this.buildId &&\n            previousLockRow.finalized_checkpoint !==\n              encodeCheckpoint(zeroCheckpoint)\n          ) {\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Detected cache hit for build '${this.buildId}' in schema '${\n                this.userNamespace\n              }' last active ${formatEta(\n                Date.now() - previousLockRow.heartbeat_at,\n              )} ago`,\n            });\n\n            // Remove any indexes, will be recreated once the app\n            // becomes healthy.\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              if (table.constraints === undefined) continue;\n\n              for (const name of Object.keys(table.constraints)) {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .dropIndex(`${tableName}_${name}`)\n                  .ifExists()\n                  .execute();\n\n                this.common.logger.info({\n                  service: \"database\",\n                  msg: `Dropped index '${tableName}_${name}' in schema '${this.userNamespace}'`,\n                });\n              }\n            }\n\n            await tx\n              .withSchema(this.internalNamespace)\n              .updateTable(\"namespace_lock\")\n              .set({ is_locked: 1, heartbeat_at: Date.now() })\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on schema '${this.userNamespace}'`,\n            });\n\n            const finalizedCheckpoint = decodeCheckpoint(\n              previousLockRow.finalized_checkpoint,\n            );\n\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Reverting operations prior to finalized checkpoint (timestamp=${finalizedCheckpoint.blockTimestamp} chainId=${finalizedCheckpoint.chainId} block=${finalizedCheckpoint.blockNumber})`,\n            });\n\n            // Revert unfinalized data from the existing tables.\n            const tx_ = tx as KyselyTransaction<any>;\n            for (const [tableName, tableId] of Object.entries(\n              namespaceInfo.internalTableIds,\n            )) {\n              const rows = await tx_\n                .withSchema(namespaceInfo.internalNamespace)\n                .deleteFrom(tableId)\n                .returningAll()\n                .where(\"checkpoint\", \">\", previousLockRow.finalized_checkpoint)\n                .execute();\n\n              const reversed = rows.sort(\n                (a, b) => b.operation_id - a.operation_id,\n              );\n\n              for (const log of reversed) {\n                if (log.operation === 0) {\n                  // Create\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .deleteFrom(tableName)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else if (log.operation === 1) {\n                  // Update\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .updateTable(tableName)\n                    .set(log)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else {\n                  // Delete\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .insertInto(tableName)\n                    .values(log)\n                    .execute();\n                }\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Reverted ${rows.length} unfinalized operations from existing '${tableName}' table`,\n              });\n            }\n\n            return {\n              status: \"success\",\n              checkpoint: finalizedCheckpoint,\n            } as const;\n          }\n\n          // Otherwise, the lock row has a different build ID or a zero finalized checkpoint,\n          // so we need to drop the previous app's tables and create new ones.\n          const previousBuildId = previousLockRow.build_id;\n          // Note: `previousSchema` should only be used to get table names or enum names because\n          // the types of `Table` and `Enum` have changed between versions.\n          const previousSchema = previousLockRow.schema as unknown as {\n            tables: { [tableName: string]: Table };\n            enums: { [enumName: string]: Enum };\n          };\n\n          await tx\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set(newLockRow)\n            .execute();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Acquired lock on schema '${this.userNamespace}' previously used by build '${previousBuildId}'`,\n          });\n\n          for (const tableName of Object.keys(previousSchema.tables)) {\n            const tableId = hash([\n              this.userNamespace,\n              previousBuildId,\n              tableName,\n            ]);\n\n            await tx.schema\n              .withSchema(this.internalNamespace)\n              .dropTable(tableId)\n              .ifExists()\n              .execute();\n\n            await tx.schema\n              .withSchema(this.userNamespace)\n              .dropTable(tableName)\n              .cascade() // Need cascade here to drop dependent published views.\n              .ifExists()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped '${tableName}' table left by previous build`,\n            });\n          }\n\n          await createTables();\n\n          return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n        });\n      };\n\n      const result = await attemptSetup();\n\n      let finalizedCheckpoint: Checkpoint;\n\n      if (result.status === \"success\") {\n        finalizedCheckpoint = result.checkpoint;\n      } else {\n        // If the namespace is locked, attempt one more time after waiting the timeout.\n        const { expiresInMs } = result;\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Schema '${this.userNamespace}' is locked by a different Ponder app`,\n        });\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Waiting ${formatEta(expiresInMs)} for lock on schema '${\n            this.userNamespace\n          }' to expire...`,\n        });\n\n        await wait(expiresInMs);\n\n        const resultTwo = await attemptSetup();\n        if (resultTwo.status === \"locked\") {\n          throw new NonRetryableError(\n            `Failed to acquire lock on schema '${this.userNamespace}'. A different Ponder app is actively using this schema.`,\n          );\n        }\n        finalizedCheckpoint = resultTwo.checkpoint;\n      }\n\n      // Start the heartbeat interval to hold the lock for as long as the process is running.\n      this.heartbeatInterval = setInterval(async () => {\n        try {\n          const lockRow = await this.db\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set({ heartbeat_at: Date.now() })\n            .returningAll()\n            .executeTakeFirst();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Updated heartbeat timestamp to ${lockRow?.heartbeat_at} for current build '${this.buildId}'`,\n          });\n        } catch (err) {\n          const error = err as Error;\n          this.common.logger.error({\n            service: \"database\",\n            msg: `Failed to update heartbeat timestamp, retrying in ${formatEta(\n              this.common.options.databaseHeartbeatInterval,\n            )}`,\n            error,\n          });\n        }\n      }, this.common.options.databaseHeartbeatInterval);\n\n      return { checkpoint: finalizedCheckpoint, namespaceInfo };\n    });\n  }\n\n  async revert({\n    checkpoint,\n    namespaceInfo,\n  }: {\n    checkpoint: Checkpoint;\n    namespaceInfo: NamespaceInfo;\n  }) {\n    await revertIndexingTables({\n      db: this.indexingDb,\n      checkpoint,\n      namespaceInfo,\n    });\n  }\n\n  async updateFinalizedCheckpoint({\n    checkpoint,\n  }: { checkpoint: Checkpoint }): Promise<void> {\n    await this.db.wrap({ method: \"updateFinalizedCheckpoint\" }, async () => {\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ finalized_checkpoint: encodeCheckpoint(checkpoint) })\n        .execute();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Updated finalized checkpoint to (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} block=${checkpoint.blockNumber})`,\n      });\n    });\n  }\n\n  async publish() {\n    await this.db.wrap({ method: \"publish\" }, async () => {\n      const publishSchema = this.publishSchema;\n      if (publishSchema === undefined) {\n        this.common.logger.debug({\n          service: \"database\",\n          msg: \"Not publishing views, publish schema was not defined\",\n        });\n        return;\n      }\n\n      await this.db.transaction().execute(async (tx) => {\n        // Create the publish schema if it doesn't exist.\n        await tx.schema.createSchema(publishSchema).ifNotExists().execute();\n\n        for (const tableName of Object.keys(getTables(this.schema))) {\n          // Check if there is an existing relation with the name we're about to publish.\n          const result = await tx.executeQuery<{\n            table_type: string;\n          }>(\n            sql`\n              SELECT table_type\n              FROM information_schema.tables\n              WHERE table_schema = '${sql.raw(publishSchema)}'\n              AND table_name = '${sql.raw(tableName)}'\n            `.compile(tx),\n          );\n\n          const isTable = result.rows[0]?.table_type === \"BASE TABLE\";\n          if (isTable) {\n            this.common.logger.warn({\n              service: \"database\",\n              msg: `Unable to publish view '${publishSchema}'.'${tableName}' because a table with that name already exists`,\n            });\n            continue;\n          }\n\n          const isView = result.rows[0]?.table_type === \"VIEW\";\n          if (isView) {\n            await tx.schema\n              .withSchema(publishSchema)\n              .dropView(tableName)\n              .ifExists()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped existing view '${publishSchema}'.'${tableName}'`,\n            });\n          }\n\n          await tx.schema\n            .withSchema(publishSchema)\n            .createView(tableName)\n            .as(\n              (tx as Kysely<any>)\n                .withSchema(this.userNamespace)\n                .selectFrom(tableName)\n                .selectAll(),\n            )\n            .execute();\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created view '${publishSchema}'.'${tableName}' serving data from '${this.userNamespace}'.'${tableName}'`,\n          });\n        }\n      });\n    });\n  }\n\n  async createIndexes({ schema }: { schema: Schema }) {\n    await Promise.all(\n      Object.entries(getTables(schema)).flatMap(([tableName, table]) => {\n        if (table.constraints === undefined) return [];\n\n        return Object.entries(table.constraints).map(async ([name, index]) => {\n          await this.db.wrap({ method: \"createIndexes\" }, async () => {\n            const indexName = `${tableName}_${name}`;\n\n            const indexColumn = index[\" column\"];\n            const order = index[\" order\"];\n            const nulls = index[\" nulls\"];\n\n            const columns = Array.isArray(indexColumn)\n              ? indexColumn.map((ic) => `\"${ic}\"`).join(\", \")\n              : `\"${indexColumn}\" ${\n                  order === \"asc\" ? \"ASC\" : order === \"desc\" ? \"DESC\" : \"\"\n                } ${\n                  nulls === \"first\"\n                    ? \"NULLS FIRST\"\n                    : nulls === \"last\"\n                      ? \"NULLS LAST\"\n                      : \"\"\n                }`;\n\n            await this.db.executeQuery(\n              sql`CREATE INDEX ${sql.ref(indexName)} ON ${sql.table(\n                `${this.userNamespace}.${tableName}`,\n              )} (${sql.raw(columns)})`.compile(this.db),\n            );\n          });\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created index '${tableName}_${name}' on columns (${\n              Array.isArray(index[\" column\"])\n                ? index[\" column\"].join(\", \")\n                : index[\" column\"]\n            }) in schema '${this.userNamespace}'`,\n          });\n        });\n      }),\n    );\n  }\n\n  async kill() {\n    await this.db.wrap({ method: \"kill\" }, async () => {\n      clearInterval(this.heartbeatInterval);\n\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ is_locked: 0 })\n        .returningAll()\n        .executeTakeFirst();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Released lock on namespace '${this.userNamespace}'`,\n      });\n\n      await this.readonlyDb.destroy();\n      await this.indexingDb.destroy();\n      await this.syncDb.destroy();\n      await this.db.destroy();\n\n      await this.readonlyPool.end();\n      await this.indexingPool.end();\n      await this.syncPool.end();\n      await this.internalPool.end();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: \"Closed database connection pools\",\n      });\n    });\n  }\n\n  async migrateSyncStore() {\n    await this.db.wrap({ method: \"migrateSyncStore\" }, async () => {\n      // TODO: Probably remove this at 1.0 to speed up startup time.\n      await moveLegacyTables({\n        common: this.common,\n        db: this.db as Kysely<any>,\n        newSchemaName: \"ponder_sync\",\n      });\n\n      const migrator = new Migrator({\n        db: this.db.withPlugin(new WithSchemaPlugin(\"ponder_sync\")),\n        provider: syncMigrationProvider,\n        migrationTableSchema: \"ponder_sync\",\n      });\n\n      const { error } = await migrator.migrateToLatest();\n      if (error) throw error;\n    });\n  }\n\n  private buildColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    schema: Schema,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          if (isListColumn(column) === false) {\n            col = col.check(\n              sql`${sql.ref(columnName)} in (${sql.join(\n                getEnums(schema)[column[\" enum\"]].map((v) => sql.lit(v)),\n              )})`,\n            );\n          }\n          return col;\n        });\n      } else if (isListColumn(column)) {\n        // Handle scalar list table\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (isOptionalColumn(column) === false) col = col.notNull();\n            if (columnName === \"id\") col = col.primaryKey();\n            return col;\n          },\n        );\n      }\n    });\n\n    return builder;\n  }\n\n  private buildOperationLogColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        // Omit the CHECK constraint because its included in the user table\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\");\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (columnName === \"id\") col = col.notNull();\n            return col;\n          },\n        );\n      }\n    });\n\n    builder = builder\n      .addColumn(\"operation_id\", \"serial\", (col) => col.notNull().primaryKey())\n      .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n      .addColumn(\"operation\", \"integer\", (col) => col.notNull());\n\n    return builder;\n  }\n\n  private registerMetrics() {\n    const service = this;\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_query_total\",\n    );\n    this.common.metrics.ponder_postgres_query_total = new prometheus.Counter({\n      name: \"ponder_postgres_query_total\",\n      help: \"Total number of queries submitted to the database\",\n      labelNames: [\"pool\"] as const,\n      registers: [this.common.metrics.registry],\n    });\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_pool_connections\",\n    );\n    this.common.metrics.ponder_postgres_pool_connections = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_pool_connections\",\n        help: \"Number of connections in the pool\",\n        labelNames: [\"pool\", \"kind\"] as const,\n        registers: [this.common.metrics.registry],\n        collect() {\n          this.set(\n            { pool: \"internal\", kind: \"idle\" },\n            service.internalPool.idleCount,\n          );\n          this.set(\n            { pool: \"internal\", kind: \"total\" },\n            service.internalPool.totalCount,\n          );\n\n          this.set({ pool: \"sync\", kind: \"idle\" }, service.syncPool.idleCount);\n          this.set(\n            { pool: \"sync\", kind: \"total\" },\n            service.syncPool.totalCount,\n          );\n\n          this.set(\n            { pool: \"indexing\", kind: \"idle\" },\n            service.indexingPool.idleCount,\n          );\n          this.set(\n            { pool: \"indexing\", kind: \"total\" },\n            service.indexingPool.totalCount,\n          );\n\n          this.set(\n            { pool: \"readonly\", kind: \"idle\" },\n            service.readonlyPool.idleCount,\n          );\n          this.set(\n            { pool: \"readonly\", kind: \"total\" },\n            service.readonlyPool.totalCount,\n          );\n        },\n      },\n    );\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_query_queue_size\",\n    );\n    this.common.metrics.ponder_postgres_query_queue_size = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_query_queue_size\",\n        help: \"Number of query requests waiting for an available connection\",\n        labelNames: [\"pool\"] as const,\n        registers: [this.common.metrics.registry],\n        collect() {\n          this.set({ pool: \"internal\" }, service.internalPool.waitingCount);\n          this.set({ pool: \"sync\" }, service.syncPool.waitingCount);\n          this.set({ pool: \"indexing\" }, service.indexingPool.waitingCount);\n          this.set({ pool: \"readonly\" }, service.readonlyPool.waitingCount);\n        },\n      },\n    );\n  }\n}\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"float8\",\n  string: \"text\",\n  bigint: \"numeric(78, 0)\",\n  hex: \"bytea\",\n} as const;\n","import type { Common } from \"@/common/common.js\";\nimport { IgnorableError, NonRetryableError } from \"@/common/errors.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { Kysely, type KyselyConfig, type KyselyProps } from \"kysely\";\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\nexport class HeadlessKysely<DB> extends Kysely<DB> {\n  private common: Common;\n  private name: string;\n  private isKilled = false;\n\n  constructor({\n    common,\n    name,\n    ...args\n  }: (KyselyConfig | KyselyProps) & { name: string; common: Common }) {\n    super(args);\n    this.common = common;\n    this.name = name;\n  }\n\n  override async destroy() {\n    this.isKilled = true;\n  }\n\n  wrap = async <T>(\n    options: { method: string },\n    fn: () => Promise<T>,\n    // TypeScript can't infer that we always return or throw.\n    // @ts-ignore\n  ): Promise<T> => {\n    // First error thrown is often the most useful\n    let firstError: any;\n    let hasError = false;\n\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      const endClock = startClock();\n      try {\n        const result = await fn();\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        return result;\n      } catch (_error) {\n        const error = _error as Error;\n\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        this.common.metrics.ponder_database_method_error_total.inc({\n          service: this.name,\n          method: options.method,\n        });\n\n        if (this.isKilled) {\n          this.common.logger.trace({\n            service: this.name,\n            msg: `Ignored error during '${options.method}' database method (service is killed)`,\n          });\n          throw new IgnorableError();\n        }\n\n        if (!hasError) {\n          hasError = true;\n          firstError = error;\n        }\n\n        if (error instanceof NonRetryableError) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method with non-retryable error: ${firstError.message}`,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method after '${\n              i + 1\n            }' attempts with error: ${firstError.message}`,\n          });\n          throw firstError;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        this.common.logger.debug({\n          service: this.name,\n          msg: `Failed '${options.method}' database method, retrying after ${duration} milliseconds. Error: ${error.message}`,\n        });\n        await wait(duration);\n      }\n    }\n  };\n}\n","import { type Checkpoint, encodeCheckpoint } from \"@/utils/checkpoint.js\";\nimport type { HeadlessKysely } from \"./kysely.js\";\nimport type { NamespaceInfo } from \"./service.js\";\n\nexport const revertIndexingTables = async ({\n  checkpoint,\n  namespaceInfo,\n  db,\n}: {\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n  checkpoint: Checkpoint;\n}) => {\n  await db.wrap({ method: \"revert\" }, async () => {\n    const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n    await Promise.all(\n      Object.entries(namespaceInfo.internalTableIds).map(\n        async ([tableName, tableId]) => {\n          await db.transaction().execute(async (tx) => {\n            const rows = await tx\n              .withSchema(namespaceInfo.internalNamespace)\n              .deleteFrom(tableId)\n              .returningAll()\n              .where(\"checkpoint\", \">\", encodedCheckpoint)\n              .execute();\n\n            const reversed = rows.sort(\n              (a, b) => b.operation_id - a.operation_id,\n            );\n\n            // undo operation\n            for (const log of reversed) {\n              if (log.operation === 0) {\n                // create\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .deleteFrom(tableName)\n                  .where(\"id\", \"=\", log.id)\n                  .execute();\n              } else if (log.operation === 1) {\n                // update\n                log.operation_id = undefined;\n                log.checkpoint = undefined;\n                log.operation = undefined;\n\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .updateTable(tableName)\n                  .set(log)\n                  .where(\"id\", \"=\", log.id)\n                  .execute();\n              } else {\n                // delete\n                log.operation_id = undefined;\n                log.checkpoint = undefined;\n                log.operation = undefined;\n\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .insertInto(tableName)\n                  .values(log)\n                  .execute();\n              }\n            }\n          });\n        },\n      ),\n    );\n  });\n};\n","import { type Kysely } from \"kysely\";\nimport { type Migration, type MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2024_03_28_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"namespace_lock\")\n        .ifNotExists()\n        .addColumn(\"namespace\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"is_locked\", \"integer\", (col) => col.notNull())\n        .addColumn(\"heartbeat_at\", \"bigint\", (col) => col.notNull())\n        .addColumn(\"build_id\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized_checkpoint\", \"varchar(75)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"schema\", \"jsonb\", (col) => col.notNull())\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport type InternalTables = {\n  namespace_lock: {\n    namespace: string;\n    is_locked: number;\n    heartbeat_at: number;\n    build_id: string;\n    finalized_checkpoint: string;\n    schema: string;\n  };\n};\n","import { existsSync, rmSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { Enum, Schema, Table } from \"@/schema/common.js\";\nimport {\n  encodeSchema,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n} from \"@/schema/utils.js\";\nimport type { SyncStoreTables } from \"@/sync-store/sqlite/encoding.js\";\nimport { migrationProvider as syncMigrationProvider } from \"@/sync-store/sqlite/migrations.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { formatEta } from \"@/utils/format.js\";\nimport { hash } from \"@/utils/hash.js\";\nimport { type SqliteDatabase, createSqliteDatabase } from \"@/utils/sqlite.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport {\n  type CreateTableBuilder,\n  type Insertable,\n  Kysely,\n  Migrator,\n  SqliteDialect,\n  Transaction as KyselyTransaction,\n  WithSchemaPlugin,\n  sql,\n} from \"kysely\";\nimport prometheus from \"prom-client\";\nimport { HeadlessKysely } from \"../kysely.js\";\nimport { revertIndexingTables } from \"../revert.js\";\nimport type { BaseDatabaseService, NamespaceInfo } from \"../service.js\";\nimport { type InternalTables, migrationProvider } from \"./migrations.js\";\n\nexport class SqliteDatabaseService implements BaseDatabaseService {\n  kind = \"sqlite\" as const;\n\n  private common: Common;\n  private directory: string;\n\n  private userNamespace: string;\n  private internalNamespace: string;\n\n  private internalDatabase: SqliteDatabase;\n  private syncDatabase: SqliteDatabase;\n\n  db: HeadlessKysely<InternalTables>;\n  readonlyDb: HeadlessKysely<any>;\n  indexingDb: HeadlessKysely<any>;\n  syncDb: HeadlessKysely<SyncStoreTables>;\n\n  private buildId: string = null!;\n  private heartbeatInterval?: NodeJS.Timeout;\n\n  constructor({\n    common,\n    directory,\n    userNamespace = \"public\",\n  }: {\n    common: Common;\n    directory: string;\n    userNamespace?: string;\n  }) {\n    this.common = common;\n    this.directory = directory;\n\n    this.deleteV3DatabaseFiles();\n\n    this.userNamespace = userNamespace;\n    const userDatabaseFile = path.join(directory, `${userNamespace}.db`);\n\n    // Note that SQLite supports using \"main\" as the schema name for tables\n    // in the primary database (as opposed to attached databases). We include\n    // it here to more closely match Postgres, where it's required.\n    // https://www.sqlite.org/lang_attach.html\n    this.internalNamespace = \"main\";\n    const internalDatabaseFile = path.join(directory, \"ponder.db\");\n\n    this.internalDatabase = createSqliteDatabase(internalDatabaseFile);\n    this.internalDatabase.exec(\n      `ATTACH DATABASE '${userDatabaseFile}' AS ${this.userNamespace}`,\n    );\n\n    this.db = new HeadlessKysely<InternalTables>({\n      name: \"internal\",\n      common,\n      dialect: new SqliteDialect({ database: this.internalDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"internal\",\n          });\n        }\n      },\n    });\n\n    const syncDatabaseFile = path.join(directory, \"ponder_sync.db\");\n    this.syncDatabase = createSqliteDatabase(syncDatabaseFile);\n    this.syncDb = new HeadlessKysely<SyncStoreTables>({\n      name: \"sync\",\n      common,\n      dialect: new SqliteDialect({ database: this.syncDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({ database: \"sync\" });\n        }\n      },\n    });\n\n    this.indexingDb = new HeadlessKysely<InternalTables>({\n      name: \"indexing\",\n      common,\n      dialect: new SqliteDialect({ database: this.internalDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"indexing\",\n          });\n        }\n      },\n    });\n\n    this.readonlyDb = new HeadlessKysely<InternalTables>({\n      name: \"readonly\",\n      common,\n      dialect: new SqliteDialect({ database: this.internalDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"readonly\",\n          });\n        }\n      },\n    });\n\n    this.registerMetrics();\n  }\n\n  async setup({ schema, buildId }: { schema: Schema; buildId: string }) {\n    this.buildId = buildId;\n\n    const migrator = new Migrator({\n      db: this.db.withPlugin(new WithSchemaPlugin(this.internalNamespace)),\n      provider: migrationProvider,\n    });\n    const result = await migrator.migrateToLatest();\n    if (result.error) throw result.error;\n\n    const namespaceInfo = {\n      userNamespace: this.userNamespace,\n      internalNamespace: this.internalNamespace,\n      internalTableIds: Object.keys(getTables(schema)).reduce(\n        (acc, tableName) => {\n          acc[tableName] = hash([this.userNamespace, this.buildId, tableName]);\n          return acc;\n        },\n        {} as { [tableName: string]: string },\n      ),\n    } satisfies NamespaceInfo;\n\n    return this.db.wrap({ method: \"setup\" }, async () => {\n      const attemptSetup = async () => {\n        return await this.db.transaction().execute(async (tx) => {\n          const previousLockRow = await tx\n            .withSchema(this.internalNamespace)\n            .selectFrom(\"namespace_lock\")\n            .selectAll()\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .executeTakeFirst();\n\n          const newLockRow = {\n            namespace: this.userNamespace,\n            is_locked: 1,\n            heartbeat_at: Date.now(),\n            build_id: this.buildId,\n            finalized_checkpoint: encodeCheckpoint(zeroCheckpoint),\n            // Schema is encoded to be backwards compatible with old versions.\n            // `schema` should have to properties \"tables\" and \"enums\".\n            schema: encodeSchema(schema),\n          } satisfies Insertable<InternalTables[\"namespace_lock\"]>;\n\n          // Function to create the operation log tables and user tables.\n          const createTables = async () => {\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              const tableId = namespaceInfo.internalTableIds[tableName];\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createTable(tableId)\n                .$call((builder) =>\n                  this.buildOperationLogColumns(builder, table.table),\n                )\n                .execute();\n\n              await tx.schema\n                .createIndex(`${tableId}_checkpointIndex`)\n                .on(tableId)\n                .column(\"checkpoint\")\n                .execute();\n\n              try {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .createTable(tableName)\n                  .$call((builder) =>\n                    this.buildColumns(builder, schema, table.table),\n                  )\n                  .execute();\n              } catch (err) {\n                const error = err as Error;\n                if (!error.message.includes(\"already exists\")) throw error;\n                throw new NonRetryableError(\n                  `Unable to create table '${tableName}' in '${this.userNamespace}.db' because a table with that name already exists. Is there another application using the '${this.userNamespace}.db' database file?`,\n                );\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Created table '${tableName}' in '${this.userNamespace}.db'`,\n              });\n            }\n          };\n\n          // If no lock row is found for this namespace, we can acquire the lock.\n          if (previousLockRow === undefined) {\n            await tx\n              .withSchema(this.internalNamespace)\n              .insertInto(\"namespace_lock\")\n              .values(newLockRow)\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on database file '${this.userNamespace}.db'`,\n            });\n\n            await createTables();\n\n            return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n          }\n\n          // If the lock row is held and has not expired, we cannot proceed.\n          const expiresAt =\n            previousLockRow.heartbeat_at +\n            this.common.options.databaseHeartbeatTimeout;\n\n          if (previousLockRow.is_locked === 1 && Date.now() <= expiresAt) {\n            const expiresInMs = expiresAt - Date.now();\n            return { status: \"locked\", expiresInMs } as const;\n          }\n\n          // If the lock row has the same build ID as the current app AND\n          // has a non-zero finalized checkpoint, we can revert unfinalized\n          // rows and continue where it left off.\n          if (\n            this.common.options.command === \"start\" &&\n            previousLockRow.build_id === this.buildId &&\n            previousLockRow.finalized_checkpoint !==\n              encodeCheckpoint(zeroCheckpoint)\n          ) {\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Detected cache hit for build '${\n                this.buildId\n              }' in database file '${\n                this.userNamespace\n              }.db' last active ${formatEta(\n                Date.now() - previousLockRow.heartbeat_at,\n              )} ago`,\n            });\n\n            // Remove any indexes, will be recreated once the app\n            // becomes healthy.\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              if (table.constraints === undefined) continue;\n\n              for (const name of Object.keys(table.constraints)) {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .dropIndex(`${tableName}_${name}`)\n                  .ifExists()\n                  .execute();\n\n                this.common.logger.info({\n                  service: \"database\",\n                  msg: `Dropped index '${tableName}_${name}' in schema '${this.userNamespace}'`,\n                });\n              }\n            }\n\n            await tx\n              .withSchema(this.internalNamespace)\n              .updateTable(\"namespace_lock\")\n              .set({ is_locked: 1, heartbeat_at: Date.now() })\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on schema '${this.userNamespace}'`,\n            });\n\n            const finalizedCheckpoint = decodeCheckpoint(\n              previousLockRow.finalized_checkpoint,\n            );\n\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Reverting operations prior to finalized checkpoint (timestamp=${finalizedCheckpoint.blockTimestamp} chainId=${finalizedCheckpoint.chainId} block=${finalizedCheckpoint.blockNumber})`,\n            });\n\n            // Revert unfinalized data from the existing tables.\n            const tx_ = tx as KyselyTransaction<any>;\n            for (const [tableName, tableId] of Object.entries(\n              namespaceInfo.internalTableIds,\n            )) {\n              const rows = await tx_\n                .withSchema(namespaceInfo.internalNamespace)\n                .deleteFrom(tableId)\n                .returningAll()\n                .where(\"checkpoint\", \">\", previousLockRow.finalized_checkpoint)\n                .execute();\n\n              const reversed = rows.sort(\n                (a, b) => b.operation_id - a.operation_id,\n              );\n\n              for (const log of reversed) {\n                if (log.operation === 0) {\n                  // Create\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .deleteFrom(tableName)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else if (log.operation === 1) {\n                  // Update\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .updateTable(tableName)\n                    .set(log)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else {\n                  // Delete\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .insertInto(tableName)\n                    .values(log)\n                    .execute();\n                }\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Reverted ${rows.length} unfinalized operations from existing '${tableName}' table`,\n              });\n            }\n\n            return {\n              status: \"success\",\n              checkpoint: finalizedCheckpoint,\n            } as const;\n          }\n\n          // Otherwise, the lock row has a different build ID or a zero finalized checkpoint,\n          // so we need to drop the previous app's tables and create new ones.\n          const previousBuildId = previousLockRow.build_id;\n          // Note: `previousSchema` should only be used to get table names or enum names because\n          // the types of `Table` and `Enum` have changed between versions.\n          const previousSchema = JSON.parse(previousLockRow.schema) as {\n            tables: { [tableName: string]: Table };\n            enums: { [enumName: string]: Enum };\n          };\n\n          await tx\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set(newLockRow)\n            .execute();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Acquired lock on schema '${this.userNamespace}' previously used by build '${previousBuildId}'`,\n          });\n\n          for (const tableName of Object.keys(previousSchema.tables)) {\n            const tableId = hash([\n              this.userNamespace,\n              previousBuildId,\n              tableName,\n            ]);\n\n            await tx.schema\n              .withSchema(this.internalNamespace)\n              .dropTable(tableId)\n              .ifExists()\n              .execute();\n\n            await tx.schema\n              .withSchema(this.userNamespace)\n              .dropTable(tableName)\n              .ifExists()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped '${tableName}' table left by previous build`,\n            });\n          }\n\n          await createTables();\n\n          return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n        });\n      };\n\n      const result = await attemptSetup();\n\n      let finalizedCheckpoint: Checkpoint;\n\n      if (result.status === \"success\") {\n        finalizedCheckpoint = result.checkpoint;\n      } else {\n        // If the namespace is locked, attempt one more time after waiting the timeout.\n        const { expiresInMs } = result;\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Database file '${this.userNamespace}.db' is locked by a different Ponder app`,\n        });\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Waiting ${formatEta(expiresInMs)} for lock on database file '${\n            this.userNamespace\n          }.db' to expire...`,\n        });\n\n        await wait(expiresInMs);\n\n        const resultTwo = await attemptSetup();\n        if (resultTwo.status === \"locked\") {\n          throw new NonRetryableError(\n            `Failed to acquire lock on database file '${this.userNamespace}.db'. A different Ponder app is actively using this database.`,\n          );\n        }\n        finalizedCheckpoint = resultTwo.checkpoint;\n      }\n\n      // Start the heartbeat interval to hold the lock for as long as the process is running.\n      this.heartbeatInterval = setInterval(async () => {\n        try {\n          const lockRow = await this.db\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set({ heartbeat_at: Date.now() })\n            .returningAll()\n            .executeTakeFirst();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Updated heartbeat timestamp to ${lockRow?.heartbeat_at} (build_id=${this.buildId})`,\n          });\n        } catch (err) {\n          const error = err as Error;\n          this.common.logger.error({\n            service: \"database\",\n            msg: `Failed to update heartbeat timestamp, retrying in ${formatEta(\n              this.common.options.databaseHeartbeatInterval,\n            )}`,\n            error,\n          });\n        }\n      }, this.common.options.databaseHeartbeatInterval);\n\n      return { checkpoint: finalizedCheckpoint, namespaceInfo };\n    });\n  }\n\n  async revert({\n    checkpoint,\n    namespaceInfo,\n  }: {\n    checkpoint: Checkpoint;\n    namespaceInfo: NamespaceInfo;\n  }) {\n    await revertIndexingTables({\n      db: this.indexingDb,\n      checkpoint,\n      namespaceInfo,\n    });\n  }\n\n  async updateFinalizedCheckpoint({\n    checkpoint,\n  }: { checkpoint: Checkpoint }): Promise<void> {\n    await this.db.wrap({ method: \"updateFinalizedCheckpoint\" }, async () => {\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ finalized_checkpoint: encodeCheckpoint(checkpoint) })\n        .execute();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Updated finalized checkpoint to (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} block=${checkpoint.blockNumber})`,\n      });\n    });\n  }\n\n  async createIndexes({ schema }: { schema: Schema }) {\n    await Promise.all(\n      Object.entries(getTables(schema)).flatMap(([tableName, table]) => {\n        if (table.constraints === undefined) return [];\n\n        return Object.entries(table.constraints).map(async ([name, index]) => {\n          await this.db.wrap({ method: \"createIndexes\" }, async () => {\n            const indexName = `${tableName}_${name}`;\n\n            const indexColumn = index[\" column\"];\n            const order = index[\" order\"];\n\n            const columns = Array.isArray(indexColumn)\n              ? indexColumn.map((ic) => `\"${ic}\"`).join(\", \")\n              : `\"${indexColumn}\" ${\n                  order === \"asc\" ? \"ASC\" : order === \"desc\" ? \"DESC\" : \"\"\n                }`;\n\n            await this.db.executeQuery(\n              sql`CREATE INDEX ${sql.ref(this.userNamespace)}.${sql.ref(\n                indexName,\n              )} ON ${sql.table(tableName)} (${sql.raw(columns)})`.compile(\n                this.db,\n              ),\n            );\n          });\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created index '${tableName}_${name}' on columns (${\n              Array.isArray(index[\" column\"])\n                ? index[\" column\"].join(\", \")\n                : index[\" column\"]\n            }) in '${this.userNamespace}.db'`,\n          });\n        });\n      }),\n    );\n  }\n\n  async kill() {\n    await this.db.wrap({ method: \"kill\" }, async () => {\n      clearInterval(this.heartbeatInterval);\n\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ is_locked: 0 })\n        .returningAll()\n        .executeTakeFirst();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Released lock on namespace '${this.userNamespace}'`,\n      });\n\n      await this.readonlyDb.destroy();\n      await this.indexingDb.destroy();\n      await this.syncDb.destroy();\n      await this.db.destroy();\n\n      this.syncDatabase.close();\n      this.internalDatabase.close();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: \"Closed connection to database\",\n      });\n    });\n  }\n\n  async migrateSyncStore() {\n    await this.db.wrap({ method: \"migrateSyncStore\" }, async () => {\n      const migrator = new Migrator({\n        db: this.syncDb as Kysely<any>,\n        provider: syncMigrationProvider,\n      });\n\n      const { error } = await migrator.migrateToLatest();\n      if (error) throw error;\n    });\n  }\n\n  private buildColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    schema: Schema,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          if (isListColumn(column) === false) {\n            col = col.check(\n              sql`${sql.ref(columnName)} in (${sql.join(\n                getEnums(schema)[column[\" enum\"]].map((v) => sql.lit(v)),\n              )})`,\n            );\n          }\n          return col;\n        });\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (isOptionalColumn(column) === false) col = col.notNull();\n            if (columnName === \"id\") col = col.primaryKey();\n            return col;\n          },\n        );\n      }\n    });\n\n    return builder;\n  }\n\n  private buildOperationLogColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        // Omit the CHECK constraint because its included in the user table\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\");\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (columnName === \"id\") col = col.notNull();\n            return col;\n          },\n        );\n      }\n    });\n\n    builder = builder\n      .addColumn(\"operation_id\", \"integer\", (col) => col.notNull().primaryKey())\n      .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n      .addColumn(\"operation\", \"integer\", (col) => col.notNull());\n\n    return builder;\n  }\n\n  private registerMetrics() {\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_sqlite_query_total\",\n    );\n    this.common.metrics.ponder_sqlite_query_total = new prometheus.Counter({\n      name: \"ponder_sqlite_query_total\",\n      help: \"Number of queries submitted to the database\",\n      labelNames: [\"database\"] as const,\n      registers: [this.common.metrics.registry],\n    });\n  }\n\n  private async deleteV3DatabaseFiles() {\n    // Detect if the `.ponder/sqlite` directly contains 0.3 database files.\n    const hasV3Files = existsSync(path.join(this.directory, \"ponder_cache.db\"));\n\n    if (!hasV3Files) return;\n\n    this.common.logger.debug({\n      service: \"database\",\n      msg: \"Migrating '.ponder/sqlite' database from 0.3.x to 0.4.x\",\n    });\n\n    // Drop 'ponder_cache' database files.\n    rmSync(path.join(this.directory, \"ponder_cache.db\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder_cache.db-shm\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder_cache.db-wal\"), { force: true });\n    this.common.logger.debug({\n      service: \"database\",\n      msg: `Removed '.ponder/sqlite/ponder_cache.db' file`,\n    });\n\n    // Drop 'ponder' database files (they will be created again).\n    rmSync(path.join(this.directory, \"ponder.db\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder.db-shm\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder.db-wal\"), { force: true });\n    this.common.logger.debug({\n      service: \"database\",\n      msg: `Removed '.ponder/sqlite/ponder.db' file`,\n    });\n  }\n}\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"real\",\n  string: \"text\",\n  bigint: \"varchar(79)\",\n  hex: \"blob\",\n} as const;\n","import type { Kysely, Migration, MigrationProvider } from \"kysely\";\nimport { sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", \"blob\") // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses SQLite's ROWID() function (simple autoincrement).\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"varchar(79)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"varchar(79)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"varchar(79)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"varchar(79)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"v\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      // SQLite doesn't support dropping NOT NULL constraints. As a workaround:\n      // 1) Create a new column of the same type without NOT NULL.\n      // 2) Copy data from the old column to the new column.\n      // 3) Drop the old column.\n      // 4) Rename the new column to the old column's name.\n\n      // Drop NOT NULL constraint from \"blocks.mixHash\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"mixHash_temp_null\", \"varchar(66)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          mixHash_temp_null: eb.selectFrom(\"blocks\").select(\"mixHash\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"mixHash\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"mixHash_temp_null\", \"mixHash\")\n        .execute();\n\n      // Drop NOT NULL constraint from \"blocks.nonce\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"nonce_temp_null\", \"varchar(18)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          nonce_temp_null: eb.selectFrom(\"blocks\").select(\"nonce\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"nonce\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"nonce_temp_null\", \"nonce\")\n        .execute();\n    },\n  },\n  \"2024_03_00_0_log_transaction_hash_index\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_transaction_hash_index\")\n        .on(\"logs\")\n        .column(\"transactionHash\")\n        .execute();\n    },\n  },\n  \"2024_03_13_0_nullable_block_columns_sha3uncles\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"sha3Uncles\",\n        columnType: \"varchar(66)\",\n      });\n    },\n  },\n  \"2024_03_14_0_nullable_transaction_rsv\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"r\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"s\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"v\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_03_20_0_checkpoint_in_logs_table\": {\n    async up(_db: Kysely<any>) {\n      // no-op migration to avoid crashing databases that successfully ran this migration\n      return;\n    },\n  },\n  \"2024_04_04_0_log_events_indexes\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropIndex(\"blockNumberIndex\").ifExists().execute();\n      await db.schema.dropIndex(\"blockTimestampIndex\").ifExists().execute();\n\n      await db.schema\n        .createIndex(\"logBlockNumberIndex\")\n        .on(\"logs\")\n        .column(\"blockNumber\")\n        .execute();\n    },\n  },\n  \"2024_04_14_0_nullable_block_total_difficulty\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"totalDifficulty\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_04_14_1_add_checkpoint_column_to_logs_table\": {\n    async up(db: Kysely<any>) {\n      if (await hasCheckpointCol(db)) {\n        return;\n      }\n      await db.schema\n        .alterTable(\"logs\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n    },\n  },\n  \"2024_04_14_2_set_checkpoint_in_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(\n        sql`\n        CREATE TEMPORARY TABLE cp_vals AS\n        SELECT \n          logs.id,\n          substr(blocks.timestamp, -10, 10) ||\n            substr('0000000000000000' || blocks.chainId, -16, 16) ||\n            substr(blocks.number, -16, 16) ||\n            substr('0000000000000000' || logs.transactionIndex, -16, 16) ||\n            '5' ||\n            substr('0000000000000000' || logs.logIndex, -16, 16) as checkpoint\n          FROM logs\n          JOIN blocks ON logs.\"blockHash\" = blocks.hash\n      `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n        UPDATE logs \n        SET checkpoint=cp_vals.checkpoint\n        FROM cp_vals\n        WHERE logs.id = cp_vals.id\n      `.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_3_index_on_logs_checkpoint\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"logs_checkpoint_index\")\n        .ifNotExists()\n        .on(\"logs\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_04_22_0_transaction_receipts\": {\n    async up(db: Kysely<any>) {\n      // Disable foriegn keys for the duration of this transaction.\n      await db.executeQuery(sql`PRAGMA foreign_keys = 0`.compile(db));\n\n      // Rename and update the existing tables to include the data we want. Note that\n      // these tables have constraints that we do NOT want. They won't get copied over.\n      await db.schema\n        .alterTable(\"logFilters\")\n        .renameTo(\"logFilters_temp\")\n        .execute();\n      await db\n        .updateTable(\"logFilters_temp\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"logFilters_temp\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"logFilterIntervals\")\n        .renameTo(\"logFilterIntervals_temp\")\n        .execute();\n      await db\n        .updateTable(\"logFilterIntervals_temp\")\n        .set({ logFilterId: sql`\"logFilterId\" || '_0'` })\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilters\")\n        // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}_${includeTransactionReceipts}`\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull(),\n        )\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        // Note that we removed the foreign key constraint here.\n        .addColumn(\"logFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      // Copy data from temp tables to new tables.\n      await db.executeQuery(\n        sql`INSERT INTO \"logFilters\" SELECT * FROM \"logFilters_temp\"`.compile(\n          db,\n        ),\n      );\n      await db.executeQuery(\n        sql`INSERT INTO \"logFilterIntervals\" SELECT * FROM \"logFilterIntervals_temp\"`.compile(\n          db,\n        ),\n      );\n      // Drop the temp tables.\n      await db.schema.dropTable(\"logFilters_temp\").execute();\n      await db.schema.dropTable(\"logFilterIntervals_temp\").execute();\n      // Add back the index.\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      // Repeat the same process for factories.\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factories_temp\")\n        .execute();\n      await db\n        .updateTable(\"factories_temp\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"factories_temp\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"factoryLogFilterIntervals\")\n        .renameTo(\"factoryLogFilterIntervals_temp\")\n        .execute();\n      await db\n        .updateTable(\"factoryLogFilterIntervals_temp\")\n        .set({ factoryId: sql`\"factoryId\" || '_0'` })\n        .execute();\n      await db.schema\n        .createTable(\"factories\")\n        // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${topic0}_${topic1}_${topic2}_${topic3}_${includeTransactionReceipts}`\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull(),\n        )\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        // Note that we removed the foreign key constraint here.\n        .addColumn(\"factoryId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.executeQuery(\n        sql`INSERT INTO \"factories\" SELECT * FROM \"factories_temp\"`.compile(db),\n      );\n      await db.executeQuery(\n        sql`INSERT INTO \"factoryLogFilterIntervals\" SELECT * FROM \"factoryLogFilterIntervals_temp\"`.compile(\n          db,\n        ),\n      );\n      await db.schema.dropTable(\"factories_temp\").execute();\n      await db.schema.dropTable(\"factoryLogFilterIntervals_temp\").execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"transactionReceipts\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"contractAddress\", \"varchar(66)\")\n        .addColumn(\"cumulativeGasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"effectiveGasPrice\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"logs\", \"text\", (col) => col.notNull())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"status\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) =>\n          col.notNull().primaryKey(),\n        )\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.executeQuery(sql`PRAGMA foreign_keys = 1`.compile(db));\n    },\n  },\n  \"2024_04_23_0_block_filters\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blockFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${interval}_${offset}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"interval\", \"integer\", (col) => col.notNull())\n        .addColumn(\"offset\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createTable(\"blockFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"blockFilterId\", \"text\", (col) =>\n          col.notNull().references(\"blockFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockFilterIntervalsBlockFilterId\")\n        .on(\"blockFilterIntervals\")\n        .column(\"blockFilterId\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n      await db.executeQuery(\n        sql`\n          CREATE TEMPORARY TABLE bcp_vals AS\n          SELECT \n            blocks.hash,\n            substr(blocks.timestamp, -10, 10) ||\n              substr('0000000000000000' || blocks.chainId, -16, 16) ||\n              substr(blocks.number, -16, 16) ||\n              '9999999999999999' ||\n              '5' ||\n              '0000000000000000' as checkpoint\n            FROM blocks\n        `.compile(db),\n      );\n      await db.executeQuery(\n        sql`\n          UPDATE blocks \n          SET checkpoint=bcp_vals.checkpoint\n          FROM bcp_vals\n          WHERE blocks.hash = bcp_vals.hash\n        `.compile(db),\n      );\n\n      await db.schema.alterTable(\"blocks\").renameTo(\"blocks_temp\").execute();\n\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"varchar(79)\")\n        .addColumn(\"difficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      await db.executeQuery(\n        sql`INSERT INTO \"blocks\" SELECT * FROM \"blocks_temp\"`.compile(db),\n      );\n\n      await db.schema.dropTable(\"blocks_temp\").execute();\n\n      // The blocks.number index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n      // The blocks.chainId index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockChainIdIndex\")\n        .on(\"blocks\")\n        .column(\"chainId\")\n        .execute();\n      // The blocks.number index supports getEvents\n      await db.schema\n        .createIndex(\"blockCheckpointIndex\")\n        .on(\"blocks\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_05_06_0_drop_not_null_block_columns\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"baseFeePerGas\",\n        columnType: \"varchar(79)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"mixHash\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"nonce\",\n        columnType: \"varchar(18)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"sha3Uncles\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"totalDifficulty\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_05_07_0_trace_filters\": {\n    async up(db: Kysely<any>) {\n      // TODO(kyle) drop foreign key constraint on \"blockFilterIntervals.blockFilterId\".\n\n      await db.schema\n        .createTable(\"traceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${fromAddress}_${toAddress}_${includeTransactionReceipts}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .addColumn(\"toAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"traceFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"traceFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"traceFilterIntervalsTraceFilterId\")\n        .on(\"traceFilterIntervals\")\n        .column(\"traceFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"callTraces\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"callType\", \"text\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"value\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"error\", \"text\")\n        .addColumn(\"gasUsed\", \"varchar(79)\")\n        .addColumn(\"output\", \"text\")\n        .addColumn(\"subtraces\", \"integer\", (col) => col.notNull())\n        .addColumn(\"traceAddress\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionPosition\", \"integer\", (col) => col.notNull())\n        .addColumn(\"functionSelector\", \"varchar(10)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      // The callTraces.blockNumber index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"callTracesBlockNumberIndex\")\n        .on(\"callTraces\")\n        .column(\"blockNumber\")\n        .execute();\n\n      // The callTraces.functionSelector index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFunctionSelectorIndex\")\n        .on(\"callTraces\")\n        .column(\"functionSelector\")\n        .execute();\n\n      // The callTraces.error index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesErrorIndex\")\n        .on(\"callTraces\")\n        .column(\"error\")\n        .execute();\n\n      // The callTraces.blockHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesBlockHashIndex\")\n        .on(\"callTraces\")\n        .column(\"blockHash\")\n        .execute();\n\n      // The callTraces.transactionHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesTransactionHashIndex\")\n        .on(\"callTraces\")\n        .column(\"transactionHash\")\n        .execute();\n\n      // The callTraces.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesCheckpointIndex\")\n        .on(\"callTraces\")\n        .column(\"checkpoint\")\n        .execute();\n\n      // The callTraces.chainId index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesChainIdIndex\")\n        .on(\"callTraces\")\n        .column(\"chainId\")\n        .execute();\n\n      // The callTraces.from index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFromIndex\")\n        .on(\"callTraces\")\n        .column(\"from\")\n        .execute();\n\n      // The callTraces.to index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesToIndex\")\n        .on(\"callTraces\")\n        .column(\"to\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factoryLogFilters\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factoryTraceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryTraceFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\")\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryTraceFilterIntervalsFactoryId\")\n        .on(\"factoryTraceFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n};\n\nasync function hasCheckpointCol(db: Kysely<any>) {\n  const res = await db.executeQuery(sql`PRAGMA table_info(\"logs\")`.compile(db));\n  return res.rows.some((x: any) => x.name === \"checkpoint\");\n}\n\nconst columnDropNotNull = async ({\n  db,\n  table,\n  column,\n  columnType,\n}: {\n  db: Kysely<any>;\n  table: string;\n  column: string;\n  columnType: Parameters<\n    ReturnType<Kysely<any>[\"schema\"][\"alterTable\"]>[\"addColumn\"]\n  >[1];\n}) => {\n  const tempName = `${column}_temp_null`;\n\n  await db.schema.alterTable(table).addColumn(tempName, columnType).execute();\n  await db\n    .updateTable(table)\n    .set((eb: any) => ({ [tempName]: eb.selectFrom(table).select(column) }))\n    .execute();\n  await db.schema.alterTable(table).dropColumn(column).execute();\n  await db.schema.alterTable(table).renameColumn(tempName, column).execute();\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import BetterSqlite3 from \"better-sqlite3\";\n\nimport { ensureDirExists } from \"./exists.js\";\nimport { prettyPrint } from \"./print.js\";\n\nfunction improveSqliteErrors(database: BetterSqlite3.Database) {\n  const originalPrepare = database.prepare;\n  // @ts-ignore\n  database.prepare = (source: string) => {\n    let statement: any;\n    try {\n      statement = originalPrepare.apply(database, [source]);\n    } catch (error_) {\n      // This block is reachable if the database is closed, and possibly in other cases.\n      const error = error_ as Error & { detail?: string; meta?: string };\n      error.name = \"SqliteError\";\n      Error.captureStackTrace(error);\n\n      const metaMessages = [];\n      if (error.detail) metaMessages.push(`Detail:\\n  ${error.detail}`);\n      metaMessages.push(`Statement:\\n  ${source}`);\n      error.meta = metaMessages.join(\"\\n\");\n\n      throw error;\n    }\n\n    const wrapper =\n      (fn: (...args: any) => void) =>\n      (...args: any) => {\n        try {\n          return fn.apply(statement, args);\n        } catch (error_) {\n          const error = error_ as Error & { detail?: string; meta?: string };\n          error.name = \"SqliteError\";\n\n          let parameters = (args[0] ?? []) as string[];\n          parameters =\n            parameters.length <= 25\n              ? parameters\n              : parameters.slice(0, 26).concat([\"...\"]);\n          const params = parameters.reduce<Record<number, any>>(\n            (acc, parameter, idx) => {\n              acc[idx + 1] = parameter;\n              return acc;\n            },\n            {},\n          );\n\n          const metaMessages = [];\n          if (error.detail) metaMessages.push(`Detail:\\n  ${error.detail}`);\n          metaMessages.push(`Statement:\\n  ${source}`);\n          metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n          error.meta = metaMessages.join(\"\\n\");\n\n          throw error;\n        }\n      };\n\n    for (const method of [\"run\", \"get\", \"all\"]) {\n      // @ts-ignore\n      statement[method] = wrapper(statement[method]);\n    }\n\n    return statement;\n  };\n}\n\nexport type SqliteDatabase = BetterSqlite3.Database;\n\nexport function createSqliteDatabase(\n  file: string,\n  options?: BetterSqlite3.Options,\n): SqliteDatabase {\n  ensureDirExists(file);\n  const database = new BetterSqlite3(file, options);\n  improveSqliteErrors(database);\n  database.pragma(\"journal_mode = WAL\");\n  return database;\n}\n","import { existsSync, mkdirSync } from \"node:fs\";\nimport path from \"node:path\";\n\nexport const ensureDirExists = (filePath: string) => {\n  const dirname = path.dirname(filePath);\n  if (existsSync(dirname)) {\n    return;\n  }\n  mkdirSync(dirname, { recursive: true });\n};\n","import { type Kysely } from \"kysely\";\nimport { type Migration, type MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2024_03_28_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"namespace_lock\")\n        .ifNotExists()\n        .addColumn(\"namespace\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"is_locked\", \"integer\", (col) => col.notNull())\n        .addColumn(\"heartbeat_at\", \"integer\", (col) => col.notNull())\n        .addColumn(\"build_id\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized_checkpoint\", \"varchar(75)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"schema\", \"jsonb\", (col) => col.notNull())\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport type InternalTables = {\n  namespace_lock: {\n    namespace: string;\n    is_locked: number;\n    heartbeat_at: number;\n    build_id: string;\n    finalized_checkpoint: string;\n    schema: string;\n  };\n};\n","import { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { Schema, Table } from \"@/schema/common.js\";\nimport type {\n  DatabaseColumn,\n  DatabaseRecord,\n  UserId,\n  UserRecord,\n} from \"@/types/schema.js\";\nimport { sql } from \"kysely\";\nimport type { WhereInput, WriteStore } from \"./store.js\";\nimport { decodeRow, encodeRow, encodeValue } from \"./utils/encoding.js\";\nimport { parseStoreError } from \"./utils/errors.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\n\nconst MAX_BATCH_SIZE = 1_000 as const;\n\nexport const getHistoricalStore = ({\n  kind,\n  schema,\n  namespaceInfo,\n  db,\n}: {\n  kind: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n}): WriteStore<\"historical\"> => ({\n  create: async ({\n    tableName,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    id: UserId;\n    data?: Omit<UserRecord, \"id\">;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.create` }, async () => {\n      const createRow = encodeRow({ id, ...data }, table, kind);\n\n      const row = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .insertInto(tableName)\n        .values(createRow)\n        .returningAll()\n        .executeTakeFirstOrThrow()\n        .catch((err) => {\n          throw parseStoreError(err, { id, ...data });\n        });\n\n      return decodeRow(row, table, kind);\n    });\n  },\n  createMany: async ({\n    tableName,\n    data,\n  }: {\n    tableName: string;\n    data: UserRecord[];\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    const rows: DatabaseRecord[] = [];\n\n    for (let i = 0, len = data.length; i < len; i += MAX_BATCH_SIZE) {\n      await db.wrap({ method: `${tableName}.createMany` }, async () => {\n        const createRows = data\n          .slice(i, i + MAX_BATCH_SIZE)\n          .map((d) => encodeRow(d, table, kind));\n\n        const _rows = await db\n          .withSchema(namespaceInfo.userNamespace)\n          .insertInto(tableName)\n          .values(createRows)\n          .returningAll()\n          .execute()\n          .catch((err) => {\n            throw parseStoreError(err, data.length > 0 ? data[0] : {});\n          });\n\n        rows.push(..._rows);\n      });\n    }\n\n    return rows.map((row) => decodeRow(row, table, kind));\n  },\n  update: async ({\n    tableName,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    id: UserId;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.update` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n\n      let updateObject: Partial<Omit<UserRecord, \"id\">>;\n      if (typeof data === \"function\") {\n        const latestRow = await db\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, data: \"(function)\" });\n          });\n\n        updateObject = data({ current: decodeRow(latestRow, table, kind) });\n      } else {\n        updateObject = data;\n      }\n      const updateRow = encodeRow({ id, ...updateObject }, table, kind);\n\n      const row = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .updateTable(tableName)\n        .set(updateRow)\n        .where(\"id\", \"=\", encodedId)\n        .returningAll()\n        .executeTakeFirstOrThrow()\n        .catch((err) => {\n          throw parseStoreError(err, { id, ...updateObject });\n        });\n\n      return decodeRow(row, table, kind);\n    });\n  },\n  updateMany: async ({\n    tableName,\n    where,\n    data = {},\n  }: {\n    tableName: string;\n    where: WhereInput<any>;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    if (typeof data === \"function\") {\n      const query = db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(tableName)\n        .selectAll()\n        .where((eb) =>\n          buildWhereConditions({\n            eb,\n            where,\n            table,\n            encoding: kind,\n          }),\n        )\n        .orderBy(\"id\", \"asc\");\n\n      const rows: UserRecord[] = [];\n      let cursor: DatabaseColumn = null;\n\n      while (true) {\n        const _rows = await db.wrap(\n          { method: `${tableName}.updateMany` },\n          async () => {\n            const latestRows: DatabaseRecord[] = await query\n              .limit(MAX_BATCH_SIZE)\n              .$if(cursor !== null, (qb) => qb.where(\"id\", \">\", cursor))\n              .execute();\n\n            const rows: DatabaseRecord[] = [];\n\n            for (const latestRow of latestRows) {\n              const current = decodeRow(latestRow, table, kind);\n              const updateObject = data({ current });\n              // Here, `latestRow` is already encoded, so we need to exclude it from `encodeRow`.\n              const updateRow = {\n                id: latestRow.id,\n                ...encodeRow(updateObject, table, kind),\n              };\n\n              const row = await db\n                .withSchema(namespaceInfo.userNamespace)\n                .updateTable(tableName)\n                .set(updateRow)\n                .where(\"id\", \"=\", latestRow.id)\n                .returningAll()\n                .executeTakeFirstOrThrow()\n                .catch((err) => {\n                  throw parseStoreError(err, updateObject);\n                });\n              rows.push(row);\n            }\n\n            return rows.map((row) => decodeRow(row, table, kind));\n          },\n        );\n\n        rows.push(..._rows);\n\n        if (_rows.length === 0) {\n          break;\n        } else {\n          cursor = encodeValue(_rows[_rows.length - 1].id, table.id, kind);\n        }\n      }\n\n      return rows;\n    } else {\n      return db.wrap({ method: `${tableName}.updateMany` }, async () => {\n        const updateRow = encodeRow(data, table, kind);\n\n        const rows = await db\n          .with(\"latestRows(id)\", (db) =>\n            db\n              .withSchema(namespaceInfo.userNamespace)\n              .selectFrom(tableName)\n              .select(\"id\")\n              .where((eb) =>\n                buildWhereConditions({\n                  eb,\n                  where,\n                  table,\n                  encoding: kind,\n                }),\n              ),\n          )\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRow)\n          .from(\"latestRows\")\n          .where(`${tableName}.id`, \"=\", sql.ref(\"latestRows.id\"))\n          .returningAll()\n          .execute()\n          .catch((err) => {\n            throw parseStoreError(err, data);\n          });\n\n        return rows.map((row) => decodeRow(row, table, kind));\n      });\n    }\n  },\n  upsert: async ({\n    tableName,\n    id,\n    create = {},\n    update = {},\n  }: {\n    tableName: string;\n    id: UserId;\n    create?: Omit<UserRecord, \"id\">;\n    update?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.upsert` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n      const createRow = encodeRow({ id, ...create }, table, kind);\n\n      if (typeof update === \"function\") {\n        const latestRow = await db\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirst();\n\n        if (latestRow === undefined) {\n          const row = await db\n            .withSchema(namespaceInfo.userNamespace)\n            .insertInto(tableName)\n            .values(createRow)\n            .returningAll()\n            .executeTakeFirstOrThrow()\n            .catch((err) => {\n              const prettyObject: any = { id };\n              for (const [key, value] of Object.entries(create))\n                prettyObject[`create.${key}`] = value;\n              prettyObject.update = \"(function)\";\n              throw parseStoreError(err, prettyObject);\n            });\n\n          return decodeRow(row, table, kind);\n        }\n\n        const current = decodeRow(latestRow, table, kind);\n        const updateObject = update({ current });\n        const updateRow = encodeRow({ id, ...updateObject }, table, kind);\n\n        const row = await db\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRow)\n          .where(\"id\", \"=\", encodedId)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            const prettyObject: any = { id };\n            for (const [key, value] of Object.entries(create))\n              prettyObject[`create.${key}`] = value;\n            for (const [key, value] of Object.entries(updateObject))\n              prettyObject[`update.${key}`] = value;\n            throw parseStoreError(err, prettyObject);\n          });\n\n        return decodeRow(row, table, kind);\n      } else {\n        const updateRow = encodeRow({ id, ...update }, table, kind);\n\n        const row = await db\n          .withSchema(namespaceInfo.userNamespace)\n          .insertInto(tableName)\n          .values(createRow)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(updateRow))\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            const prettyObject: any = { id };\n            for (const [key, value] of Object.entries(create))\n              prettyObject[`create.${key}`] = value;\n            for (const [key, value] of Object.entries(update))\n              prettyObject[`update.${key}`] = value;\n            throw parseStoreError(err, prettyObject);\n          });\n\n        return decodeRow(row, table, kind);\n      }\n    });\n  },\n  delete: async ({\n    tableName,\n    id,\n  }: {\n    tableName: string;\n    id: UserId;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.delete` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n\n      const deletedRow = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .deleteFrom(tableName)\n        .where(\"id\", \"=\", encodedId)\n        .returning([\"id\"])\n        .executeTakeFirst()\n        .catch((err) => {\n          throw parseStoreError(err, { id });\n        });\n\n      return !!deletedRow;\n    });\n  },\n});\n","import type { Hex } from \"viem\";\n\nexport const EVM_MAX_UINT =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n\nexport const EVM_MIN_INT =\n  -57896044618658097711785492504343953926634992332820282019728792003956564819968n;\n\n/**\n * Converts a integer into a 33-byte Buffer (sign byte followed by 32-byte value).\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function encodeAsText(value: bigint | number | Hex) {\n  if (typeof value === \"string\" || typeof value === \"number\")\n    value = BigInt(value);\n\n  if (value > EVM_MAX_UINT)\n    throw new Error(`Value cannot be greater than EVM_MAX_UINT (${value})`);\n  if (value < EVM_MIN_INT)\n    throw new Error(`Value cannot be less than EVM_MIN_INT (${value})`);\n\n  const signChar = value >= 0n ? \"0\" : \"-\";\n\n  // If the value is negative, add the minimum integer to it.\n  if (value < 0n) value = value - EVM_MIN_INT;\n\n  const chars = value.toString(10);\n\n  // Pad the hex string with leading zeros and add the sign byte.\n  return signChar + chars.padStart(78, \"0\");\n}\n\n/**\n * Converts an encoded 33-byte Buffer (sign byte followed by 32-byte value) into a BigInt.\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function decodeToBigInt(text: string) {\n  if (typeof text === \"bigint\") return text;\n\n  const signChar = text.at(0);\n  let valueChars = text.substring(1).replace(/^0+/, \"\");\n  // If the value is 0, valueChars will be an empty string.\n  if (valueChars.length === 0) valueChars = \"0\";\n  let value = BigInt(valueChars);\n\n  // If the sign byte is negative, invert the value\n\n  if (signChar === \"-\") value = value + EVM_MIN_INT;\n\n  return value;\n}\n","import { BigIntSerializationError, StoreError } from \"@/common/errors.js\";\nimport type {\n  Column,\n  EnumColumn,\n  JSONColumn,\n  ReferenceColumn,\n  Scalar,\n  ScalarColumn,\n  Table,\n} from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOptionalColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type {\n  DatabaseColumn,\n  DatabaseRecord,\n  UserColumn,\n  UserRecord,\n} from \"@/types/schema.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport { bytesToHex, hexToBytes, isHex } from \"viem\";\n\nconst scalarToTsType = {\n  int: \"number\",\n  float: \"number\",\n  bigint: \"bigint\",\n  boolean: \"boolean\",\n  string: \"string\",\n  hex: \"`0x${string}`\",\n} as const satisfies { [key in Scalar]: string };\n\n/**\n * Convert a user-land row into a database-ready object.\n */\nexport function encodeRow(\n  data: Partial<UserRecord>,\n  table: Table,\n  encoding: \"sqlite\" | \"postgres\",\n): DatabaseRecord {\n  const instance: DatabaseRecord = {};\n\n  for (const [columnName, value] of Object.entries(data)) {\n    const column = table[columnName];\n    if (!column) {\n      throw new StoreError(\n        `Invalid record: Column does not exist. Got ${columnName}, expected one of [${Object.keys(\n          table,\n        )\n          .filter(\n            (column) =>\n              isScalarColumn(table[column]) ||\n              isReferenceColumn(table[column]) ||\n              isEnumColumn(table[column]) ||\n              isJSONColumn(table[column]),\n          )\n          .join(\", \")}]`,\n      );\n    }\n\n    instance[columnName] = encodeValue(value, column, encoding);\n  }\n\n  return instance;\n}\n\n/**\n * Convert a user-land value into a database-ready value.\n */\nexport function encodeValue(\n  value: UserColumn,\n  column: Column,\n  encoding: \"sqlite\" | \"postgres\",\n): DatabaseColumn {\n  if (isEnumColumn(column)) {\n    if (isOptionalColumn(column) && (value === undefined || value === null)) {\n      return null;\n    }\n\n    if (isListColumn(column)) {\n      if (!Array.isArray(value)) {\n        throw new StoreError(\n          `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type 'string[]'.`,\n        );\n      }\n\n      return JSON.stringify(value);\n    } else if (typeof value !== \"string\") {\n      throw new StoreError(\n        `Unable to encode ${value} as an enum. Got type '${typeof value}' but expected type 'string'.`,\n      );\n    }\n    return value;\n  } else if (isJSONColumn(column)) {\n    if (encoding === \"postgres\") return value as Object;\n\n    try {\n      return JSON.stringify(value);\n    } catch (_error) {\n      const error = new BigIntSerializationError((_error as TypeError).message);\n      error.meta.push(\n        \"Hint:\\n  The JSON column type does not support BigInt values.\\n  Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n      );\n      throw error;\n    }\n  } else if (isScalarColumn(column) || isReferenceColumn(column)) {\n    if (isOptionalColumn(column) && (value === undefined || value === null)) {\n      return null;\n    }\n\n    if (isListColumn(column)) {\n      // Note: We are not checking the types of the list elements.\n      if (!Array.isArray(value)) {\n        throw new StoreError(\n          `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type '${\n            scalarToTsType[column[\" scalar\"]]\n          }[]'.`,\n        );\n      }\n\n      if (column[\" scalar\"] === \"bigint\") {\n        return JSON.stringify(value.map(String));\n      } else if (column[\" scalar\"] === \"hex\") {\n        return JSON.stringify(value.map((v) => (v as string).toLowerCase()));\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n\n    if (column[\" scalar\"] === \"string\") {\n      if (typeof value !== \"string\") {\n        throw new StoreError(\n          `Unable to encode ${value} as a string. Got type '${typeof value}' but expected type 'string'.`,\n        );\n      }\n      return value;\n    } else if (column[\" scalar\"] === \"hex\") {\n      if (typeof value !== \"string\" || !isHex(value)) {\n        throw new StoreError(\n          `Unable to encode ${value} as a hex. Got type '${typeof value}' but expected type '\\`0x\\${string}\\`'.`,\n        );\n      }\n      return Buffer.from(hexToBytes(value));\n    } else if (column[\" scalar\"] === \"int\") {\n      if (typeof value !== \"number\") {\n        throw new StoreError(\n          `Unable to encode ${value} as an int. Got type '${typeof value}' but expected type 'number'.`,\n        );\n      }\n      return value;\n    } else if (column[\" scalar\"] === \"float\") {\n      if (typeof value !== \"number\") {\n        throw new StoreError(\n          `Unable to encode ${value} as a float. Got type '${typeof value}' but expected type 'number'.`,\n        );\n      }\n      return value;\n    } else if (column[\" scalar\"] === \"bigint\") {\n      if (typeof value !== \"bigint\") {\n        throw new StoreError(\n          `Unable to encode ${value} as a bigint. Got type '${typeof value}' but expected type 'bigint'.`,\n        );\n      }\n      return encoding === \"sqlite\" ? encodeAsText(value) : value;\n    } else if (column[\" scalar\"] === \"boolean\") {\n      if (typeof value !== \"boolean\") {\n        throw new StoreError(\n          `Unable to encode ${value} as a boolean. Got type '${typeof value}' but expected type 'boolean'.`,\n        );\n      }\n      return value ? 1 : 0;\n    }\n\n    // Note: it should be impossible to get to this line\n    throw new StoreError(\n      `Unable to encode ${value} as type ${column[\" scalar\"]}. Please report this issue (https://github.com/ponder-sh/ponder/issues/new)`,\n    );\n  }\n\n  // Column is either \"many\" or \"one\"\n  throw new StoreError(\n    `Unable to encode ${value} into a \"${\n      isManyColumn(column) ? \"many\" : \"one\"\n    }\" column. \"${\n      isManyColumn(column) ? \"many\" : \"one\"\n    }\" columns are virtual and therefore should not be given a value.`,\n  );\n}\n\nexport function decodeRow(\n  data: DatabaseRecord,\n  table: Table,\n  encoding: \"sqlite\" | \"postgres\",\n): UserRecord {\n  const instance = {} as UserRecord;\n\n  for (const [columnName, column] of Object.entries(table)) {\n    if (\n      isScalarColumn(column) ||\n      isReferenceColumn(column) ||\n      isEnumColumn(column) ||\n      isJSONColumn(column)\n    ) {\n      instance[columnName] = decodeValue(data[columnName], column, encoding);\n    }\n  }\n\n  return instance;\n}\n\nfunction decodeValue(\n  value: DatabaseColumn,\n  column: ScalarColumn | ReferenceColumn | EnumColumn | JSONColumn,\n  encoding: \"sqlite\" | \"postgres\",\n): UserColumn {\n  if (value === null) return null;\n  else if (isEnumColumn(column)) {\n    if (isListColumn(column)) {\n      return JSON.parse(value as string);\n    }\n    return value as UserColumn;\n  } else if (isJSONColumn(column)) {\n    return encoding === \"postgres\" ? value : JSON.parse(value as string);\n  } else if (isListColumn(column)) {\n    return column[\" scalar\"] === \"bigint\"\n      ? JSON.parse(value as string).map(BigInt)\n      : JSON.parse(value as string);\n  } else if (column[\" scalar\"] === \"boolean\") {\n    return value === 1 ? true : false;\n  } else if (column[\" scalar\"] === \"hex\") {\n    return bytesToHex(value as Buffer);\n  } else if (column[\" scalar\"] === \"bigint\" && encoding === \"sqlite\") {\n    return decodeToBigInt(value as string);\n  } else {\n    return value as UserColumn;\n  }\n}\n","import {\n  BigIntSerializationError,\n  CheckConstraintError,\n  NotNullConstraintError,\n  RecordNotFoundError,\n  UniqueConstraintError,\n  getBaseError,\n} from \"@/common/errors.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\n\nexport function parseStoreError(err: unknown, args: Record<string, unknown>) {\n  let error = getBaseError(err);\n\n  if (error.message?.includes(\"no result\")) {\n    error = new RecordNotFoundError(\n      \"No existing record was found with the specified ID\",\n    );\n  } else if (\n    error.message?.includes(\"UNIQUE constraint failed\") ||\n    error.message?.includes(\"violates unique constraint\")\n  ) {\n    error = new UniqueConstraintError(error.message);\n    error.meta.push(\n      \"Hints:\\n  Did you forget to await the promise returned by a store method?\\n  Did you mean to do an upsert?\",\n    );\n  } else if (\n    error.message?.includes(\"NOT NULL constraint failed\") ||\n    error.message?.includes(\"violates not-null constraint\")\n  ) {\n    error = new NotNullConstraintError(error.message);\n  } else if (\n    error.message?.includes(\"CHECK constraint failed\") ||\n    error.message?.includes(\"violates check constraint\")\n  ) {\n    error = new CheckConstraintError(error.message);\n  } else if (error.message?.includes(\"Do not know how to serialize a BigInt\")) {\n    error = new BigIntSerializationError(error.message);\n    error.meta.push(\n      \"Hint:\\n  The JSON column type does not support BigInt values.\\n  Use the replaceBigInts helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n    );\n  }\n\n  // Adds a newline in the error message\n  if (error.meta.length !== 0) {\n    error.meta.push(\"\");\n  }\n\n  error.meta.push(`Store method arguments:\\n${prettyPrint(args)}`);\n\n  return error;\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { ScalarColumn, Table } from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type {\n  ComparisonOperatorExpression,\n  ExpressionBuilder,\n  ExpressionWrapper,\n} from \"kysely\";\nimport { encodeValue } from \"./encoding.js\";\n\nconst filterValidityMap = {\n  boolean: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  string: {\n    singular: [\n      \"equals\",\n      \"not\",\n      \"in\",\n      \"notIn\",\n      \"contains\",\n      \"notContains\",\n      \"startsWith\",\n      \"notStartsWith\",\n      \"endsWith\",\n      \"notEndsWith\",\n    ],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  hex: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  int: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  bigint: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  float: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n};\n\nconst filterEncodingMap: {\n  [condition: string]: (\n    value: any,\n    encode: (v: any) => any,\n  ) => [comparator: ComparisonOperatorExpression, value: any];\n} = {\n  // Universal\n  equals: (value, encode) =>\n    value === null ? [\"is\", null] : [\"=\", encode(value)],\n  not: (value, encode) =>\n    value === null ? [\"is not\", null] : [\"!=\", encode(value)],\n  // Singular\n  in: (value, encode) => [\"in\", value.map(encode)],\n  notIn: (value, encode) => [\"not in\", value.map(encode)],\n  // Plural/list\n  has: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notHas: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  // Numeric\n  gt: (value, encode) => [\">\", encode(value)],\n  lt: (value, encode) => [\"<\", encode(value)],\n  gte: (value, encode) => [\">=\", encode(value)],\n  lte: (value, encode) => [\"<=\", encode(value)],\n  // String\n  contains: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notContains: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  startsWith: (value, encode) => [\"like\", `${encode(value)}%`],\n  notStartsWith: (value, encode) => [\"not like\", `${encode(value)}%`],\n  endsWith: (value, encode) => [\"like\", `%${encode(value)}`],\n  notEndsWith: (value, encode) => [\"not like\", `%${encode(value)}`],\n} as const;\n\nexport function buildWhereConditions({\n  eb,\n  where,\n  table,\n  encoding,\n}: {\n  eb: ExpressionBuilder<any, string>;\n  where: Record<string, any>;\n  table: Table;\n  encoding: \"sqlite\" | \"postgres\";\n}) {\n  const exprs: ExpressionWrapper<any, string, any>[] = [];\n\n  for (const [columnName, rhs] of Object.entries(where)) {\n    if (columnName === \"AND\" || columnName === \"OR\") {\n      if (!Array.isArray(rhs)) {\n        throw new StoreError(\n          `Invalid filter. Expected an array for logical operator '${columnName}', got '${rhs}'.`,\n        );\n      }\n\n      const nestedExprs = rhs.map((nestedWhere) =>\n        buildWhereConditions({ eb, where: nestedWhere, table, encoding }),\n      );\n\n      exprs.push(eb[columnName === \"AND\" ? \"and\" : \"or\"](nestedExprs));\n      continue;\n    }\n\n    const column = table[columnName];\n\n    if (!column) {\n      throw new StoreError(\n        `Invalid filter. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n          table,\n        )\n          .filter(\n            (columnName) =>\n              isScalarColumn(table[columnName]) ||\n              isReferenceColumn(table[columnName]) ||\n              isEnumColumn(table[columnName]) ||\n              isJSONColumn(table[columnName]),\n          )\n          .map((c) => `'${c}'`)\n          .join(\", \")}]`,\n      );\n    }\n\n    if (isOneColumn(column) || isManyColumn(column)) {\n      throw new StoreError(\n        `Invalid filter. Cannot filter on virtual column '${columnName}'.`,\n      );\n    }\n\n    if (isJSONColumn(column)) {\n      throw new StoreError(\n        `Invalid filter. Cannot filter on json column '${columnName}'.`,\n      );\n    }\n\n    // Handle the shortcut case for `equals`, e.g. { user: \"abc\" }.\n    const conditionsForColumn =\n      Array.isArray(rhs) || typeof rhs !== \"object\" ? { equals: rhs } : rhs;\n\n    for (const [condition, value] of Object.entries(conditionsForColumn)) {\n      const filterType = isEnumColumn(column) ? \"string\" : column[\" scalar\"];\n\n      const allowedConditions =\n        filterValidityMap[filterType]?.[\n          isListColumn(column) ? \"list\" : \"singular\"\n        ];\n      if (!allowedConditions.includes(condition)) {\n        throw new StoreError(\n          `Invalid filter condition for column '${columnName}'. Got '${condition}', expected one of [${allowedConditions\n            .map((c) => `'${c}'`)\n            .join(\", \")}]`,\n        );\n      }\n\n      const filterEncodingFn = filterEncodingMap[condition];\n\n      // Handle special case for list column types `has` and `notHas`.\n      // We need to use the singular encoding function for the arguments.\n      const encode = (v: any) => {\n        const isListCondition =\n          isListColumn(column) &&\n          (condition === \"has\" || condition === \"notHas\");\n\n        if (isListCondition) {\n          // Must encode the value the same way that it is encoded as a list in\n          // `encodeValue`.\n          if ((column as ScalarColumn)[\" scalar\"] === \"bigint\") {\n            return String(v as bigint);\n          } else if ((column as ScalarColumn)[\" scalar\"] === \"hex\") {\n            return (v as string).toLowerCase();\n          }\n          return v;\n        }\n        return encodeValue(v, column, encoding);\n      };\n\n      const [comparator, encodedValue] = filterEncodingFn(value, encode);\n      exprs.push(eb.eb(columnName, comparator, encodedValue));\n    }\n  }\n\n  return eb.and(exprs);\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { Schema, Table } from \"@/schema/common.js\";\nimport type { UserId } from \"@/types/schema.js\";\nimport { sql } from \"kysely\";\nimport type { OrderByInput, ReadonlyStore, WhereInput } from \"./store.js\";\nimport {\n  buildCursorConditions,\n  decodeCursor,\n  encodeCursor,\n} from \"./utils/cursor.js\";\nimport { decodeRow, encodeValue } from \"./utils/encoding.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\nimport {\n  buildOrderByConditions,\n  reverseOrderByConditions,\n} from \"./utils/sort.js\";\n\nconst DEFAULT_LIMIT = 50 as const;\nconst MAX_LIMIT = 1_000 as const;\n\nexport const getReadonlyStore = ({\n  kind,\n  schema,\n  namespaceInfo,\n  db,\n}: {\n  kind: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n}): ReadonlyStore => ({\n  findUnique: async ({\n    tableName,\n    id,\n  }: {\n    tableName: string;\n    id: UserId;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.findUnique` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n\n      const row = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", encodedId)\n        .executeTakeFirst();\n\n      if (row === undefined) return null;\n\n      return decodeRow(row, table, kind);\n    });\n  },\n  findMany: async ({\n    tableName,\n    where,\n    orderBy,\n    before = null,\n    after = null,\n    limit = DEFAULT_LIMIT,\n  }: {\n    tableName: string;\n    where?: WhereInput<any>;\n    orderBy?: OrderByInput<any>;\n    before?: string | null;\n    after?: string | null;\n    limit?: number;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.findMany` }, async () => {\n      let query = db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(tableName)\n        .selectAll();\n\n      if (where) {\n        query = query.where((eb) =>\n          buildWhereConditions({ eb, where, table, encoding: kind }),\n        );\n      }\n\n      const orderByConditions = buildOrderByConditions({ orderBy, table });\n      for (const [column, direction] of orderByConditions) {\n        query = query.orderBy(\n          column,\n          kind === \"sqlite\"\n            ? direction\n            : direction === \"asc\"\n              ? sql`asc nulls first`\n              : sql`desc nulls last`,\n        );\n      }\n      const orderDirection = orderByConditions[0][1];\n\n      if (limit > MAX_LIMIT) {\n        throw new StoreError(\n          `Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`,\n        );\n      }\n\n      if (after !== null && before !== null) {\n        throw new StoreError(\"Cannot specify both before and after cursors.\");\n      }\n\n      let startCursor = null;\n      let endCursor = null;\n      let hasPreviousPage = false;\n      let hasNextPage = false;\n\n      // Neither cursors are specified, apply the order conditions and execute.\n      if (after === null && before === null) {\n        query = query.limit(limit + 1);\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, kind));\n\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n\n      if (after !== null) {\n        // User specified an 'after' cursor.\n        const rawCursorValues = decodeCursor(after, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], kind),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"after\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, kind));\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: {\n              hasNextPage,\n              hasPreviousPage,\n              startCursor,\n              endCursor,\n            },\n          };\n        }\n\n        // If the cursor of the first returned record equals the `after` cursor,\n        // `hasPreviousPage` is true. Remove that record.\n        if (encodeCursor(records[0], orderByConditions) === after) {\n          records.shift();\n          hasPreviousPage = true;\n        } else {\n          // Otherwise, remove the last record.\n          records.pop();\n        }\n\n        // Now if the length of the records is still equal to limit + 1,\n        // there is a next page.\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      } else {\n        // User specified a 'before' cursor.\n        const rawCursorValues = decodeCursor(before!, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], kind),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"before\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        // Reverse the order by conditions to get the previous page.\n        query = query.clearOrderBy();\n        const reversedOrderByConditions =\n          reverseOrderByConditions(orderByConditions);\n        for (const [column, direction] of reversedOrderByConditions) {\n          query = query.orderBy(column, direction);\n        }\n\n        const rows = await query.execute();\n        const records = rows\n          .map((row) => decodeRow(row, table, kind))\n          // Reverse the records again, back to the original order.\n          .reverse();\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: {\n              hasNextPage,\n              hasPreviousPage,\n              startCursor,\n              endCursor,\n            },\n          };\n        }\n\n        // If the cursor of the last returned record equals the `before` cursor,\n        // `hasNextPage` is true. Remove that record.\n        if (\n          encodeCursor(records[records.length - 1], orderByConditions) ===\n          before\n        ) {\n          records.pop();\n          hasNextPage = true;\n        } else {\n          // Otherwise, remove the first record.\n          records.shift();\n        }\n\n        // Now if the length of the records is equal to limit + 1, we know\n        // there is a previous page.\n        if (records.length === limit + 1) {\n          records.shift();\n          hasPreviousPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n    });\n  },\n});\n","/**\n * Serialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to stringify\n * @returns the stringified output\n */\nexport function serialize(value: any) {\n  return JSON.stringify(value, (_, v) =>\n    typeof v === \"bigint\" ? { __type: \"bigint\", value: v.toString() } : v,\n  );\n}\n\n/**\n * Deserialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to parse\n * @returns the output object\n */\nexport function deserialize<type>(value: string): type {\n  return JSON.parse(value, (_, value_) =>\n    value_?.__type === \"bigint\" ? BigInt(value_.value) : value_,\n  );\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { UserRecord } from \"@/types/schema.js\";\nimport { deserialize, serialize } from \"@/utils/serialize.js\";\nimport type { ExpressionBuilder } from \"kysely\";\nimport type { OrderByConditions } from \"./sort.js\";\n\nexport function encodeCursor(\n  record: UserRecord,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = orderByConditions.map(([columnName]) => [\n    columnName,\n    record[columnName],\n  ]);\n\n  return Buffer.from(serialize(cursorValues)).toString(\"base64\");\n}\n\nexport function decodeCursor(\n  cursor: string,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = deserialize<[string, any][]>(\n    Buffer.from(cursor, \"base64\").toString(),\n  );\n\n  // Validate cursor values against order by conditions.\n  if (cursorValues.length !== orderByConditions.length) {\n    throw new StoreError(\n      `Invalid cursor. Got ${cursorValues.length}, ${orderByConditions.length} conditions`,\n    );\n  }\n\n  for (const [index, [columnName]] of orderByConditions.entries()) {\n    if (cursorValues[index][0] !== columnName) {\n      throw new StoreError(\n        `Invalid cursor. Got column '${cursorValues[index][0]}' at index ${index}, expected '${columnName}'.`,\n      );\n    }\n  }\n\n  return cursorValues;\n}\n\nexport function buildCursorConditions(\n  cursorValues: [string, any][],\n  kind: \"after\" | \"before\",\n  direction: \"asc\" | \"desc\",\n  eb: ExpressionBuilder<any, any>,\n) {\n  const comparator =\n    kind === \"after\"\n      ? direction === \"asc\"\n        ? \">\" // after, asc\n        : \"<\" // after, desc\n      : direction === \"asc\"\n        ? \"<\" // before, asc\n        : \">\"; // before, desc\n  const comparatorOrEquals = `${comparator}=` as const;\n\n  if (cursorValues.length === 1) {\n    const [columnName, value] = cursorValues[0];\n    return eb.eb(columnName, comparatorOrEquals, value);\n  } else if (cursorValues.length === 2) {\n    const [columnName1, value1] = cursorValues[0];\n    const [columnName2, value2] = cursorValues[1];\n\n    return eb.or([\n      eb.eb(columnName1, comparator, value1),\n      eb.and([\n        eb.eb(columnName1, \"=\", value1),\n        eb.eb(columnName2, comparatorOrEquals, value2),\n      ]),\n    ]);\n  } else {\n    throw new StoreError(\n      `Invalid cursor. Got ${cursorValues.length} value pairs, expected 1 or 2.`,\n    );\n  }\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { Table } from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type { OrderByInput } from \"../store.js\";\n\nexport type OrderByConditions = [\n  columnName: string,\n  direction: \"asc\" | \"desc\",\n][];\n\nexport function buildOrderByConditions({\n  orderBy,\n  table,\n}: {\n  orderBy: OrderByInput<any> | undefined;\n  table: Table;\n}): OrderByConditions {\n  if (!orderBy) {\n    return [[\"id\", \"asc\"]];\n  }\n\n  const conditions = Object.entries(orderBy);\n  if (conditions.length > 1)\n    throw new StoreError(\"Invalid sort. Cannot sort by multiple columns.\");\n\n  const [columnName, orderDirection] = conditions[0];\n\n  // Validate column name.\n  const column = table[columnName];\n  if (!column) {\n    throw new StoreError(\n      `Invalid sort. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n        table,\n      )\n        .filter(\n          (columnName) =>\n            isScalarColumn(table[columnName]) ||\n            isReferenceColumn(table[columnName]) ||\n            isEnumColumn(table[columnName]) ||\n            isJSONColumn(table[columnName]),\n        )\n        .map((c) => `'${c}'`)\n        .join(\", \")}]`,\n    );\n  }\n  if (isOneColumn(column) || isManyColumn(column)) {\n    throw new StoreError(\n      `Invalid sort. Cannot sort on virtual column '${columnName}'.`,\n    );\n  }\n\n  if (isJSONColumn(column)) {\n    throw new StoreError(\n      `Invalid sort. Cannot sort on json column '${columnName}'.`,\n    );\n  }\n\n  if (orderDirection === undefined || ![\"asc\", \"desc\"].includes(orderDirection))\n    throw new StoreError(\n      `Invalid sort direction. Got '${orderDirection}', expected 'asc' or 'desc'.`,\n    );\n\n  const orderByConditions: OrderByConditions = [[columnName, orderDirection]];\n\n  // If the specified order by column is not the ID column, add the ID column\n  // as a secondary using the same order to enforce a consistent sort.\n  if (columnName !== \"id\") {\n    orderByConditions.push([\"id\", orderDirection]);\n  }\n\n  return orderByConditions;\n}\n\nexport function reverseOrderByConditions(orderByConditions: OrderByConditions) {\n  return orderByConditions.map(([columnName, direction]) => [\n    columnName,\n    direction === \"asc\" ? \"desc\" : \"asc\",\n  ]) satisfies OrderByConditions;\n}\n","import type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { Schema, Table } from \"@/schema/common.js\";\nimport type {\n  DatabaseColumn,\n  DatabaseRecord,\n  UserId,\n  UserRecord,\n} from \"@/types/schema.js\";\nimport type { WhereInput, WriteStore } from \"./store.js\";\nimport { decodeRow, encodeRow, encodeValue } from \"./utils/encoding.js\";\nimport { parseStoreError } from \"./utils/errors.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\n\nconst MAX_BATCH_SIZE = 1_000 as const;\n\nexport const getRealtimeStore = ({\n  kind,\n  schema,\n  namespaceInfo,\n  db,\n}: {\n  kind: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n}): WriteStore<\"realtime\"> => ({\n  create: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    data?: Omit<UserRecord, \"id\">;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.create` }, async () => {\n      const createRow = encodeRow({ id, ...data }, table, kind);\n\n      return await db.transaction().execute(async (tx) => {\n        const row = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .insertInto(tableName)\n          .values(createRow)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, ...data });\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName])\n          .values({\n            operation: 0,\n            id: createRow.id,\n            checkpoint: encodedCheckpoint,\n          })\n          .execute();\n\n        return decodeRow(row, table, kind);\n      });\n    });\n  },\n  createMany: ({\n    tableName,\n    encodedCheckpoint,\n    data,\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    data: UserRecord[];\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.createMany` }, async () => {\n      const rows: DatabaseRecord[] = [];\n      await db.transaction().execute(async (tx) => {\n        for (let i = 0, len = data.length; i < len; i += MAX_BATCH_SIZE) {\n          const createRows = data\n            .slice(i, i + MAX_BATCH_SIZE)\n            .map((d) => encodeRow(d, table, kind));\n\n          const _rows = await tx\n            .withSchema(namespaceInfo.userNamespace)\n            .insertInto(tableName)\n            .values(createRows)\n            .returningAll()\n            .execute()\n            .catch((err) => {\n              throw parseStoreError(err, data.length > 0 ? data[0] : {});\n            });\n\n          rows.push(..._rows);\n\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName])\n            .values(\n              createRows.map((row) => ({\n                operation: 0,\n                id: row.id,\n                checkpoint: encodedCheckpoint,\n              })),\n            )\n            .execute();\n        }\n      });\n\n      return rows.map((row) => decodeRow(row, table, kind));\n    });\n  },\n  update: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.update` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n\n      const row = await db.transaction().execute(async (tx) => {\n        const latestRow = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, data: \"(function)\" });\n          });\n\n        const updateObject =\n          typeof data === \"function\"\n            ? data({ current: decodeRow(latestRow, table, kind) })\n            : data;\n        const updateRow = encodeRow({ id, ...updateObject }, table, kind);\n\n        const updateResult = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRow)\n          .where(\"id\", \"=\", encodedId)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, ...updateObject });\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName])\n          .values({\n            operation: 1,\n            checkpoint: encodedCheckpoint,\n            ...latestRow,\n          })\n          .execute();\n\n        return updateResult;\n      });\n\n      const result = decodeRow(row, table, kind);\n\n      return result;\n    });\n  },\n  updateMany: async ({\n    tableName,\n    encodedCheckpoint,\n    where,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    where: WhereInput<any>;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    const rows: UserRecord[] = [];\n    let cursor: DatabaseColumn = null;\n\n    while (true) {\n      const _rows = await db.wrap({ method: `${tableName}.updateMany` }, () =>\n        db.transaction().execute(async (tx) => {\n          const latestRows: DatabaseRecord[] = await tx\n            .withSchema(namespaceInfo.userNamespace)\n            .selectFrom(tableName)\n            .selectAll()\n            .where((eb) =>\n              buildWhereConditions({\n                eb,\n                where,\n                table,\n                encoding: kind,\n              }),\n            )\n            .orderBy(\"id\", \"asc\")\n            .limit(MAX_BATCH_SIZE)\n            .$if(cursor !== null, (qb) => qb.where(\"id\", \">\", cursor))\n            .execute();\n\n          const rows: DatabaseRecord[] = [];\n\n          for (const latestRow of latestRows) {\n            const updateObject =\n              typeof data === \"function\"\n                ? data({ current: decodeRow(latestRow, table, kind) })\n                : data;\n\n            // Here, `latestRow` is already encoded, so we need to exclude it from `encodeRow`.\n            const updateRow = {\n              id: latestRow.id,\n              ...encodeRow(updateObject, table, kind),\n            };\n\n            const row = await tx\n              .withSchema(namespaceInfo.userNamespace)\n              .updateTable(tableName)\n              .set(updateRow)\n              .where(\"id\", \"=\", latestRow.id)\n              .returningAll()\n              .executeTakeFirstOrThrow()\n              .catch((err) => {\n                throw parseStoreError(err, updateObject);\n              });\n\n            rows.push(row);\n\n            await tx\n              .withSchema(namespaceInfo.internalNamespace)\n              .insertInto(namespaceInfo.internalTableIds[tableName])\n              .values({\n                operation: 1,\n                checkpoint: encodedCheckpoint,\n                ...latestRow,\n              })\n              .execute();\n          }\n\n          return rows.map((row) => decodeRow(row, table, kind));\n        }),\n      );\n\n      rows.push(..._rows);\n\n      if (_rows.length === 0) {\n        break;\n      } else {\n        cursor = encodeValue(_rows[_rows.length - 1].id, table.id, kind);\n      }\n    }\n\n    return rows;\n  },\n  upsert: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    create = {},\n    update = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    create?: Omit<UserRecord, \"id\">;\n    update?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.upsert` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n      const createRow = encodeRow({ id, ...create }, table, kind);\n\n      const row = await db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRow = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirst();\n\n        // If there is no latest version, insert a new version using the create data.\n        if (latestRow === undefined) {\n          const row = await tx\n            .withSchema(namespaceInfo.userNamespace)\n            .insertInto(tableName)\n            .values(createRow)\n            .returningAll()\n            .executeTakeFirstOrThrow()\n            .catch((err) => {\n              const prettyObject: any = { id };\n              for (const [key, value] of Object.entries(create))\n                prettyObject[`create.${key}`] = value;\n              if (typeof update === \"function\") {\n                prettyObject.update = \"(function)\";\n              } else {\n                for (const [key, value] of Object.entries(update))\n                  prettyObject[`update.${key}`] = value;\n              }\n              throw parseStoreError(err, prettyObject);\n            });\n\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName])\n            .values({\n              operation: 0,\n              id: createRow.id,\n              checkpoint: encodedCheckpoint,\n            })\n            .execute();\n\n          return row;\n        }\n\n        const updateObject =\n          typeof update === \"function\"\n            ? update({ current: decodeRow(latestRow, table, kind) })\n            : update;\n        const updateRow = encodeRow({ id, ...updateObject }, table, kind);\n\n        const row = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRow)\n          .where(\"id\", \"=\", encodedId)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            const prettyObject: any = { id };\n            for (const [key, value] of Object.entries(create))\n              prettyObject[`create.${key}`] = value;\n            for (const [key, value] of Object.entries(updateObject))\n              prettyObject[`update.${key}`] = value;\n            throw parseStoreError(err, prettyObject);\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName])\n          .values({\n            operation: 1,\n            checkpoint: encodedCheckpoint,\n            ...latestRow,\n          })\n          .execute();\n\n        return row;\n      });\n\n      return decodeRow(row, table, kind);\n    });\n  },\n  delete: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.delete` }, async () => {\n      const encodedId = encodeValue(id, table.id, kind);\n\n      const isDeleted = await db.transaction().execute(async (tx) => {\n        const row = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirst();\n\n        const deletedRow = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .deleteFrom(tableName)\n          .where(\"id\", \"=\", encodedId)\n          .returning([\"id\"])\n          .executeTakeFirst()\n          .catch((err) => {\n            throw parseStoreError(err, { id });\n          });\n\n        if (row !== undefined) {\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName])\n            .values({\n              operation: 2,\n              checkpoint: encodedCheckpoint,\n              ...row,\n            })\n            .execute();\n        }\n\n        return !!deletedRow;\n      });\n\n      return isDeleted;\n    });\n  },\n});\n","export const never = (_x: never) => {\n  throw \"unreachable\";\n};\n","import type { IndexingFunctions } from \"@/build/configAndIndexingFunctions.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type EventSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { IndexingStore } from \"@/indexing-store/store.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport type { SyncService } from \"@/sync/index.js\";\nimport type { DatabaseModel } from \"@/types/model.js\";\nimport type { UserRecord } from \"@/types/schema.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport type { Abi, Address } from \"viem\";\nimport { checksumAddress, createClient } from \"viem\";\nimport type {\n  BlockEvent,\n  CallTraceEvent,\n  Event,\n  LogEvent,\n  SetupEvent,\n} from \"../sync/events.js\";\nimport {\n  type ReadOnlyClient,\n  buildCachedActions,\n  buildDb,\n} from \"./ponderActions.js\";\nimport { addUserStackTrace } from \"./trace.js\";\n\nexport type Context = {\n  network: { chainId: number; name: string };\n  client: ReadOnlyClient;\n  db: Record<string, DatabaseModel<UserRecord>>;\n  contracts: Record<\n    string,\n    {\n      abi: Abi;\n      address?: Address | readonly Address[];\n      startBlock: number;\n      endBlock?: number;\n      maxBlockRange?: number;\n    }\n  >;\n};\n\nexport type Service = {\n  // static\n  common: Common;\n  indexingFunctions: IndexingFunctions;\n  indexingStore: IndexingStore;\n\n  // state\n  isKilled: boolean;\n\n  eventCount: {\n    [eventName: string]: { [networkName: string]: number };\n  };\n  firstEventCheckpoint: Checkpoint | undefined;\n  lastEventCheckpoint: Checkpoint | undefined;\n\n  /**\n   * Reduce memory usage by reserving space for objects ahead of time\n   * instead of creating a new one for each event.\n   */\n  currentEvent: {\n    contextState: {\n      encodedCheckpoint: string;\n      blockNumber: bigint;\n    };\n    context: Context;\n  };\n\n  // static cache\n  networkByChainId: { [chainId: number]: Network };\n  clientByChainId: { [chainId: number]: Context[\"client\"] };\n  contractsByChainId: { [chainId: number]: Context[\"contracts\"] };\n};\n\nexport const create = ({\n  indexingFunctions,\n  common,\n  sources,\n  networks,\n  syncService,\n  indexingStore,\n  schema,\n}: {\n  indexingFunctions: IndexingFunctions;\n  common: Common;\n  sources: EventSource[];\n  networks: Network[];\n  syncService: SyncService;\n  indexingStore: IndexingStore;\n  schema: Schema;\n}): Service => {\n  const contextState: Service[\"currentEvent\"][\"contextState\"] = {\n    encodedCheckpoint: undefined!,\n    blockNumber: undefined!,\n  };\n  const clientByChainId: Service[\"clientByChainId\"] = {};\n  const contractsByChainId: Service[\"contractsByChainId\"] = {};\n\n  const networkByChainId = networks.reduce<Service[\"networkByChainId\"]>(\n    (acc, cur) => {\n      acc[cur.chainId] = cur;\n      return acc;\n    },\n    {},\n  );\n\n  // build contractsByChainId\n  for (const source of sources) {\n    if (source.type === \"block\") continue;\n\n    const address =\n      source.type === \"factoryCallTrace\" || source.type === \"factoryLog\"\n        ? undefined\n        : source.type === \"callTrace\"\n          ? source.criteria.toAddress!.length === 1\n            ? source.criteria.toAddress![0]\n            : undefined\n          : typeof source.criteria.address === \"string\"\n            ? source.criteria.address\n            : undefined;\n\n    if (contractsByChainId[source.chainId] === undefined) {\n      contractsByChainId[source.chainId] = {};\n    }\n\n    // Note: multiple sources with the same contract (logs and traces)\n    // should only create one entry in the `contracts` object\n    if (contractsByChainId[source.chainId][source.contractName] !== undefined)\n      continue;\n\n    contractsByChainId[source.chainId][source.contractName] = {\n      abi: source.abi,\n      address: address ? checksumAddress(address) : address,\n      startBlock: source.startBlock,\n      endBlock: source.endBlock,\n      maxBlockRange: source.maxBlockRange,\n    };\n  }\n\n  // build db\n  const db = buildDb({ common, schema, indexingStore, contextState });\n\n  // build cachedActions\n  const cachedActions = buildCachedActions(contextState);\n\n  // build clientByChainId\n  for (const network of networks) {\n    const transport = syncService.getCachedTransport(network);\n    clientByChainId[network.chainId] = createClient({\n      transport,\n      chain: network.chain,\n    }).extend(cachedActions);\n  }\n\n  // build eventCount\n  const eventCount: Service[\"eventCount\"] = {};\n  for (const eventName of Object.keys(indexingFunctions)) {\n    eventCount[eventName] = {};\n    for (const network of networks) {\n      eventCount[eventName][network.name] = 0;\n    }\n  }\n\n  return {\n    common,\n    indexingFunctions,\n    indexingStore,\n    isKilled: false,\n    eventCount,\n    firstEventCheckpoint: undefined,\n    lastEventCheckpoint: undefined,\n    currentEvent: {\n      contextState,\n      context: {\n        network: { name: undefined!, chainId: undefined! },\n        contracts: undefined!,\n        client: undefined!,\n        db,\n      },\n    },\n    networkByChainId,\n    clientByChainId,\n    contractsByChainId,\n  };\n};\n\nexport const updateIndexingStore = async (\n  indexingService: Service,\n  { indexingStore, schema }: { indexingStore: IndexingStore; schema: Schema },\n) => {\n  const db = buildDb({\n    common: indexingService.common,\n    schema,\n    indexingStore,\n    contextState: indexingService.currentEvent.contextState,\n  });\n\n  indexingService.currentEvent.context.db = db;\n};\n\nexport const processSetupEvents = async (\n  indexingService: Service,\n  {\n    sources,\n    networks,\n  }: {\n    sources: EventSource[];\n    networks: Network[];\n  },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  for (const eventName of Object.keys(indexingService.indexingFunctions)) {\n    if (!eventName.endsWith(\":setup\")) continue;\n\n    const [contractName] = eventName.split(\":\");\n\n    for (const network of networks) {\n      const source = sources.find(\n        (s) =>\n          (sourceIsLog(s) || sourceIsFactoryLog(s)) &&\n          s.contractName === contractName &&\n          s.chainId === network.chainId,\n      )! as LogSource | FactoryLogSource;\n\n      if (indexingService.isKilled) return { status: \"killed\" };\n      indexingService.eventCount[eventName][source.networkName]++;\n\n      const result = await executeSetup(indexingService, {\n        event: {\n          type: \"setup\",\n          chainId: network.chainId,\n          contractName: source.contractName,\n          startBlock: BigInt(source.startBlock),\n          encodedCheckpoint: encodeCheckpoint({\n            ...zeroCheckpoint,\n            chainId: BigInt(network.chainId),\n            blockNumber: BigInt(source.startBlock),\n          }),\n        },\n      });\n\n      if (result.status !== \"success\") {\n        return result;\n      }\n    }\n  }\n\n  return { status: \"success\" };\n};\n\nexport const processEvents = async (\n  indexingService: Service,\n  { events }: { events: Event[] },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  // set first event checkpoint\n  if (events.length > 0 && indexingService.firstEventCheckpoint === undefined) {\n    indexingService.firstEventCheckpoint = decodeCheckpoint(\n      events[0].encodedCheckpoint,\n    );\n\n    // set total seconds\n    if (indexingService.lastEventCheckpoint !== undefined) {\n      indexingService.common.metrics.ponder_indexing_total_seconds.set(\n        indexingService.lastEventCheckpoint.blockTimestamp -\n          indexingService.firstEventCheckpoint.blockTimestamp,\n      );\n    }\n  }\n\n  const eventCounts: { [eventName: string]: number } = {};\n\n  for (let i = 0; i < events.length; i++) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n\n    const event = events[i];\n\n    switch (event.type) {\n      case \"log\": {\n        const eventName = `${event.contractName}:${event.logEventName}`;\n\n        indexingService.eventCount[eventName][\n          indexingService.networkByChainId[event.chainId].name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeLog(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      case \"block\": {\n        const eventName = `${event.sourceName}:block`;\n\n        indexingService.eventCount[eventName][\n          indexingService.networkByChainId[event.chainId].name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeBlock(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      case \"callTrace\": {\n        const eventName = `${event.contractName}.${event.functionName}`;\n\n        indexingService.eventCount[eventName][\n          indexingService.networkByChainId[event.chainId].name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeCallTrace(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      default:\n        never(event);\n    }\n\n    // periodically update metrics\n    if (i % 93 === 0) {\n      updateCompletedEvents(indexingService);\n\n      const eventTimestamp = decodeCheckpoint(\n        event.encodedCheckpoint,\n      ).blockTimestamp;\n\n      indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n        eventTimestamp - indexingService.firstEventCheckpoint!.blockTimestamp,\n      );\n      indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n        eventTimestamp,\n      );\n\n      // Note(kyle) this is only needed for sqlite\n      await new Promise(setImmediate);\n    }\n  }\n\n  // set completed seconds\n  if (\n    events.length > 0 &&\n    indexingService.firstEventCheckpoint !== undefined &&\n    indexingService.lastEventCheckpoint !== undefined\n  ) {\n    const lastEventInBatchTimestamp = decodeCheckpoint(\n      events[events.length - 1].encodedCheckpoint,\n    ).blockTimestamp;\n\n    indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n      lastEventInBatchTimestamp -\n        indexingService.firstEventCheckpoint.blockTimestamp,\n    );\n    indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n      lastEventInBatchTimestamp,\n    );\n  }\n  // set completed events\n  updateCompletedEvents(indexingService);\n\n  for (const [eventName, count] of Object.entries(eventCounts)) {\n    if (count === 1) {\n      indexingService.common.logger.info({\n        service: \"indexing\",\n        msg: `Indexed 1 '${eventName}' event`,\n      });\n    } else {\n      indexingService.common.logger.info({\n        service: \"indexing\",\n        msg: `Indexed ${count} '${eventName}' events`,\n      });\n    }\n  }\n\n  return { status: \"success\" };\n};\n\nexport const kill = (indexingService: Service) => {\n  indexingService.common.logger.debug({\n    service: \"indexing\",\n    msg: \"Killed indexing service\",\n  });\n  indexingService.isKilled = true;\n};\n\nexport const updateLastEventCheckpoint = (\n  indexingService: Service,\n  lastEventCheckpoint: Checkpoint,\n) => {\n  indexingService.lastEventCheckpoint = lastEventCheckpoint;\n\n  if (indexingService.firstEventCheckpoint !== undefined) {\n    indexingService.common.metrics.ponder_indexing_total_seconds.set(\n      indexingService.lastEventCheckpoint.blockTimestamp -\n        indexingService.firstEventCheckpoint.blockTimestamp,\n    );\n  }\n};\n\nconst updateCompletedEvents = (indexingService: Service) => {\n  for (const event of Object.keys(indexingService.eventCount)) {\n    for (const network of Object.keys(indexingService.eventCount[event])) {\n      const metricLabel = {\n        event,\n        network,\n      };\n      indexingService.common.metrics.ponder_indexing_completed_events.set(\n        metricLabel,\n        indexingService.eventCount[event][network],\n      );\n    }\n  }\n};\n\nconst executeSetup = async (\n  indexingService: Service,\n  { event }: { event: SetupEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}:setup`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId].name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId].name;\n    currentEvent.context.client = clientByChainId[event.chainId];\n    currentEvent.context.contracts = contractsByChainId[event.chainId];\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.startBlock;\n\n    const endClock = startClock();\n\n    await indexingFunction({\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (error_) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = error_ as Error & { meta?: string };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addUserStackTrace(error, common.options);\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeLog = async (\n  indexingService: Service,\n  { event }: { event: LogEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}:${event.logEventName}`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId].name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId].name;\n    currentEvent.context.client = clientByChainId[event.chainId];\n    currentEvent.context.contracts = contractsByChainId[event.chainId];\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction({\n      event: {\n        name: event.logEventName,\n        args: event.event.args,\n        log: event.event.log,\n        block: event.event.block,\n        transaction: event.event.transaction,\n        transactionReceipt: event.event.transactionReceipt,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (error_) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = error_ as Error & { meta?: string };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addUserStackTrace(error, common.options);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeBlock = async (\n  indexingService: Service,\n  { event }: { event: BlockEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.sourceName}:block`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const metricLabel = {\n    event: eventName,\n    network: networkByChainId[event.chainId].name,\n  };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId].name;\n    currentEvent.context.client = clientByChainId[event.chainId];\n    currentEvent.context.contracts = contractsByChainId[event.chainId];\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction({\n      event: {\n        block: event.event.block,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (error_) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = error_ as Error & { meta?: string };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addUserStackTrace(error, common.options);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing ${eventName} event at chainId=${decodedCheckpoint.chainId}, block=${decodedCheckpoint.blockNumber}: `,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeCallTrace = async (\n  indexingService: Service,\n  { event }: { event: CallTraceEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}.${event.functionName}`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId].name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId].name;\n    currentEvent.context.client = clientByChainId[event.chainId];\n    currentEvent.context.contracts = contractsByChainId[event.chainId];\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction({\n      event: {\n        args: event.event.args,\n        result: event.event.result,\n        trace: event.event.trace,\n        block: event.event.block,\n        transaction: event.event.transaction,\n        transactionReceipt: event.event.transactionReceipt,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (error_) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = error_ as Error & { meta?: string };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addUserStackTrace(error, common.options);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n","import { getTables } from \"@/schema/utils.js\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionConfig,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n  GetBytecodeParameters,\n  GetBytecodeReturnType,\n  GetEnsNameParameters,\n  GetEnsNameReturnType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n  MulticallParameters,\n  MulticallReturnType,\n  PublicRpcSchema,\n  ReadContractParameters,\n  ReadContractReturnType,\n  Transport,\n} from \"viem\";\nimport {\n  getBalance as viemGetBalance,\n  getBytecode as viemGetBytecode,\n  getStorageAt as viemGetStorageAt,\n  multicall as viemMulticall,\n  readContract as viemReadContract,\n} from \"viem/actions\";\nimport type { Service, create } from \"./service.js\";\n\nexport type BlockOptions =\n  | {\n      cache?: undefined;\n      blockNumber?: undefined;\n    }\n  | {\n      cache: \"immutable\";\n      blockNumber?: undefined;\n    }\n  | {\n      cache?: undefined;\n      blockNumber: bigint;\n    };\n\nexport type PonderActions = {\n  getBalance: (\n    args: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetBalanceReturnType>;\n  getBytecode: (\n    args: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions,\n  ) => Promise<GetBytecodeReturnType>;\n  getStorageAt: (\n    args: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions,\n  ) => Promise<GetStorageAtReturnType>;\n  multicall: <\n    TContracts extends ContractFunctionConfig[],\n    TAllowFailure extends boolean = true,\n  >(\n    args: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<MulticallReturnType<TContracts, TAllowFailure>>;\n  readContract: <\n    const TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n  >(\n    args: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<ReadContractReturnType<TAbi, TFunctionName>>;\n  getEnsName: (\n    args: Omit<GetEnsNameParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetEnsNameReturnType>;\n};\n\nexport type ReadOnlyClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Client<transport, chain, undefined, PublicRpcSchema, PonderActions>\n>;\n\nexport const buildCachedActions = (\n  contextState: Pick<Service[\"currentEvent\"][\"contextState\"], \"blockNumber\">,\n) => {\n  return <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PonderActions => ({\n    getBalance: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetBalanceReturnType> =>\n      viemGetBalance(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getBytecode: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetBytecodeReturnType> =>\n      viemGetBytecode(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getStorageAt: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetStorageAtReturnType> =>\n      viemGetStorageAt(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    multicall: <\n      TContracts extends ContractFunctionConfig[],\n      TAllowFailure extends boolean = true,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<MulticallReturnType<TContracts, TAllowFailure>> =>\n      viemMulticall(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    // @ts-ignore\n    readContract: <\n      const TAbi extends Abi | readonly unknown[],\n      TFunctionName extends string,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<ReadContractReturnType<TAbi, TFunctionName>> =>\n      viemReadContract(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      } as ReadContractParameters<TAbi, TFunctionName>),\n  });\n};\n\nexport const buildDb = ({\n  common,\n  schema,\n  indexingStore,\n  contextState,\n}: Pick<Parameters<typeof create>[0], \"common\" | \"schema\" | \"indexingStore\"> & {\n  contextState: Pick<\n    Service[\"currentEvent\"][\"contextState\"],\n    \"encodedCheckpoint\"\n  >;\n}) => {\n  return Object.keys(getTables(schema)).reduce<\n    Service[\"currentEvent\"][\"context\"][\"db\"]\n  >((acc, tableName) => {\n    acc[tableName] = {\n      findUnique: async ({ id }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.findUnique(id=${id})`,\n        });\n        return indexingStore.findUnique({\n          tableName,\n          id,\n        });\n      },\n      findMany: async ({ where, orderBy, limit, before, after } = {}) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.findMany`,\n        });\n        return indexingStore.findMany({\n          tableName,\n          where,\n          orderBy,\n          limit,\n          before,\n          after,\n        });\n      },\n      create: async ({ id, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.create(id=${id})`,\n        });\n        return indexingStore.create({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          data,\n        });\n      },\n      createMany: async ({ data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.createMany(count=${data.length})`,\n        });\n        return indexingStore.createMany({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          data,\n        });\n      },\n      update: async ({ id, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.update(id=${id})`,\n        });\n        return indexingStore.update({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          data,\n        });\n      },\n      updateMany: async ({ where, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.updateMany`,\n        });\n        return indexingStore.updateMany({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          where,\n          data,\n        });\n      },\n      upsert: async ({ id, create, update }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.upsert(id=${id})`,\n        });\n        return indexingStore.upsert({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          create,\n          update,\n        });\n      },\n      delete: async ({ id }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.delete(id=${id})`,\n        });\n        return indexingStore.delete({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n        });\n      },\n    };\n    return acc;\n  }, {});\n};\n","import { readFileSync } from \"node:fs\";\nimport type { Options } from \"@/common/options.js\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { type StackFrame, parse as parseStackTrace } from \"stacktrace-parser\";\n\nexport const addUserStackTrace = (error: Error, options: Options) => {\n  if (!error.stack) return;\n\n  const stackTrace = parseStackTrace(error.stack);\n\n  let codeFrame: string | undefined;\n  let userStackTrace: StackFrame[];\n\n  // Find first frame that occurred within user code.\n  const firstUserFrameIndex = stackTrace.findIndex((frame) =>\n    frame.file?.includes(options.srcDir),\n  );\n\n  if (firstUserFrameIndex >= 0) {\n    userStackTrace = stackTrace.filter((frame) =>\n      frame.file?.includes(options.srcDir),\n    );\n\n    const firstUserFrame = stackTrace[firstUserFrameIndex];\n    if (firstUserFrame?.file && firstUserFrame?.lineNumber) {\n      try {\n        const sourceContent = readFileSync(firstUserFrame.file, {\n          encoding: \"utf-8\",\n        });\n        codeFrame = codeFrameColumns(\n          sourceContent,\n          {\n            start: {\n              line: firstUserFrame.lineNumber,\n              column: firstUserFrame.column ?? undefined,\n            },\n          },\n          { highlightCode: true },\n        );\n      } catch (err) {\n        // Ignore errors here.\n      }\n    }\n  } else {\n    userStackTrace = stackTrace;\n  }\n\n  const formattedStackTrace = [\n    `${error.name}: ${error.message}`,\n    ...userStackTrace.map(({ file, lineNumber, column, methodName }) => {\n      const prefix = \"    at\";\n      const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n        column !== null ? `:${column}` : \"\"\n      }`;\n      if (methodName === null || methodName === \"<unknown>\") {\n        return `${prefix} ${path}`;\n      } else {\n        return `${prefix} ${methodName} (${path})`;\n      }\n    }),\n    codeFrame,\n  ].join(\"\\n\");\n\n  error.stack = formattedStackTrace;\n};\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  updateIndexingStore,\n  updateLastEventCheckpoint,\n} from \"./service.js\";\nimport type { Context, Service } from \"./service.js\";\n\nconst methods = {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  updateIndexingStore,\n  updateLastEventCheckpoint,\n};\n\nexport const createIndexingService = extend(create, methods);\n\nexport type IndexingService = Extend<Service, typeof methods>;\n\nexport type { Context };\n","import http from \"node:http\";\nimport type { Common } from \"@/common/common.js\";\nimport type { ReadonlyStore } from \"@/indexing-store/store.js\";\nimport { graphiQLHtml } from \"@/ui/graphiql.html.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { maxAliasesPlugin } from \"@escape.tech/graphql-armor-max-aliases\";\nimport { maxDepthPlugin } from \"@escape.tech/graphql-armor-max-depth\";\nimport { maxTokensPlugin } from \"@escape.tech/graphql-armor-max-tokens\";\nimport { serve } from \"@hono/node-server\";\nimport { GraphQLError, GraphQLSchema } from \"graphql\";\nimport { createYoga } from \"graphql-yoga\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { createMiddleware } from \"hono/factory\";\nimport { createHttpTerminator } from \"http-terminator\";\nimport {\n  type GetLoader,\n  buildLoaderCache,\n} from \"./graphql/buildLoaderCache.js\";\n\ntype Server = {\n  hono: Hono<{ Variables: { store: ReadonlyStore; getLoader: GetLoader } }>;\n  port: number;\n  setHealthy: () => void;\n  kill: () => Promise<void>;\n};\n\nexport async function createServer({\n  graphqlSchema,\n  readonlyStore,\n  common,\n}: {\n  graphqlSchema: GraphQLSchema;\n  readonlyStore: ReadonlyStore;\n  common: Common;\n}): Promise<Server> {\n  const hono = new Hono<{\n    Variables: { store: ReadonlyStore; getLoader: GetLoader };\n  }>();\n\n  let port = common.options.port;\n  let isHealthy = false;\n  const startTime = Date.now();\n\n  const metricsMiddleware = createMiddleware(async (c, next) => {\n    const commonLabels = { method: c.req.method, path: c.req.path };\n    common.metrics.ponder_http_server_active_requests.inc(commonLabels);\n    const endClock = startClock();\n\n    try {\n      await next();\n    } finally {\n      const requestSize = Number(c.req.header(\"Content-Length\") ?? 0);\n      const responseSize = Number(c.res.headers.get(\"Content-Length\") ?? 0);\n      const responseDuration = endClock();\n      const status =\n        c.res.status >= 200 && c.res.status < 300\n          ? \"2XX\"\n          : c.res.status >= 300 && c.res.status < 400\n            ? \"3XX\"\n            : c.res.status >= 400 && c.res.status < 500\n              ? \"4XX\"\n              : \"5XX\";\n\n      common.metrics.ponder_http_server_active_requests.dec(commonLabels);\n      common.metrics.ponder_http_server_request_size_bytes.observe(\n        { ...commonLabels, status },\n        requestSize,\n      );\n      common.metrics.ponder_http_server_response_size_bytes.observe(\n        { ...commonLabels, status },\n        responseSize,\n      );\n      common.metrics.ponder_http_server_request_duration_ms.observe(\n        { ...commonLabels, status },\n        responseDuration,\n      );\n    }\n  });\n\n  const createGraphqlYoga = (path: string) =>\n    createYoga({\n      schema: graphqlSchema,\n      context: () => {\n        const getLoader = buildLoaderCache({ store: readonlyStore });\n        return { store: readonlyStore, getLoader };\n      },\n      graphqlEndpoint: path,\n      maskedErrors: process.env.NODE_ENV === \"production\",\n      logging: false,\n      graphiql: false,\n      parserAndValidationCache: false,\n      plugins: [\n        maxTokensPlugin({ n: common.options.graphqlMaxOperationTokens }),\n        maxDepthPlugin({\n          n: common.options.graphqlMaxOperationDepth,\n          ignoreIntrospection: false,\n        }),\n        maxAliasesPlugin({\n          n: common.options.graphqlMaxOperationAliases,\n          allowList: [],\n        }),\n      ],\n    });\n\n  const rootYoga = createGraphqlYoga(\"/\");\n  const rootGraphiql = graphiQLHtml(\"/\");\n\n  const prodYoga = createGraphqlYoga(\"/graphql\");\n  const prodGraphiql = graphiQLHtml(\"/graphql\");\n\n  hono\n    .use(cors())\n    .use(metricsMiddleware)\n    .get(\"/metrics\", async (c) => {\n      try {\n        const metrics = await common.metrics.getMetrics();\n        return c.text(metrics);\n      } catch (error) {\n        return c.json(error, 500);\n      }\n    })\n    .get(\"/health\", async (c) => {\n      if (isHealthy) {\n        return c.text(\"\", 200);\n      }\n\n      const elapsed = (Date.now() - startTime) / 1000;\n      const max = common.options.maxHealthcheckDuration;\n\n      if (elapsed > max) {\n        common.logger.warn({\n          service: \"server\",\n          msg: `Historical indexing duration has exceeded the max healthcheck duration of ${max} seconds (current: ${elapsed}). Sevice is now responding as healthy and may serve incomplete data.`,\n        });\n        return c.text(\"\", 200);\n      }\n\n      return c.text(\"Historical indexing is not complete.\", 503);\n    })\n    // Renders GraphiQL\n    .get(\"/graphql\", (c) => c.html(prodGraphiql))\n    // Serves GraphQL POST requests following healthcheck rules\n    .post(\"/graphql\", (c) => {\n      if (isHealthy === false) {\n        return c.json(\n          { errors: [new GraphQLError(\"Historical indexing is not complete\")] },\n          503,\n        );\n      }\n\n      return prodYoga.handle(c.req.raw);\n    })\n    // Renders GraphiQL\n    .get(\"/\", (c) => c.html(rootGraphiql))\n    // Serves GraphQL POST requests regardless of health status, e.g. \"dev UI\"\n    .post(\"/\", (c) => rootYoga.handle(c.req.raw));\n\n  const createServerWithNextAvailablePort: typeof http.createServer = (\n    ...args: any\n  ) => {\n    const httpServer = http.createServer(...args);\n\n    const errorHandler = (error: Error & { code: string }) => {\n      if (error.code === \"EADDRINUSE\") {\n        common.logger.warn({\n          service: \"server\",\n          msg: `Port ${port} was in use, trying port ${port + 1}`,\n        });\n        port += 1;\n        setTimeout(() => {\n          httpServer.close();\n          httpServer.listen(port, common.options.hostname);\n        }, 5);\n      }\n    };\n\n    const listenerHandler = () => {\n      common.metrics.ponder_http_server_port.set(port);\n      common.logger.info({\n        service: \"server\",\n        msg: `Started listening on port ${port}`,\n      });\n      httpServer.off(\"error\", errorHandler);\n    };\n\n    httpServer.on(\"error\", errorHandler);\n    httpServer.on(\"listening\", listenerHandler);\n\n    return httpServer;\n  };\n\n  const httpServer = await new Promise<http.Server>((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(\"HTTP server failed to start within 5 seconds.\"));\n    }, 5_000);\n\n    const httpServer = serve(\n      {\n        fetch: hono.fetch,\n        createServer: createServerWithNextAvailablePort,\n        port,\n        // Note that common.options.hostname can be undefined if the user did not specify one.\n        // In this case, Node.js uses `::` if IPv6 is available and `0.0.0.0` otherwise.\n        // https://nodejs.org/api/net.html#serverlistenport-host-backlog-callback\n        hostname: common.options.hostname,\n      },\n      () => {\n        clearTimeout(timeout);\n        resolve(httpServer as http.Server);\n      },\n    );\n  });\n\n  const terminator = createHttpTerminator({\n    server: httpServer,\n    gracefulTerminationTimeout: 1000,\n  });\n\n  return {\n    hono,\n    port,\n    setHealthy: () => {\n      isHealthy = true;\n    },\n    kill: () => terminator.terminate(),\n  };\n}\n","// https://github.com/graphql/graphiql/blob/main/examples/graphiql-cdn/index.html\n\nexport const graphiQLHtml = (path: string) => `<!--\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n-->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Ponder Playground</title>\n    <style>\n      body {\n        height: 100%;\n        margin: 0;\n        width: 100%;\n        overflow: hidden;\n      }\n      #graphiql {\n        height: 100vh;\n      }\n      *::-webkit-scrollbar {\n        height: 0.3rem;\n        width: 0.5rem;\n      }\n      *::-webkit-scrollbar-track {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n      *::-webkit-scrollbar-thumb {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n    </style>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/graphiql/graphiql.min.css\" />\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/@graphiql/plugin-explorer/dist/style.css\" />\n  </head>\n  <body>\n    <div id=\"graphiql\">Loading...</div>\n    <script crossorigin src=\"https://unpkg.com/react/umd/react.development.js\"></script>1\n    <script crossorigin src=\"https://unpkg.com/react-dom/umd/react-dom.development.js\"></script>\n    <script src=\"https://unpkg.com/graphiql/graphiql.min.js\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://unpkg.com/@graphiql/plugin-explorer/dist/index.umd.js\" crossorigin=\"anonymous\"></script>\n    <script>\n      const fetcher = GraphiQL.createFetcher({ url: \"${path}\" });\n      const explorerPlugin = GraphiQLPluginExplorer.explorerPlugin();\n      const root = ReactDOM.createRoot(document.getElementById(\"graphiql\"));\n      root.render(\n        React.createElement(GraphiQL, {\n          fetcher,\n          plugins: [explorerPlugin],\n          defaultEditorToolsVisibility: false,\n        })\n      );\n    </script>\n  </body>\n</html>`;\n","import type { ReadonlyStore } from \"@/indexing-store/store.js\";\nimport DataLoader from \"dataloader\";\n\nexport type GetLoader = ReturnType<typeof buildLoaderCache>;\n\nexport function buildLoaderCache({ store }: { store: ReadonlyStore }) {\n  const loaderCache: Record<\n    string,\n    DataLoader<string | number | bigint, any> | undefined\n  > = {};\n\n  return ({ tableName }: { tableName: string }) => {\n    const loader = (loaderCache[tableName] ??= new DataLoader(\n      async (ids) => {\n        const rows = await store.findMany({\n          tableName,\n          where: { id: { in: ids } },\n          limit: ids.length,\n        });\n\n        return ids.map((id) => rows.items.find((row) => row.id === id));\n      },\n      { maxBatchSize: 1_000 },\n    ));\n\n    return loader;\n  };\n}\n","import type {\n  CallTraceFilterCriteria,\n  ChildAddressCriteria,\n  FactoryCallTraceFilterCriteria,\n  FactoryLogFilterCriteria,\n  LogFilterCriteria,\n} from \"@/config/sources.js\";\nimport type { Address, Hex } from \"viem\";\n\n/**\n * Generates log filter fragments from a log filter.\n *\n * @param logFilter Log filter to be decompose into fragments.\n * @returns A list of log filter fragments.\n */\nexport function buildLogFilterFragments({\n  address,\n  topics,\n  includeTransactionReceipts,\n  chainId,\n}: LogFilterCriteria & {\n  chainId: number;\n}) {\n  return buildLogFragments({\n    address,\n    topics,\n    includeTransactionReceipts,\n    chainId,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n        includeTransactionReceipts ? 1 : 0\n      }`,\n  });\n}\n\n/**\n * Generates factory fragments from a factory.\n *\n * @param factory Factory to be decomposed into fragments.\n * @returns A list of factory fragments.\n */\nexport function buildFactoryLogFragments({\n  address,\n  eventSelector,\n  childAddressLocation,\n  topics,\n  includeTransactionReceipts,\n  chainId,\n}: FactoryLogFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments = buildLogFragments({\n    address,\n    topics,\n    includeTransactionReceipts,\n    chainId,\n    childAddressLocation,\n    eventSelector,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${eventSelector}_${childAddressLocation}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n        includeTransactionReceipts ? 1 : 0\n      }`,\n  });\n\n  return fragments as ((typeof fragments)[number] & ChildAddressCriteria)[];\n}\n\nfunction buildLogFragments({\n  address,\n  topics,\n  chainId,\n  idCallback,\n  includeTransactionReceipts,\n  ...rest\n}: (LogFilterCriteria | FactoryLogFilterCriteria) & {\n  idCallback: (\n    address: Address | null,\n    topic0: ReturnType<typeof parseTopics>[\"topic0\"],\n    topic1: ReturnType<typeof parseTopics>[\"topic1\"],\n    topic2: ReturnType<typeof parseTopics>[\"topic2\"],\n    topic3: ReturnType<typeof parseTopics>[\"topic3\"],\n  ) => string;\n  chainId: number;\n}) {\n  const fragments: {\n    id: string;\n    chainId: number;\n    address: Hex | null;\n    topic0: Hex | null;\n    topic1: Hex | null;\n    topic2: Hex | null;\n    topic3: Hex | null;\n    includeTransactionReceipts: 0 | 1;\n  }[] = [];\n\n  const { topic0, topic1, topic2, topic3 } = parseTopics(topics);\n\n  for (const address_ of Array.isArray(address) ? address : [address ?? null]) {\n    for (const topic0_ of Array.isArray(topic0) ? topic0 : [topic0]) {\n      for (const topic1_ of Array.isArray(topic1) ? topic1 : [topic1]) {\n        for (const topic2_ of Array.isArray(topic2) ? topic2 : [topic2]) {\n          for (const topic3_ of Array.isArray(topic3) ? topic3 : [topic3]) {\n            fragments.push({\n              id: idCallback(address_, topic0_, topic1_, topic2_, topic3_),\n              ...rest,\n              chainId,\n              address: address_,\n              topic0: topic0_,\n              topic1: topic1_,\n              topic2: topic2_,\n              topic3: topic3_,\n              includeTransactionReceipts: includeTransactionReceipts ? 1 : 0,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return fragments;\n}\n\nfunction parseTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  return {\n    topic0: topics?.[0] ?? null,\n    topic1: topics?.[1] ?? null,\n    topic2: topics?.[2] ?? null,\n    topic3: topics?.[3] ?? null,\n  } as {\n    topic0: Hex | Hex[] | null;\n    topic1: Hex | Hex[] | null;\n    topic2: Hex | Hex[] | null;\n    topic3: Hex | Hex[] | null;\n  };\n}\n\nexport function buildTraceFragments({\n  fromAddress,\n  toAddress,\n  chainId,\n}: CallTraceFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments: {\n    id: string;\n    chainId: number;\n    fromAddress: Hex | null;\n    toAddress: Hex | null;\n  }[] = [];\n\n  for (const _fromAddress of Array.isArray(fromAddress)\n    ? fromAddress\n    : [null]) {\n    for (const _toAddress of Array.isArray(toAddress) ? toAddress : [null]) {\n      fragments.push({\n        id: `${chainId}_${_fromAddress}_${_toAddress}`,\n        chainId,\n        fromAddress: _fromAddress,\n        toAddress: _toAddress,\n      });\n    }\n  }\n\n  return fragments;\n}\n\nexport function buildFactoryTraceFragments({\n  address,\n  eventSelector,\n  childAddressLocation,\n  fromAddress,\n  chainId,\n}: FactoryCallTraceFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments: ({\n    id: string;\n    chainId: number;\n    fromAddress: Hex | null;\n  } & ChildAddressCriteria)[] = [];\n\n  for (const _fromAddress of Array.isArray(fromAddress)\n    ? fromAddress\n    : [null]) {\n    fragments.push({\n      id: `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${_fromAddress}`,\n      chainId,\n      address,\n      eventSelector,\n      childAddressLocation,\n      fromAddress: _fromAddress,\n    });\n  }\n\n  return fragments;\n}\n","/**\n * Return the total sum of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the sum of.\n * @returns Sum of the intervals.\n */\nexport function intervalSum(intervals: [number, number][]) {\n  let totalSum = 0;\n\n  for (const [start, end] of intervals) {\n    totalSum += end - start + 1;\n  }\n\n  return totalSum;\n}\n\n/**\n * Return the union of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the union of.\n * @returns Union of the intervals, represented as a list of intervals.\n */\nexport function intervalUnion(intervals_: [number, number][]) {\n  if (intervals_.length === 0) return [];\n\n  // Create copies to avoid mutating the originals.\n  const intervals = intervals_.map(\n    (interval) => [...interval] as [number, number],\n  );\n  // Sort intervals based on the left end.\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const result: [number, number][] = [];\n  let currentInterval = intervals[0];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const nextInterval = intervals[i];\n\n    if (currentInterval[1] >= nextInterval[0] - 1) {\n      // Merge overlapping intervals\n      currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);\n    } else {\n      // No overlap, add current interval to result\n      result.push(currentInterval);\n      currentInterval = nextInterval;\n    }\n  }\n\n  result.push(currentInterval); // Add the last interval\n  return result;\n}\n\n/**\n * Return the intersection of two lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersection(\n  list1: [number, number][],\n  list2: [number, number][],\n) {\n  const result: [number, number][] = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < list1.length && j < list2.length) {\n    const [start1, end1] = list1[i];\n    const [start2, end2] = list2[j];\n\n    const intersectionStart = Math.max(start1, start2);\n    const intersectionEnd = Math.min(end1, end2);\n\n    if (intersectionStart <= intersectionEnd) {\n      result.push([intersectionStart, intersectionEnd]);\n    }\n\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  // Merge potentially overlapping intervals before returning.\n  return intervalUnion(result);\n}\n\n/**\n * Return the intersection of many lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersectionMany(lists: [number, number][][]) {\n  if (lists.length === 0) return [];\n  if (lists.length === 1) return lists[0];\n\n  let result: [number, number][] = lists[0];\n\n  for (let i = 1; i < lists.length; i++) {\n    result = intervalIntersection(result, lists[i]);\n  }\n\n  return intervalUnion(result);\n}\n\n/**\n * Return the difference between two lists of numeric intervals (initial - remove).\n *\n * @param initial Starting/base list of numeric intervals.\n * @param remove List of numeric intervals to remove.\n * @returns Difference of the intervals, represented as a list of intervals.\n */\nexport function intervalDifference(\n  initial: [number, number][],\n  remove: [number, number][],\n) {\n  // Create copies to avoid mutating the originals.\n  const initial_ = initial.map((interval) => [...interval] as [number, number]);\n  const remove_ = remove.map((interval) => [...interval] as [number, number]);\n\n  const result: [number, number][] = [];\n\n  let i = 0;\n  let j = 0;\n\n  while (i < initial.length && j < remove.length) {\n    const interval1 = initial_[i];\n    const interval2 = remove_[j];\n\n    if (interval1[1] < interval2[0]) {\n      // No overlap, add interval1 to the result\n      result.push(interval1);\n      i++;\n    } else if (interval2[1] < interval1[0]) {\n      // No overlap, move to the next interval in remove\n      j++;\n    } else {\n      // There is an overlap\n      if (interval1[0] < interval2[0]) {\n        // Add the left part of interval1\n        result.push([interval1[0], interval2[0] - 1]);\n      }\n      if (interval1[1] > interval2[1]) {\n        // Update interval1's start to exclude the overlap\n        interval1[0] = interval2[1] + 1;\n        j++;\n      } else {\n        // No more overlap, move to the next interval in initial\n        i++;\n      }\n    }\n  }\n\n  // Add any remaining intervals from initial\n  while (i < initial_.length) {\n    result.push(initial_[i]);\n    i++;\n  }\n\n  return result;\n}\n\nexport function getChunks({\n  intervals,\n  maxChunkSize,\n}: {\n  intervals: [number, number][];\n  maxChunkSize: number;\n}) {\n  const _chunks: [number, number][] = [];\n\n  for (const interval of intervals) {\n    const [startBlock, endBlock] = interval;\n\n    let fromBlock = startBlock;\n    let toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n\n    while (fromBlock <= endBlock) {\n      _chunks.push([fromBlock, toBlock]);\n\n      fromBlock = toBlock + 1;\n      toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n    }\n  }\n\n  return _chunks;\n}\n\nexport class ProgressTracker {\n  target: [number, number];\n  private _completed: [number, number][];\n  private _required: [number, number][] | null = null;\n  private _checkpoint: number | null = null;\n\n  /**\n   * Constructs a new ProgressTracker object.\n\n   * @throws Will throw an error if the target interval is invalid.\n   */\n  constructor({\n    target,\n    completed,\n  }: {\n    target: [number, number];\n    completed: [number, number][];\n  }) {\n    if (target[0] > target[1])\n      throw new Error(\n        `Invalid interval: start (${target[0]}) is greater than end (${target[1]})`,\n      );\n\n    this.target = target;\n    this._completed = completed;\n  }\n\n  /**\n   * Adds a completed interval.\n   *\n   * @throws Will throw an error if the new interval is invalid.\n   */\n  addCompletedInterval(interval: [number, number]) {\n    if (interval[0] > interval[1])\n      throw new Error(\n        `Invalid interval: start (${interval[0]}) is greater than end (${interval[1]})`,\n      );\n\n    const prevCheckpoint = this.getCheckpoint();\n    this._completed = intervalUnion([...this._completed, interval]);\n    this.invalidateCache();\n    const newCheckpoint = this.getCheckpoint();\n\n    return {\n      isUpdated: newCheckpoint > prevCheckpoint,\n      prevCheckpoint,\n      newCheckpoint,\n    };\n  }\n\n  /**\n   * Returns the remaining required intervals.\n   */\n  getRequired() {\n    if (this._required === null) {\n      this._required = intervalDifference([this.target], this._completed);\n    }\n    return this._required;\n  }\n\n  /**\n   * Returns the checkpoint value. If no progress has been made, the checkpoint\n   * is equal to the target start minus one.\n   */\n  getCheckpoint() {\n    if (this._checkpoint !== null) return this._checkpoint;\n\n    const completedIntervalIncludingTargetStart = this._completed\n      .sort((a, b) => a[0] - b[0])\n      .find((i) => i[0] <= this.target[0] && i[1] >= this.target[0]);\n\n    if (completedIntervalIncludingTargetStart) {\n      this._checkpoint = completedIntervalIncludingTargetStart[1];\n    } else {\n      this._checkpoint = this.target[0] - 1;\n    }\n\n    return this._checkpoint;\n  }\n\n  private invalidateCache() {\n    this._required = null;\n    this._checkpoint = null;\n  }\n}\n\n/**\n * Need granular writes to db and retries at each step rather than at the task level\n */\n\nexport class BlockProgressTracker {\n  private pendingBlocks: number[] = [];\n  private completedBlocks: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }[] = [];\n\n  checkpoint: { blockNumber: number; blockTimestamp: number } | null = null;\n\n  addPendingBlocks({ blockNumbers }: { blockNumbers: number[] }): void {\n    if (blockNumbers.length === 0) return;\n\n    const maxPendingBlock = this.pendingBlocks[this.pendingBlocks.length - 1];\n\n    const sorted = blockNumbers.sort((a, b) => a - b);\n    const minNewPendingBlock = sorted[0];\n\n    if (\n      this.pendingBlocks.length > 0 &&\n      minNewPendingBlock <= maxPendingBlock\n    ) {\n      throw new Error(\n        `New pending block number ${minNewPendingBlock} was added out of order. Already added block number ${maxPendingBlock}.`,\n      );\n    }\n\n    sorted.forEach((blockNumber) => {\n      this.pendingBlocks.push(blockNumber);\n    });\n  }\n\n  /**\n   * Add a new completed block. If adding this block moves the checkpoint, returns the\n   * new checkpoint. Otherwise, returns null.\n   */\n  addCompletedBlock({\n    blockNumber,\n    blockTimestamp,\n  }: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }) {\n    // Find and remove the completed block from the pending list.\n    const pendingBlockIndex = this.pendingBlocks.findIndex(\n      (pendingBlock) => pendingBlock === blockNumber,\n    );\n    if (pendingBlockIndex === -1) {\n      throw new Error(\n        `Block number ${blockNumber} was not pending. Ensure to add blocks as pending before marking them as completed.`,\n      );\n    }\n    this.pendingBlocks.splice(pendingBlockIndex, 1);\n\n    // Add the new completed block to the completed block list, and maintain the sort order.\n    // Note that this could be optimized using a for loop with a break.\n    this.completedBlocks.push({ blockNumber, blockTimestamp });\n    this.completedBlocks.sort((a, b) => a.blockNumber - b.blockNumber);\n\n    // If the pending blocks list is now empty, return the max block present in\n    // the list of completed blocks. This happens at the end of the sync.\n    if (this.pendingBlocks.length === 0) {\n      this.checkpoint = this.completedBlocks[this.completedBlocks.length - 1];\n      return this.checkpoint;\n    }\n\n    // Find all completed blocks that are less than the minimum pending block.\n    // These blocks are \"safe\".\n    const safeCompletedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber < this.pendingBlocks[0],\n    );\n\n    // If there are no safe blocks, the first pending block has not been completed yet.\n    if (safeCompletedBlocks.length === 0) return null;\n\n    const maximumSafeCompletedBlock =\n      safeCompletedBlocks[safeCompletedBlocks.length - 1];\n\n    // Remove all safe completed blocks that are less than the new checkpoint.\n    // This avoid a memory leak and speeds up subsequent calls.\n    this.completedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber >= maximumSafeCompletedBlock.blockNumber,\n    );\n\n    // If this is the first checkpoint OR this checkpoint is greater than\n    // the previous checkpoint, store and return it as updated.\n    if (\n      !this.checkpoint ||\n      maximumSafeCompletedBlock.blockNumber > this.checkpoint.blockNumber\n    ) {\n      this.checkpoint = maximumSafeCompletedBlock;\n      return this.checkpoint;\n    }\n\n    // Otherwise, the checkpoint is not updated.\n    return null;\n  }\n}\n","/**\n * Generates an array of integers between two bounds. Exclusive on the right.\n *\n * @param start Integer to start at.\n * @param stop Integer to stop at (exclusive).\n */\nexport const range = (start: number, stop: number) =>\n  Array.from({ length: stop - start }, (_, i) => start + i);\n","import {\n  type BlockFilterCriteria,\n  type CallTraceFilterCriteria,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceFilterCriteria,\n  type FactoryCallTraceSource,\n  type FactoryLogFilterCriteria,\n  type FactoryLogSource,\n  type LogFilterCriteria,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { SyncCallTrace, SyncLog } from \"@/sync/index.js\";\nimport type { CallTrace, Log, TransactionReceipt } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport {\n  type Checkpoint,\n  EVENT_TYPES,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport {\n  buildFactoryLogFragments,\n  buildFactoryTraceFragments,\n  buildLogFilterFragments,\n  buildTraceFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport {\n  type ExpressionBuilder,\n  type OperandExpression,\n  type SqlBool,\n  type Transaction as KyselyTransaction,\n  sql,\n} from \"kysely\";\nimport {\n  type Hex,\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  type RpcTransactionReceipt,\n  checksumAddress,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport type { RawEvent, SyncStore } from \"../store.js\";\nimport {\n  type InsertableCallTrace,\n  type SyncStoreTables,\n  rpcToPostgresBlock,\n  rpcToPostgresLog,\n  rpcToPostgresTrace,\n  rpcToPostgresTransaction,\n  rpcToPostgresTransactionReceipt,\n} from \"./encoding.js\";\n\nexport class PostgresSyncStore implements SyncStore {\n  kind = \"postgres\" as const;\n  db: HeadlessKysely<SyncStoreTables>;\n\n  constructor({ db }: { db: HeadlessKysely<SyncStoreTables> }) {\n    this.db = db;\n  }\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertLogFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [logFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getLogFilterIntervals\" }, async () => {\n      const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await Promise.all(\n        fragments.map(async (fragment) => {\n          return await this.db.transaction().execute(async (tx) => {\n            const { id: logFilterId } = await tx\n              .insertInto(\"logFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            const existingIntervalRows = await tx\n              .deleteFrom(\"logFilterIntervals\")\n              .where(\"logFilterId\", \"=\", logFilterId)\n              .returningAll()\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervalRows.map((i) => [\n                Number(i.startBlock),\n                Number(i.endBlock),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                logFilterId,\n                startBlock: BigInt(startBlock),\n                endBlock: BigInt(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"logFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n          });\n        }),\n      );\n\n      const intervals = await this.db\n        .with(\n          \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                    f.topic0,\n                  )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                    f.topic3,\n                  )}, ${sql.lit(f.includeTransactionReceipts)} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"logFilterIntervals\")\n        .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n        .innerJoin(\"logFilterFragments\", (join) => {\n          let baseJoin = join.on((eb) =>\n            eb.or([\n              eb(\"address\", \"is\", null),\n              eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            ]),\n          );\n          baseJoin = baseJoin.on((eb) =>\n            eb(\n              \"fragmentIncludeTransactionReceipts\",\n              \"<=\",\n              sql.ref(\"includeTransactionReceipts\"),\n            ),\n          );\n          for (const idx_ of range(0, 4)) {\n            baseJoin = baseJoin.on((eb) => {\n              const idx = idx_ as 0 | 1 | 2 | 3;\n              return eb.or([\n                eb(`topic${idx}`, \"is\", null),\n                eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n              ]);\n            });\n          }\n\n          return baseJoin;\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryChildAddressLogs\" },\n      async () => {\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n          }));\n          await this.db\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      },\n    );\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    fromBlock,\n    toBlock,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n    toBlock: bigint;\n    factory: FactoryLogFilterCriteria | FactoryCallTraceFilterCriteria;\n    pageSize?: number;\n  }) {\n    const { address, eventSelector, childAddressLocation } = factory;\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({ childAddressLocation });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([\"id\", selectChildAddressExpression.as(\"childAddress\")])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \">=\", fromBlock)\n      .where(\"blockNumber\", \"<=\", toBlock)\n      .orderBy(\"id\", \"asc\")\n      .limit(pageSize);\n\n    let cursor: string | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n      if (cursor !== undefined) query = query.where(\"id\", \">\", cursor);\n\n      const batch = await this.db.wrap(\n        { method: \"getFactoryChildAddresses\" },\n        () => query.execute(),\n      );\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      // If the batch is less than the page size, there are no more pages.\n      if (batch.length < pageSize) break;\n      // Otherwise, set the cursor to the last block number in the batch.\n      cursor = batch[batch.length - 1].id;\n    }\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryLogFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((transaction) => ({\n              ...rpcToPostgresTransaction(transaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          if (rpcLogs.length > 0) {\n            const logs = rpcLogs.map((rpcLog) => ({\n              ...rpcToPostgresLog(rpcLog),\n              chainId,\n              checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n            }));\n\n            await tx\n              .insertInto(\"logs\")\n              .values(logs)\n              .onConflict((oc) =>\n                oc.column(\"id\").doUpdateSet((eb) => ({\n                  checkpoint: eb.ref(\"excluded.checkpoint\"),\n                })),\n              )\n              .execute();\n          }\n\n          await this._insertFactoryLogFilterInterval({\n            tx,\n            chainId,\n            factoryLogFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryLogFragments({ ...factory, chainId });\n\n        await Promise.all(\n          fragments.map(async (fragment) => {\n            await this.db.transaction().execute(async (tx) => {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryLogFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryLogFilterIntervals\")\n                .where(\"factoryId\", \"=\", factoryId)\n                .returningAll()\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(i.startBlock),\n                  Number(i.endBlock),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: BigInt(startBlock),\n                  endBlock: BigInt(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryLogFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n            });\n          }),\n        );\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                      f.topic0,\n                    )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                      f.topic3,\n                    )}, ${sql.lit(f.includeTransactionReceipts)} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryLogFilterIntervals\")\n          .innerJoin(\"factoryLogFilters\", \"factoryId\", \"factoryLogFilters.id\")\n          .innerJoin(\"factoryFilterFragments\", (join) => {\n            let baseJoin = join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n              ]),\n            );\n            baseJoin = baseJoin.on((eb) =>\n              eb(\n                \"fragmentIncludeTransactionReceipts\",\n                \"<=\",\n                sql.ref(\"includeTransactionReceipts\"),\n              ),\n            );\n            for (const idx_ of range(0, 4)) {\n              baseJoin = baseJoin.on((eb) => {\n                const idx = idx_ as 0 | 1 | 2 | 3;\n                return eb.or([\n                  eb(`topic${idx}`, \"is\", null),\n                  eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n                ]);\n              });\n            }\n\n            return baseJoin;\n          })\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertBlockFilterInterval = async ({\n    chainId,\n    blockFilter,\n    block: rpcBlock,\n    interval,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n    block?: RpcBlock;\n    interval: { startBlock: bigint; endBlock: bigint };\n  }): Promise<void> => {\n    return this.db.wrap({ method: \"insertBlockFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        if (rpcBlock !== undefined) {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters: [blockFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getBlockFilterIntervals = async ({\n    chainId,\n    blockFilter,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getBlockFilterIntervals\" }, async () => {\n      const fragment = {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await this.db.transaction().execute(async (tx) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        const existingIntervalRows = await tx\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\"blockFilterId\", \"=\", blockFilterId)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = intervalUnion(\n          existingIntervalRows.map((i) => [\n            Number(i.startBlock),\n            Number(i.endBlock),\n          ]),\n        );\n\n        const mergedIntervalRows = mergedIntervals.map(\n          ([startBlock, endBlock]) => ({\n            blockFilterId,\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          }),\n        );\n\n        if (mergedIntervalRows.length > 0) {\n          await tx\n            .insertInto(\"blockFilterIntervals\")\n            .values(mergedIntervalRows)\n            .execute();\n        }\n      });\n\n      const intervals = await this.db\n        .selectFrom(\"blockFilterIntervals\")\n        .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n        .select([\n          \"blockFilterIntervals.startBlock\",\n          \"blockFilterIntervals.endBlock\",\n        ])\n        .where(\"blockFilterId\", \"=\", fragment.id)\n        .execute();\n\n      return intervals.map(\n        ({ startBlock, endBlock }) =>\n          [Number(startBlock), Number(endBlock)] as [number, number],\n      );\n    });\n  };\n\n  getBlock = async ({\n    chainId,\n    blockNumber,\n  }: {\n    chainId: number;\n    blockNumber: number;\n  }): Promise<boolean> => {\n    const hasBlock = await this.db\n      .selectFrom(\"blocks\")\n      .select(\"hash\")\n      .where(\"number\", \"=\", BigInt(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .executeTakeFirst();\n\n    return hasBlock !== undefined;\n  };\n\n  insertTraceFilterInterval = async ({\n    chainId,\n    traceFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertTraceFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n        // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n        const traceByTransactionHash: {\n          [transactionHash: Hex]: SyncCallTrace[];\n        } = {};\n        for (const trace of rpcTraces) {\n          if (traceByTransactionHash[trace.transactionHash] === undefined) {\n            traceByTransactionHash[trace.transactionHash] = [];\n          }\n          traceByTransactionHash[trace.transactionHash].push(trace);\n        }\n\n        for (const transactionHash of Object.keys(traceByTransactionHash)) {\n          const traces = await tx\n            .deleteFrom(\"callTraces\")\n            .returningAll()\n            .where(\"transactionHash\", \"=\", transactionHash as Hex)\n            .where(\"chainId\", \"=\", chainId)\n            .execute();\n\n          (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n            ...traceByTransactionHash[transactionHash as Hex].map((trace) => ({\n              ...rpcToPostgresTrace(trace),\n              chainId,\n            })),\n          );\n\n          // Use lexographical sort of stringified `traceAddress`.\n          traces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          for (let i = 0; i < traces.length; i++) {\n            const trace = traces[i];\n            const checkpoint = encodeCheckpoint({\n              blockTimestamp: hexToNumber(rpcBlock.timestamp),\n              chainId: BigInt(chainId),\n              blockNumber: trace.blockNumber,\n              transactionIndex: BigInt(trace.transactionPosition),\n              eventType: EVENT_TYPES.callTraces,\n              eventIndex: BigInt(i),\n            });\n\n            trace.checkpoint = checkpoint;\n          }\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters: [traceFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getTraceFilterIntervals = async ({\n    traceFilter,\n    chainId,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getTraceFilterIntervals\" }, async () => {\n      const fragments = buildTraceFragments({ ...traceFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await Promise.all(\n        fragments.map(async (fragment) => {\n          return await this.db.transaction().execute(async (tx) => {\n            const { id: traceFilterId } = await tx\n              .insertInto(\"traceFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            const existingIntervalRows = await tx\n              .deleteFrom(\"traceFilterIntervals\")\n              .where(\"traceFilterId\", \"=\", traceFilterId)\n              .returningAll()\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervalRows.map((i) => [\n                Number(i.startBlock),\n                Number(i.endBlock),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                traceFilterId,\n                startBlock: BigInt(startBlock),\n                endBlock: BigInt(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"traceFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n          });\n        }),\n      );\n\n      const intervals = await this.db\n        .with(\n          \"traceFilterFragments(fragmentId, fragmentFromAddress, fragmentToAddress)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.fromAddress)}, ${sql.val(\n                    f.toAddress,\n                  )} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"traceFilterIntervals\")\n        .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n        .innerJoin(\"traceFilterFragments\", (join) => {\n          return join.on((eb) =>\n            eb.and([\n              eb.or([\n                eb(\"fromAddress\", \"is\", null),\n                eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n              ]),\n              eb.or([\n                eb(\"toAddress\", \"is\", null),\n                eb(\"fragmentToAddress\", \"=\", sql.ref(\"toAddress\")),\n              ]),\n            ]),\n          );\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryTraceFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryTraceFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToPostgresTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n          // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n          const traceByTransactionHash: {\n            [transactionHash: Hex]: SyncCallTrace[];\n          } = {};\n          for (const trace of rpcTraces) {\n            if (traceByTransactionHash[trace.transactionHash] === undefined) {\n              traceByTransactionHash[trace.transactionHash] = [];\n            }\n            traceByTransactionHash[trace.transactionHash].push(trace);\n          }\n\n          for (const transactionHash of Object.keys(traceByTransactionHash)) {\n            const traces = await tx\n              .deleteFrom(\"callTraces\")\n              .returningAll()\n              .where(\"transactionHash\", \"=\", transactionHash as Hex)\n              .where(\"chainId\", \"=\", chainId)\n              .execute();\n\n            (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n              ...traceByTransactionHash[transactionHash as Hex].map(\n                (trace) => ({\n                  ...rpcToPostgresTrace(trace),\n                  chainId,\n                }),\n              ),\n            );\n\n            // Use lexographical sort of stringified `traceAddress`.\n            traces.sort((a, b) => {\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n            for (let i = 0; i < traces.length; i++) {\n              const trace = traces[i];\n              const checkpoint = encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: trace.blockNumber,\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              });\n\n              trace.checkpoint = checkpoint;\n            }\n\n            await tx\n              .insertInto(\"callTraces\")\n              .values(traces)\n              .onConflict((oc) => oc.column(\"id\").doNothing())\n              .execute();\n          }\n\n          await this._insertFactoryTraceFilterInterval({\n            tx,\n            chainId,\n            factoryTraceFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryTraceFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryTraceFragments({ ...factory, chainId });\n\n        await Promise.all(\n          fragments.map(async (fragment) => {\n            return await this.db.transaction().execute(async (tx) => {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryTraceFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryTraceFilterIntervals\")\n                .where(\"factoryId\", \"=\", factoryId)\n                .returningAll()\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(i.startBlock),\n                  Number(i.endBlock),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: BigInt(startBlock),\n                  endBlock: BigInt(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryTraceFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n            });\n          }),\n        );\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentFromAddress)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                      f.fromAddress,\n                    )} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryTraceFilterIntervals\")\n          .innerJoin(\n            \"factoryTraceFilters\",\n            \"factoryId\",\n            \"factoryTraceFilters.id\",\n          )\n          .innerJoin(\"factoryFilterFragments\", (join) =>\n            join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n                eb.or([\n                  eb(\"fromAddress\", \"is\", null),\n                  eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n                ]),\n              ]),\n            ),\n          )\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  private createLogCheckpoint = (\n    rpcLog: RpcLog,\n    block: RpcBlock,\n    chainId: number,\n  ) => {\n    if (block.number === null) {\n      throw new Error(\"Number is missing from RPC block\");\n    }\n    if (rpcLog.transactionIndex === null) {\n      throw new Error(\"Transaction index is missing from RPC log\");\n    }\n    if (rpcLog.logIndex === null) {\n      throw new Error(\"Log index is missing from RPC log\");\n    }\n    return encodeCheckpoint({\n      blockTimestamp: Number(BigInt(block.timestamp)),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: hexToBigInt(rpcLog.transactionIndex),\n      eventType: EVENT_TYPES.logs,\n      eventIndex: hexToBigInt(rpcLog.logIndex),\n    });\n  };\n\n  private createBlockCheckpoint = (block: RpcBlock, chainId: number) => {\n    if (block.number === null) {\n      throw new Error(\"Number is missing from RPC block\");\n    }\n\n    return encodeCheckpoint({\n      blockTimestamp: hexToNumber(block.timestamp),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: maxCheckpoint.transactionIndex,\n      eventType: EVENT_TYPES.blocks,\n      eventIndex: zeroCheckpoint.eventIndex,\n    });\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    traces: rpcTraces,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    traces: SyncCallTrace[];\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeBlock\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) =>\n              oc.column(\"hash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) =>\n              oc.column(\"transactionHash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                contractAddress: eb.ref(\"excluded.contractAddress\"),\n                cumulativeGasUsed: eb.ref(\"excluded.cumulativeGasUsed\"),\n                effectiveGasPrice: eb.ref(\"excluded.effectiveGasPrice\"),\n                gasUsed: eb.ref(\"excluded.gasUsed\"),\n                logs: eb.ref(\"excluded.logs\"),\n                logsBloom: eb.ref(\"excluded.logsBloom\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTraces.length > 0) {\n          const traces = rpcTraces\n            .map((trace, i) => ({\n              ...rpcToPostgresTrace(trace),\n              chainId,\n              checkpoint: encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: hexToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              }),\n            }))\n            .sort((a, b) => {\n              if (a.transactionHash < b.transactionHash) return -1;\n              if (a.transactionHash > b.transactionHash) return 1;\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      });\n    });\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factoryLogFilters,\n    traceFilters,\n    factoryTraceFilters,\n    blockFilters,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    traceFilters: CallTraceFilterCriteria[];\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [\n            ...logFilters,\n            ...factoryLogFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n            ...factoryTraceFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n          ],\n          interval,\n        });\n\n        await this._insertFactoryLogFilterInterval({\n          tx,\n          chainId,\n          factoryLogFilters,\n          interval,\n        });\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters,\n          interval,\n        });\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters,\n          interval,\n        });\n\n        await this._insertFactoryTraceFilterInterval({\n          tx,\n          chainId,\n          factoryTraceFilters,\n          interval,\n        });\n      });\n    });\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    return this.db.wrap({ method: \"deleteRealtimeData\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n      });\n    });\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({ logFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factoryLogFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryLogFilters.flatMap((factory) =>\n      buildFactoryLogFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryLogFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({ factoryId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertBlockFilterInterval = async ({\n    tx,\n    chainId,\n    blockFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const blockFilterFragments = blockFilters.map((blockFilter) => {\n      return {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n    });\n\n    await Promise.all(\n      blockFilterFragments.map(async (blockFilterFragment) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(blockFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(blockFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"blockFilterIntervals\")\n          .values({ blockFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertTraceFilterInterval = async ({\n    tx,\n    chainId,\n    traceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    traceFilters: CallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const traceFilterFragments = traceFilters.flatMap((traceFilter) =>\n      buildTraceFragments({ ...traceFilter, chainId }),\n    );\n\n    await Promise.all(\n      traceFilterFragments.map(async (traceFilterFragment) => {\n        const { id: traceFilterId } = await tx\n          .insertInto(\"traceFilters\")\n          .values(traceFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(traceFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"traceFilterIntervals\")\n          .values({ traceFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryTraceFilterInterval = async ({\n    tx,\n    chainId,\n    factoryTraceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryTraceFilters.flatMap((factory) =>\n      buildFactoryTraceFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryTraceFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryTraceFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock,\n            endBlock,\n          })\n          .execute();\n      }),\n    );\n  };\n\n  insertRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n    result,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n    result: string;\n  }) => {\n    return this.db.wrap({ method: \"insertRpcRequestResult\" }, async () => {\n      await this.db\n        .insertInto(\"rpcRequestResults\")\n        .values({ request, blockNumber, chainId, result })\n        .onConflict((oc) =>\n          oc.constraint(\"rpcRequestResultPrimaryKey\").doUpdateSet({ result }),\n        )\n        .execute();\n    });\n  };\n\n  getRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n  }) => {\n    return this.db.wrap({ method: \"getRpcRequestResult\" }, async () => {\n      const contractReadResult = await this.db\n        .selectFrom(\"rpcRequestResults\")\n        .selectAll()\n        .where(\"request\", \"=\", request)\n        .where(\"blockNumber\", \"=\", blockNumber)\n        .where(\"chainId\", \"=\", chainId)\n        .executeTakeFirst();\n\n      return contractReadResult ?? null;\n    });\n  };\n\n  async *getEvents({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n    limit,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n    limit: number;\n  }) {\n    let cursor = encodeCheckpoint(fromCheckpoint);\n    const encodedToCheckpoint = encodeCheckpoint(toCheckpoint);\n\n    const sourcesById = sources.reduce<{\n      [sourceId: string]: (typeof sources)[number];\n    }>((acc, cur) => {\n      acc[cur.id] = cur;\n      return acc;\n    }, {});\n\n    // We can assume that source won't be empty.\n    const logSources = sources.filter(\n      (s): s is LogSource | FactoryLogSource =>\n        sourceIsLog(s) || sourceIsFactoryLog(s),\n    );\n    const callTraceSources = sources.filter(\n      (s): s is CallTraceSource | FactoryCallTraceSource =>\n        sourceIsCallTrace(s) || sourceIsFactoryCallTrace(s),\n    );\n    const blockSources = sources.filter(sourceIsBlock);\n\n    const shouldJoinLogs = logSources.length !== 0;\n    const shouldJoinTransactions =\n      logSources.length !== 0 || callTraceSources.length !== 0;\n    const shouldJoinTraces = callTraceSources.length !== 0;\n    const shouldJoinReceipts =\n      logSources.some((source) => source.criteria.includeTransactionReceipts) ||\n      callTraceSources.some(\n        (source) => source.criteria.includeTransactionReceipts,\n      );\n\n    while (true) {\n      const events = await this.db.wrap({ method: \"getEvents\" }, async () => {\n        // Get full log objects, including the eventSelector clause.\n        const requestedLogs = await this.db\n          .with(\n            \"log_sources(source_id)\",\n            () =>\n              sql`( values ${\n                logSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      logSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"block_sources(source_id)\",\n            () =>\n              sql`( values ${\n                blockSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      blockSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"call_trace_sources(source_id)\",\n            () =>\n              sql`( values ${\n                callTraceSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      callTraceSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\"log_checkpoints\", (db) =>\n            db\n              .selectFrom(\"logs\")\n              .where(\"logs.checkpoint\", \">\", cursor)\n              .where(\"logs.checkpoint\", \"<=\", encodedToCheckpoint)\n              .orderBy(\"logs.checkpoint\", \"asc\")\n              .limit(limit)\n              .select(\"logs.checkpoint\"),\n          )\n          .with(\"block_checkpoints\", (db) =>\n            db\n              .selectFrom(\"blocks\")\n              .where(\"blocks.checkpoint\", \">\", cursor)\n              .where(\"blocks.checkpoint\", \"<=\", encodedToCheckpoint)\n              .orderBy(\"blocks.checkpoint\", \"asc\")\n              .limit(limit)\n              .select(\"blocks.checkpoint\"),\n          )\n          .with(\"call_trace_checkpoints\", (db) =>\n            db\n              .selectFrom(\"callTraces\")\n              .where(\"callTraces.checkpoint\", \">\", cursor)\n              .where(\"callTraces.checkpoint\", \"<=\", encodedToCheckpoint)\n              .orderBy(\"callTraces.checkpoint\", \"asc\")\n              .limit(limit)\n              .select(\"callTraces.checkpoint\"),\n          )\n          .with(\"max_checkpoint\", (db) =>\n            db\n              .selectFrom(\n                db\n                  .selectFrom(\"log_checkpoints\")\n                  .select(\"checkpoint\")\n                  .unionAll(\n                    db.selectFrom(\"block_checkpoints\").select(\"checkpoint\"),\n                  )\n                  .unionAll(\n                    db\n                      .selectFrom(\"call_trace_checkpoints\")\n                      .select(\"checkpoint\"),\n                  )\n                  .as(\"all_checkpoints\"),\n              )\n              .select(\n                sql`COALESCE(max(checkpoint), ${encodedToCheckpoint})`.as(\n                  \"max_checkpoint\",\n                ),\n              ),\n          )\n          .with(\"events\", (db) =>\n            db\n              .selectFrom(\"logs\")\n              .innerJoin(\"log_sources\", (join) => join.onTrue())\n              .where((eb) => {\n                const logFilterCmprs = sources\n                  .filter(sourceIsLog)\n                  .map((logFilter) => {\n                    const exprs = this.buildLogFilterCmprs({\n                      eb,\n                      logFilter,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n                    return eb.and(exprs);\n                  });\n\n                const factoryCmprs = sources\n                  .filter(sourceIsFactoryLog)\n                  .map((factory) => {\n                    const exprs = this.buildFactoryLogFilterCmprs({\n                      eb,\n                      factory,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", factory.id));\n                    return eb.and(exprs);\n                  });\n\n                return eb.or([...logFilterCmprs, ...factoryCmprs]);\n              })\n              .select([\n                \"source_id\",\n                \"checkpoint\",\n                \"blockHash\",\n                \"transactionHash\",\n\n                \"logs.id as log_id\",\n                sql`null`.as(\"callTrace_id\"),\n              ])\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"blocks\")\n                  .innerJoin(\"block_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const exprs = [];\n                    for (const blockSource of blockSources) {\n                      exprs.push(\n                        eb.and([\n                          eb(\"chainId\", \"=\", blockSource.chainId),\n                          eb(\"number\", \">=\", BigInt(blockSource.startBlock)),\n                          ...(blockSource.endBlock !== undefined\n                            ? [eb(\"number\", \"<=\", BigInt(blockSource.endBlock))]\n                            : []),\n                          sql`(number - ${sql.val(\n                            blockSource.criteria.offset,\n                          )}) % ${sql.val(blockSource.criteria.interval)} = 0`,\n                          eb(\"source_id\", \"=\", blockSource.id),\n                        ]),\n                      );\n                    }\n                    return eb.or(exprs);\n                  })\n                  .select([\n                    \"block_sources.source_id\",\n                    \"checkpoint\",\n                    \"hash as blockHash\",\n                    sql`null`.as(\"transactionHash\"),\n\n                    sql`null`.as(\"log_id\"),\n                    sql`null`.as(\"callTrace_id\"),\n                  ]),\n              )\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"callTraces\")\n                  .innerJoin(\"call_trace_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const traceFilterCmprs = sources\n                      .filter(sourceIsCallTrace)\n                      .map((callTraceSource) => {\n                        const exprs = this.buildTraceFilterCmprs({\n                          eb,\n                          callTraceSource,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", callTraceSource.id));\n                        return eb.and(exprs);\n                      });\n                    const factoryTraceFilterCmprs = sources\n                      .filter(sourceIsFactoryCallTrace)\n                      .map((factory) => {\n                        const exprs = this.buildFactoryTraceFilterCmprs({\n                          eb,\n                          factory,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", factory.id));\n                        return eb.and(exprs);\n                      });\n\n                    return eb.or([\n                      ...traceFilterCmprs,\n                      ...factoryTraceFilterCmprs,\n                    ]);\n                  })\n\n                  .select([\n                    \"source_id\",\n                    \"checkpoint\",\n                    \"blockHash\",\n                    \"transactionHash\",\n\n                    sql`null`.as(\"log_id\"),\n                    \"callTraces.id as callTrace_id\",\n                  ]),\n              ),\n          )\n          .selectFrom(\"events\")\n          .innerJoin(\"blocks\", \"blocks.hash\", \"events.blockHash\")\n          .select([\n            \"events.source_id\",\n            \"events.checkpoint\",\n\n            \"blocks.baseFeePerGas as block_baseFeePerGas\",\n            \"blocks.difficulty as block_difficulty\",\n            \"blocks.extraData as block_extraData\",\n            \"blocks.gasLimit as block_gasLimit\",\n            \"blocks.gasUsed as block_gasUsed\",\n            \"blocks.hash as block_hash\",\n            \"blocks.logsBloom as block_logsBloom\",\n            \"blocks.miner as block_miner\",\n            \"blocks.mixHash as block_mixHash\",\n            \"blocks.nonce as block_nonce\",\n            \"blocks.number as block_number\",\n            \"blocks.parentHash as block_parentHash\",\n            \"blocks.receiptsRoot as block_receiptsRoot\",\n            \"blocks.sha3Uncles as block_sha3Uncles\",\n            \"blocks.size as block_size\",\n            \"blocks.stateRoot as block_stateRoot\",\n            \"blocks.timestamp as block_timestamp\",\n            \"blocks.totalDifficulty as block_totalDifficulty\",\n            \"blocks.transactionsRoot as block_transactionsRoot\",\n          ])\n          .$if(shouldJoinLogs, (qb) =>\n            qb\n              .leftJoin(\"logs\", \"logs.id\", \"events.log_id\")\n              .select([\n                \"logs.address as log_address\",\n                \"logs.blockHash as log_blockHash\",\n                \"logs.blockNumber as log_blockNumber\",\n                \"logs.chainId as log_chainId\",\n                \"logs.data as log_data\",\n                \"logs.id as log_id\",\n                \"logs.logIndex as log_logIndex\",\n                \"logs.topic0 as log_topic0\",\n                \"logs.topic1 as log_topic1\",\n                \"logs.topic2 as log_topic2\",\n                \"logs.topic3 as log_topic3\",\n                \"logs.transactionHash as log_transactionHash\",\n                \"logs.transactionIndex as log_transactionIndex\",\n              ]),\n          )\n          .$if(shouldJoinTransactions, (qb) =>\n            qb\n              .leftJoin(\n                \"transactions\",\n                \"transactions.hash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactions.accessList as tx_accessList\",\n                \"transactions.blockHash as tx_blockHash\",\n                \"transactions.blockNumber as tx_blockNumber\",\n                \"transactions.from as tx_from\",\n                \"transactions.gas as tx_gas\",\n                \"transactions.gasPrice as tx_gasPrice\",\n                \"transactions.hash as tx_hash\",\n                \"transactions.input as tx_input\",\n                \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n                \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n                \"transactions.nonce as tx_nonce\",\n                \"transactions.r as tx_r\",\n                \"transactions.s as tx_s\",\n                \"transactions.to as tx_to\",\n                \"transactions.transactionIndex as tx_transactionIndex\",\n                \"transactions.type as tx_type\",\n                \"transactions.value as tx_value\",\n                \"transactions.v as tx_v\",\n              ]),\n          )\n          .$if(shouldJoinTraces, (qb) =>\n            qb\n              .leftJoin(\"callTraces\", \"callTraces.id\", \"events.callTrace_id\")\n              .select([\n                \"callTraces.id as callTrace_id\",\n                \"callTraces.callType as callTrace_callType\",\n                \"callTraces.from as callTrace_from\",\n                \"callTraces.gas as callTrace_gas\",\n                \"callTraces.input as callTrace_input\",\n                \"callTraces.to as callTrace_to\",\n                \"callTraces.value as callTrace_value\",\n                \"callTraces.blockHash as callTrace_blockHash\",\n                \"callTraces.blockNumber as callTrace_blockNumber\",\n                \"callTraces.gasUsed as callTrace_gasUsed\",\n                \"callTraces.output as callTrace_output\",\n                \"callTraces.subtraces as callTrace_subtraces\",\n                \"callTraces.traceAddress as callTrace_traceAddress\",\n                \"callTraces.transactionHash as callTrace_transactionHash\",\n                \"callTraces.transactionPosition as callTrace_transactionPosition\",\n                \"callTraces.chainId as callTrace_chainId\",\n                \"callTraces.checkpoint as callTrace_checkpoint\",\n              ]),\n          )\n          .$if(shouldJoinReceipts, (qb) =>\n            qb\n              .leftJoin(\n                \"transactionReceipts\",\n                \"transactionReceipts.transactionHash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactionReceipts.blockHash as txr_blockHash\",\n                \"transactionReceipts.blockNumber as txr_blockNumber\",\n                \"transactionReceipts.contractAddress as txr_contractAddress\",\n                \"transactionReceipts.cumulativeGasUsed as txr_cumulativeGasUsed\",\n                \"transactionReceipts.effectiveGasPrice as txr_effectiveGasPrice\",\n                \"transactionReceipts.from as txr_from\",\n                \"transactionReceipts.gasUsed as txr_gasUsed\",\n                \"transactionReceipts.logs as txr_logs\",\n                \"transactionReceipts.logsBloom as txr_logsBloom\",\n                \"transactionReceipts.status as txr_status\",\n                \"transactionReceipts.to as txr_to\",\n                \"transactionReceipts.transactionHash as txr_transactionHash\",\n                \"transactionReceipts.transactionIndex as txr_transactionIndex\",\n                \"transactionReceipts.type as txr_type\",\n              ]),\n          )\n          .where(\"events.checkpoint\", \">\", cursor)\n          .where(\n            \"events.checkpoint\",\n            \"<=\",\n            // Get max checkpoint from all sources\n            sql`(\n              select max_checkpoint\n              from max_checkpoint\n            )`,\n          )\n          .orderBy(\"events.checkpoint\", \"asc\")\n          .limit(limit + 1)\n          .execute();\n\n        return requestedLogs.map((_row) => {\n          // Without this cast, the block_ and tx_ fields are all nullable\n          // which makes this very annoying. Should probably add a runtime check\n          // that those fields are indeed present before continuing here.\n          const row = _row as NonNull<(typeof requestedLogs)[number]>;\n\n          const source = sourcesById[row.source_id];\n\n          const shouldIncludeLog =\n            sourceIsLog(source) || sourceIsFactoryLog(source);\n          const shouldIncludeTransaction =\n            sourceIsLog(source) ||\n            sourceIsFactoryLog(source) ||\n            sourceIsCallTrace(source) ||\n            sourceIsFactoryCallTrace(source);\n          const shouldIncludeTrace =\n            sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source);\n          const shouldIncludeTransactionReceipt =\n            (sourceIsLog(source) &&\n              source.criteria.includeTransactionReceipts) ||\n            (sourceIsFactoryLog(source) &&\n              source.criteria.includeTransactionReceipts);\n          return {\n            chainId: source.chainId,\n            sourceId: row.source_id,\n            encodedCheckpoint: row.checkpoint,\n            log: shouldIncludeLog\n              ? {\n                  address: checksumAddress(row.log_address),\n                  blockHash: row.log_blockHash,\n                  blockNumber: row.log_blockNumber,\n                  data: row.log_data,\n                  id: row.log_id as Log[\"id\"],\n                  logIndex: Number(row.log_logIndex),\n                  removed: false,\n                  topics: [\n                    row.log_topic0,\n                    row.log_topic1,\n                    row.log_topic2,\n                    row.log_topic3,\n                  ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n                  transactionHash: row.log_transactionHash,\n                  transactionIndex: Number(row.log_transactionIndex),\n                }\n              : undefined,\n            block: {\n              baseFeePerGas: row.block_baseFeePerGas,\n              difficulty: row.block_difficulty,\n              extraData: row.block_extraData,\n              gasLimit: row.block_gasLimit,\n              gasUsed: row.block_gasUsed,\n              hash: row.block_hash,\n              logsBloom: row.block_logsBloom,\n              miner: checksumAddress(row.block_miner),\n              mixHash: row.block_mixHash,\n              nonce: row.block_nonce,\n              number: row.block_number,\n              parentHash: row.block_parentHash,\n              receiptsRoot: row.block_receiptsRoot,\n              sha3Uncles: row.block_sha3Uncles,\n              size: row.block_size,\n              stateRoot: row.block_stateRoot,\n              timestamp: row.block_timestamp,\n              totalDifficulty: row.block_totalDifficulty,\n              transactionsRoot: row.block_transactionsRoot,\n            },\n            transaction: shouldIncludeTransaction\n              ? {\n                  blockHash: row.tx_blockHash,\n                  blockNumber: row.tx_blockNumber,\n                  from: checksumAddress(row.tx_from),\n                  gas: row.tx_gas,\n                  hash: row.tx_hash,\n                  input: row.tx_input,\n                  nonce: Number(row.tx_nonce),\n                  r: row.tx_r,\n                  s: row.tx_s,\n                  to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n                  transactionIndex: Number(row.tx_transactionIndex),\n                  value: row.tx_value,\n                  v: row.tx_v,\n                  ...(row.tx_type === \"0x0\"\n                    ? { type: \"legacy\", gasPrice: row.tx_gasPrice }\n                    : row.tx_type === \"0x1\"\n                      ? {\n                          type: \"eip2930\",\n                          gasPrice: row.tx_gasPrice,\n                          accessList: JSON.parse(row.tx_accessList),\n                        }\n                      : row.tx_type === \"0x2\"\n                        ? {\n                            type: \"eip1559\",\n                            maxFeePerGas: row.tx_maxFeePerGas,\n                            maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas,\n                          }\n                        : row.tx_type === \"0x7e\"\n                          ? {\n                              type: \"deposit\",\n                              maxFeePerGas: row.tx_maxFeePerGas ?? undefined,\n                              maxPriorityFeePerGas:\n                                row.tx_maxPriorityFeePerGas ?? undefined,\n                            }\n                          : { type: row.tx_type }),\n                }\n              : undefined,\n            trace: shouldIncludeTrace\n              ? {\n                  id: row.callTrace_id,\n                  from: checksumAddress(row.callTrace_from),\n                  to: checksumAddress(row.callTrace_to),\n                  gas: row.callTrace_gas,\n                  value: row.callTrace_value,\n                  input: row.callTrace_input,\n                  output: row.callTrace_output,\n                  gasUsed: row.callTrace_gasUsed,\n                  subtraces: row.callTrace_subtraces,\n                  traceAddress: JSON.parse(row.callTrace_traceAddress),\n                  blockHash: row.callTrace_blockHash,\n                  blockNumber: row.callTrace_blockNumber,\n                  transactionHash: row.callTrace_transactionHash,\n                  transactionIndex: row.callTrace_transactionPosition,\n                  callType: row.callTrace_callType as CallTrace[\"callType\"],\n                }\n              : undefined,\n            transactionReceipt: shouldIncludeTransactionReceipt\n              ? {\n                  blockHash: row.txr_blockHash,\n                  blockNumber: row.txr_blockNumber,\n                  contractAddress: row.txr_contractAddress\n                    ? checksumAddress(row.txr_contractAddress)\n                    : null,\n                  cumulativeGasUsed: row.txr_cumulativeGasUsed,\n                  effectiveGasPrice: row.txr_effectiveGasPrice,\n                  from: checksumAddress(row.txr_from),\n                  gasUsed: row.txr_gasUsed,\n                  logs: JSON.parse(row.txr_logs).map((log: SyncLog) => ({\n                    address: checksumAddress(log.address),\n                    blockHash: log.blockHash,\n                    blockNumber: hexToBigInt(log.blockNumber),\n                    data: log.data,\n                    logIndex: hexToNumber(log.logIndex),\n                    removed: false,\n                    topics: [\n                      log.topics[0] ?? null,\n                      log.topics[1] ?? null,\n                      log.topics[2] ?? null,\n                      log.topics[3] ?? null,\n                    ].filter((t): t is Hex => t !== null) as\n                      | [Hex, ...Hex[]]\n                      | [],\n                    transactionHash: log.transactionHash,\n                    transactionIndex: hexToNumber(log.transactionIndex),\n                  })),\n                  logsBloom: row.txr_logsBloom,\n                  status:\n                    row.txr_status === \"0x1\"\n                      ? \"success\"\n                      : row.txr_status === \"0x0\"\n                        ? \"reverted\"\n                        : (row.txr_status as TransactionReceipt[\"status\"]),\n                  to: row.txr_to ? checksumAddress(row.txr_to) : null,\n                  transactionHash: row.txr_transactionHash,\n                  transactionIndex: Number(row.txr_transactionIndex),\n                  type:\n                    row.txr_type === \"0x0\"\n                      ? \"legacy\"\n                      : row.txr_type === \"0x1\"\n                        ? \"eip2930\"\n                        : row.tx_type === \"0x2\"\n                          ? \"eip1559\"\n                          : row.tx_type === \"0x7e\"\n                            ? \"deposit\"\n                            : row.tx_type,\n                }\n              : undefined,\n          } satisfies RawEvent;\n        });\n      });\n\n      const hasNextPage = events.length === limit + 1;\n\n      if (!hasNextPage) {\n        yield events;\n        break;\n      } else {\n        events.pop();\n        cursor = events[events.length - 1].encodedCheckpoint;\n        yield events;\n      }\n    }\n  }\n\n  async getLastEventCheckpoint({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n  }): Promise<Checkpoint | undefined> {\n    return this.db.wrap({ method: \"getLastEventCheckpoint\" }, async () => {\n      const checkpoint = await this.db\n        .selectFrom(\"logs\")\n        .where((eb) => {\n          const logFilterCmprs = sources\n            .filter(sourceIsLog)\n            .map((logFilter) => {\n              const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n              return eb.and(exprs);\n            });\n\n          const factoryCmprs = sources\n            .filter(sourceIsFactoryLog)\n            .map((factory) => {\n              const exprs = this.buildFactoryLogFilterCmprs({ eb, factory });\n              return eb.and(exprs);\n            });\n\n          return eb.or([...logFilterCmprs, ...factoryCmprs]);\n        })\n        .select(\"checkpoint\")\n        .unionAll(\n          this.db\n            .selectFrom(\"blocks\")\n            .where((eb) => {\n              const exprs = [];\n              const blockFilters = sources.filter(sourceIsBlock);\n              for (const blockFilter of blockFilters) {\n                exprs.push(\n                  eb.and([\n                    eb(\"chainId\", \"=\", blockFilter.chainId),\n                    eb(\"number\", \">=\", BigInt(blockFilter.startBlock)),\n                    ...(blockFilter.endBlock !== undefined\n                      ? [eb(\"number\", \"<=\", BigInt(blockFilter.endBlock))]\n                      : []),\n                    sql`(number - ${sql.val(\n                      BigInt(blockFilter.criteria.offset),\n                    )}) % ${sql.val(\n                      BigInt(blockFilter.criteria.interval),\n                    )} = 0`,\n                  ]),\n                );\n              }\n              return eb.or(exprs);\n            })\n            .select(\"checkpoint\"),\n        )\n        .unionAll(\n          this.db\n            .selectFrom(\"callTraces\")\n            .where((eb) => {\n              const traceFilterCmprs = sources\n                .filter(sourceIsCallTrace)\n                .map((callTraceSource) => {\n                  const exprs = this.buildTraceFilterCmprs({\n                    eb,\n                    callTraceSource,\n                  });\n                  return eb.and(exprs);\n                });\n\n              const factoryCallTraceCmprs = sources\n                .filter(sourceIsFactoryCallTrace)\n                .map((factory) => {\n                  const exprs = this.buildFactoryTraceFilterCmprs({\n                    eb,\n                    factory,\n                  });\n                  return eb.and(exprs);\n                });\n\n              return eb.or([...traceFilterCmprs, ...factoryCallTraceCmprs]);\n            })\n            .select(\"checkpoint\"),\n        )\n        .where(\"checkpoint\", \">\", encodeCheckpoint(fromCheckpoint))\n        .where(\"checkpoint\", \"<=\", encodeCheckpoint(toCheckpoint))\n        .orderBy(\"checkpoint\", \"desc\")\n        .executeTakeFirst();\n\n      return checkpoint\n        ? checkpoint.checkpoint\n          ? decodeCheckpoint(checkpoint.checkpoint)\n          : undefined\n        : undefined;\n    });\n  }\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: LogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(logFilter.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.startBlock !== undefined && logFilter.startBlock !== 0)\n      exprs.push(eb(\"logs.blockNumber\", \">=\", BigInt(logFilter.startBlock)));\n    if (logFilter.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", BigInt(logFilter.endBlock)));\n\n    return exprs;\n  };\n\n  private buildFactoryLogFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryLogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(factory.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = factory.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(eb(\"logs.blockNumber\", \">=\", BigInt(factory.startBlock)));\n    if (factory.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", BigInt(factory.endBlock)));\n\n    return exprs;\n  };\n\n  private buildTraceFilterCmprs = ({\n    eb,\n    callTraceSource,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    callTraceSource: CallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"callTraces.chainId\",\n        \"=\",\n        sql`cast (${sql.val(callTraceSource.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    if (callTraceSource.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(callTraceSource.criteria.fromAddress) &&\n        callTraceSource.criteria.fromAddress.length === 1\n          ? callTraceSource.criteria.fromAddress[0]\n          : callTraceSource.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    if (callTraceSource.criteria.toAddress) {\n      // If it's an array of length 1, collapse it.\n      const toAddress =\n        Array.isArray(callTraceSource.criteria.toAddress) &&\n        callTraceSource.criteria.toAddress.length === 1\n          ? callTraceSource.criteria.toAddress[0]\n          : callTraceSource.criteria.toAddress;\n      if (Array.isArray(toAddress)) {\n        exprs.push(eb.or(toAddress.map((a) => eb(\"callTraces.to\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"callTraces.to\", \"=\", toAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        callTraceSource.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (\n      callTraceSource.startBlock !== undefined &&\n      callTraceSource.startBlock !== 0\n    )\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", BigInt(callTraceSource.startBlock)),\n      );\n    if (callTraceSource.endBlock)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \"<=\", BigInt(callTraceSource.endBlock)),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryTraceFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryCallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"callTraces.chainId\",\n        \"=\",\n        sql`cast (${sql.val(factory.chainId)} as numeric(16, 0))`,\n      ),\n    );\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"callTraces.to\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(factory.criteria.fromAddress) &&\n        factory.criteria.fromAddress.length === 1\n          ? factory.criteria.fromAddress[0]\n          : factory.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        factory.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", BigInt(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(eb(\"callTraces.blockNumber\", \"<=\", BigInt(factory.endBlock)));\n\n    return exprs;\n  };\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryLogFilterCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data from ${start}::int for ${length}::int)`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(\n      childAddressLocation,\n    )} from ${start}::integer for ${length}::integer)`;\n  }\n}\n","import type { SyncCallTrace } from \"@/sync/index.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { Generated, Insertable } from \"kysely\";\nimport {\n  type Address,\n  type Hash,\n  type Hex,\n  type RpcTransactionReceipt,\n  hexToBigInt,\n} from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\ntype BlocksTable = {\n  baseFeePerGas: bigint | null;\n  difficulty: bigint;\n  extraData: Hex;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: bigint;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash | null;\n  size: bigint;\n  stateRoot: Hash;\n  timestamp: bigint;\n  totalDifficulty: bigint | null;\n  transactionsRoot: Hash;\n\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToPostgresBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\" | \"checkpoint\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    difficulty: BigInt(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: BigInt(block.gasLimit),\n    gasUsed: BigInt(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: BigInt(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles ?? null,\n    size: BigInt(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: BigInt(block.timestamp),\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: bigint;\n  from: Address;\n  gas: bigint;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex | null;\n  s: Hex | null;\n  to: Address | null;\n  transactionIndex: number;\n  v: bigint | null;\n  value: bigint;\n\n  type: Hex;\n  gasPrice: bigint | null;\n  maxFeePerGas: bigint | null;\n  maxPriorityFeePerGas: bigint | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToPostgresTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: BigInt(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: BigInt(transaction.gas),\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r ?? null,\n    s: transaction.s ?? null,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: BigInt(transaction.value),\n    v: transaction.v ? BigInt(transaction.v) : null,\n  };\n}\n\ntype TransactionReceiptsTable = {\n  blockHash: Hash;\n  blockNumber: bigint;\n  contractAddress: Address | null;\n  cumulativeGasUsed: bigint;\n  effectiveGasPrice: bigint;\n  from: Address;\n  gasUsed: bigint;\n  logs: string;\n  logsBloom: Hex;\n  status: Hex;\n  to: Address | null;\n  transactionHash: Hash;\n  transactionIndex: number;\n  type: Hex;\n\n  chainId: number;\n};\n\nexport type InsertableTransactionReceipts =\n  Insertable<TransactionReceiptsTable>;\n\nexport function rpcToPostgresTransactionReceipt(\n  transactionReceipt: RpcTransactionReceipt,\n): Omit<TransactionReceiptsTable, \"chainId\"> {\n  return {\n    blockHash: transactionReceipt.blockHash,\n    blockNumber: BigInt(transactionReceipt.blockNumber),\n    contractAddress: transactionReceipt.contractAddress\n      ? toLowerCase(transactionReceipt.contractAddress)\n      : null,\n    cumulativeGasUsed: BigInt(transactionReceipt.cumulativeGasUsed),\n    effectiveGasPrice: BigInt(transactionReceipt.effectiveGasPrice),\n    from: toLowerCase(transactionReceipt.from),\n    gasUsed: BigInt(transactionReceipt.gasUsed),\n    logs: JSON.stringify(transactionReceipt.logs),\n    logsBloom: transactionReceipt.logsBloom,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,\n    transactionHash: transactionReceipt.transactionHash,\n    transactionIndex: Number(transactionReceipt.transactionIndex),\n    type: transactionReceipt.type as Hex,\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: bigint;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n  checkpoint?: string;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToPostgresLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: BigInt(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype CallTracesTable = {\n  id: string;\n  callType: string;\n  from: Address;\n  gas: bigint;\n  input: Hex;\n  to: Address;\n  value: bigint;\n  blockHash: Hex;\n  blockNumber: bigint;\n  error: string | null;\n  gasUsed: bigint | null;\n  output: Hex | null;\n  subtraces: number;\n  traceAddress: string;\n  transactionHash: Hex;\n  transactionPosition: number;\n  functionSelector: Hex;\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableCallTrace = Insertable<CallTracesTable>;\n\nexport function rpcToPostgresTrace(\n  trace: SyncCallTrace,\n): Omit<InsertableCallTrace, \"chainId\" | \"checkpoint\"> {\n  return {\n    id: `${trace.transactionHash}-${JSON.stringify(trace.traceAddress)}`,\n    callType: trace.action.callType,\n    from: toLowerCase(trace.action.from),\n    gas: hexToBigInt(trace.action.gas),\n    input: trace.action.input,\n    to: toLowerCase(trace.action.to),\n    value: hexToBigInt(trace.action.value),\n    blockHash: trace.blockHash,\n    blockNumber: hexToBigInt(trace.blockNumber),\n    error: trace.error ?? null,\n    gasUsed: trace.result ? hexToBigInt(trace.result.gasUsed) : null,\n    output: trace.result ? trace.result.output : null,\n    subtraces: trace.subtraces,\n    traceAddress: JSON.stringify(trace.traceAddress),\n    transactionHash: trace.transactionHash,\n    transactionPosition: trace.transactionPosition,\n    functionSelector: trace.action.input.slice(0, 10).toLowerCase() as Hex,\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: bigint;\n  chainId: number;\n  request: string;\n  result: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype FactoryLogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype TraceFiltersTable = {\n  id: string;\n  chainId: number;\n  fromAddress: Address | null;\n  toAddress: Address | null;\n};\n\ntype TraceFilterIntervalsTable = {\n  id: Generated<number>;\n  traceFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype FactoryTraceFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  fromAddress: Address | null;\n};\n\ntype FactoryTraceFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype BlockFiltersTable = {\n  id: string;\n  chainId: number;\n  interval: number;\n  offset: number;\n};\n\ntype BlockFilterIntervalsTable = {\n  id: Generated<number>;\n  blockFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  transactionReceipts: TransactionReceiptsTable;\n  logs: LogsTable;\n  callTraces: CallTracesTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factoryLogFilters: FactoryLogFiltersTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n  traceFilters: TraceFiltersTable;\n  traceFilterIntervals: TraceFilterIntervalsTable;\n  factoryTraceFilters: FactoryTraceFiltersTable;\n  factoryTraceFilterIntervals: FactoryTraceFilterIntervalsTable;\n  blockFilters: BlockFiltersTable;\n  blockFilterIntervals: BlockFilterIntervalsTable;\n};\n","import {\n  type BlockFilterCriteria,\n  type CallTraceFilterCriteria,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceFilterCriteria,\n  type FactoryCallTraceSource,\n  type FactoryLogFilterCriteria,\n  type FactoryLogSource,\n  type LogFilterCriteria,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { SyncCallTrace, SyncLog } from \"@/sync/index.js\";\nimport type { CallTrace, Log } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport {\n  type Checkpoint,\n  EVENT_TYPES,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport {\n  buildFactoryLogFragments,\n  buildFactoryTraceFragments,\n  buildLogFilterFragments,\n  buildTraceFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport {\n  type ExpressionBuilder,\n  type OperandExpression,\n  type SqlBool,\n  type Transaction as KyselyTransaction,\n  sql,\n} from \"kysely\";\nimport {\n  type Hex,\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  type RpcTransactionReceipt,\n  type TransactionReceipt,\n  checksumAddress,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport type { RawEvent, SyncStore } from \"../store.js\";\nimport {\n  type InsertableCallTrace,\n  rpcToSqliteTrace,\n  rpcToSqliteTransactionReceipt,\n} from \"./encoding.js\";\nimport {\n  type SyncStoreTables,\n  rpcToSqliteBlock,\n  rpcToSqliteLog,\n  rpcToSqliteTransaction,\n} from \"./encoding.js\";\n\nexport class SqliteSyncStore implements SyncStore {\n  kind = \"sqlite\" as const;\n  db: HeadlessKysely<SyncStoreTables>;\n\n  constructor({ db }: { db: HeadlessKysely<SyncStoreTables> }) {\n    this.db = db;\n  }\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertLogFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((rpcTransaction) => ({\n            ...rpcToSqliteTransaction(rpcTransaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [logFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getLogFilterIntervals\" }, async () => {\n      const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await Promise.all(\n        fragments.map(async (fragment) => {\n          return await this.db.transaction().execute(async (tx) => {\n            const { id: logFilterId } = await tx\n              .insertInto(\"logFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            const existingIntervalRows = await tx\n              .deleteFrom(\"logFilterIntervals\")\n              .where(\"logFilterId\", \"=\", logFilterId)\n              .returningAll()\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervalRows.map((i) => [\n                Number(decodeToBigInt(i.startBlock)),\n                Number(decodeToBigInt(i.endBlock)),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                logFilterId,\n                startBlock: encodeAsText(startBlock),\n                endBlock: encodeAsText(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"logFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n          });\n        }),\n      );\n\n      const intervals = await this.db\n        .with(\n          \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                    f.topic0,\n                  )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                    f.topic3,\n                  )}, ${sql.lit(f.includeTransactionReceipts)} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"logFilterIntervals\")\n        .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n        .innerJoin(\"logFilterFragments\", (join) => {\n          let baseJoin = join.on((eb) =>\n            eb.or([\n              eb(\"address\", \"is\", null),\n              eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            ]),\n          );\n          baseJoin = baseJoin.on((eb) =>\n            eb(\n              \"fragmentIncludeTransactionReceipts\",\n              \"<=\",\n              sql.ref(\"includeTransactionReceipts\"),\n            ),\n          );\n          for (const idx_ of range(0, 4)) {\n            baseJoin = baseJoin.on((eb) => {\n              const idx = idx_ as 0 | 1 | 2 | 3;\n              return eb.or([\n                eb(`topic${idx}`, \"is\", null),\n                eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n              ]);\n            });\n          }\n\n          return baseJoin;\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([\n            Number(decodeToBigInt(startBlock)),\n            Number(decodeToBigInt(endBlock)),\n          ]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryChildAddressLogs\" },\n      async () => {\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n          }));\n          await this.db\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      },\n    );\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    fromBlock,\n    toBlock,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n    toBlock: bigint;\n    factory: FactoryLogFilterCriteria | FactoryCallTraceFilterCriteria;\n    pageSize?: number;\n  }) {\n    const { address, eventSelector, childAddressLocation } = factory;\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({ childAddressLocation });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([\"id\", selectChildAddressExpression.as(\"childAddress\")])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \">=\", encodeAsText(fromBlock))\n      .where(\"blockNumber\", \"<=\", encodeAsText(toBlock))\n      .orderBy(\"id\", \"asc\")\n      .limit(pageSize);\n\n    let cursor: string | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n      if (cursor !== undefined) query = query.where(\"id\", \">\", cursor);\n\n      const batch = await this.db.wrap(\n        { method: \"getFactoryChildAddresses\" },\n        () => query.execute(),\n      );\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      // If the batch is less than the page size, there are no more pages.\n      if (batch.length < pageSize) break;\n      // Otherwise, set the cursor to the last block number in the batch.\n      cursor = batch[batch.length - 1].id;\n    }\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryLogFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToSqliteTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          if (rpcLogs.length > 0) {\n            const logs = rpcLogs.map((rpcLog) => ({\n              ...rpcToSqliteLog(rpcLog),\n              chainId,\n              checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n            }));\n            await tx\n              .insertInto(\"logs\")\n              .values(logs)\n              .onConflict((oc) =>\n                oc.column(\"id\").doUpdateSet((eb) => ({\n                  checkpoint: eb.ref(\"excluded.checkpoint\"),\n                })),\n              )\n              .execute();\n          }\n\n          await this._insertFactoryLogFilterInterval({\n            tx,\n            chainId,\n            factoryLogFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryLogFragments({ ...factory, chainId });\n\n        await Promise.all(\n          fragments.map(async (fragment) => {\n            return await this.db.transaction().execute(async (tx) => {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryLogFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryLogFilterIntervals\")\n                .where(\"factoryId\", \"=\", factoryId)\n                .returningAll()\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(decodeToBigInt(i.startBlock)),\n                  Number(decodeToBigInt(i.endBlock)),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: encodeAsText(startBlock),\n                  endBlock: encodeAsText(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryLogFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n            });\n          }),\n        );\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                      f.topic0,\n                    )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                      f.topic3,\n                    )}, ${sql.lit(f.includeTransactionReceipts)} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryLogFilterIntervals\")\n          .innerJoin(\"factoryLogFilters\", \"factoryId\", \"factoryLogFilters.id\")\n          .innerJoin(\"factoryFilterFragments\", (join) => {\n            let baseJoin = join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n              ]),\n            );\n            baseJoin = baseJoin.on((eb) =>\n              eb(\n                \"fragmentIncludeTransactionReceipts\",\n                \"<=\",\n                sql.ref(\"includeTransactionReceipts\"),\n              ),\n            );\n            for (const idx_ of range(0, 4)) {\n              baseJoin = baseJoin.on((eb) => {\n                const idx = idx_ as 0 | 1 | 2 | 3;\n                return eb.or([\n                  eb(`topic${idx}`, \"is\", null),\n                  eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n                ]);\n              });\n            }\n\n            return baseJoin;\n          })\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertBlockFilterInterval = async ({\n    chainId,\n    blockFilter,\n    block: rpcBlock,\n    interval,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n    block?: RpcBlock;\n    interval: { startBlock: bigint; endBlock: bigint };\n  }): Promise<void> => {\n    return this.db.wrap({ method: \"insertBlockFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        if (rpcBlock !== undefined) {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters: [blockFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getBlockFilterIntervals = async ({\n    chainId,\n    blockFilter,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getBlockFilterIntervals\" }, async () => {\n      const fragment = {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await this.db.transaction().execute(async (tx) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        const existingIntervalRows = await tx\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\"blockFilterId\", \"=\", blockFilterId)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = intervalUnion(\n          existingIntervalRows.map((i) => [\n            Number(decodeToBigInt(i.startBlock)),\n            Number(decodeToBigInt(i.endBlock)),\n          ]),\n        );\n\n        const mergedIntervalRows = mergedIntervals.map(\n          ([startBlock, endBlock]) => ({\n            blockFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          }),\n        );\n\n        if (mergedIntervalRows.length > 0) {\n          await tx\n            .insertInto(\"blockFilterIntervals\")\n            .values(mergedIntervalRows)\n            .execute();\n        }\n      });\n\n      const intervals = await this.db\n        .selectFrom(\"blockFilterIntervals\")\n        .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n        .select([\n          \"blockFilterIntervals.startBlock\",\n          \"blockFilterIntervals.endBlock\",\n        ])\n        .where(\"blockFilterId\", \"=\", fragment.id)\n        .execute();\n\n      return intervals.map(\n        ({ startBlock, endBlock }) =>\n          [Number(startBlock), Number(endBlock)] as [number, number],\n      );\n    });\n  };\n\n  getBlock = async ({\n    chainId,\n    blockNumber,\n  }: {\n    chainId: number;\n    blockNumber: number;\n  }): Promise<boolean> => {\n    const hasBlock = await this.db\n      .selectFrom(\"blocks\")\n      .select(\"hash\")\n      .where(\"number\", \"=\", encodeAsText(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .executeTakeFirst();\n\n    return hasBlock !== undefined;\n  };\n\n  insertTraceFilterInterval = async ({\n    chainId,\n    traceFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertTraceFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToSqliteTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n        // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n        const traceByTransactionHash: {\n          [transactionHash: Hex]: SyncCallTrace[];\n        } = {};\n        for (const trace of rpcTraces) {\n          if (traceByTransactionHash[trace.transactionHash] === undefined) {\n            traceByTransactionHash[trace.transactionHash] = [];\n          }\n          traceByTransactionHash[trace.transactionHash].push(trace);\n        }\n\n        for (const transactionHash of Object.keys(traceByTransactionHash)) {\n          const traces = await tx\n            .deleteFrom(\"callTraces\")\n            .returningAll()\n            .where(\"transactionHash\", \"=\", transactionHash as Hex)\n            .where(\"chainId\", \"=\", chainId)\n            .execute();\n\n          (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n            ...traceByTransactionHash[transactionHash as Hex].map((trace) => ({\n              ...rpcToSqliteTrace(trace),\n              chainId,\n            })),\n          );\n\n          // Use lexographical sort of stringified `traceAddress`.\n          traces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          for (let i = 0; i < traces.length; i++) {\n            const trace = traces[i];\n            const checkpoint = encodeCheckpoint({\n              blockTimestamp: hexToNumber(rpcBlock.timestamp),\n              chainId: BigInt(chainId),\n              blockNumber: decodeToBigInt(trace.blockNumber),\n              transactionIndex: BigInt(trace.transactionPosition),\n              eventType: EVENT_TYPES.callTraces,\n              eventIndex: BigInt(i),\n            });\n\n            trace.checkpoint = checkpoint;\n          }\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.doNothing())\n            .execute();\n        }\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters: [traceFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getTraceFilterIntervals = async ({\n    traceFilter,\n    chainId,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getTraceFilterIntervals\" }, async () => {\n      const fragments = buildTraceFragments({ ...traceFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await Promise.all(\n        fragments.map(async (fragment) => {\n          return await this.db.transaction().execute(async (tx) => {\n            const { id: traceFilterId } = await tx\n              .insertInto(\"traceFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            const existingIntervalRows = await tx\n              .deleteFrom(\"traceFilterIntervals\")\n              .where(\"traceFilterId\", \"=\", traceFilterId)\n              .returningAll()\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervalRows.map((i) => [\n                Number(decodeToBigInt(i.startBlock)),\n                Number(decodeToBigInt(i.endBlock)),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                traceFilterId,\n                startBlock: encodeAsText(startBlock),\n                endBlock: encodeAsText(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"traceFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n          });\n        }),\n      );\n\n      const intervals = await this.db\n        .with(\n          \"traceFilterFragments(fragmentId, fragmentFromAddress, fragmentToAddress)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.fromAddress)}, ${sql.val(\n                    f.toAddress,\n                  )} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"traceFilterIntervals\")\n        .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n        .innerJoin(\"traceFilterFragments\", (join) => {\n          return join.on((eb) =>\n            eb.and([\n              eb.or([\n                eb(\"fromAddress\", \"is\", null),\n                eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n              ]),\n              eb.or([\n                eb(\"toAddress\", \"is\", null),\n                eb(\"fragmentToAddress\", \"=\", sql.ref(\"toAddress\")),\n              ]),\n            ]),\n          );\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryTraceFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryTraceFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToSqliteTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n          // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n          const traceByTransactionHash: {\n            [transactionHash: Hex]: SyncCallTrace[];\n          } = {};\n          for (const trace of rpcTraces) {\n            if (traceByTransactionHash[trace.transactionHash] === undefined) {\n              traceByTransactionHash[trace.transactionHash] = [];\n            }\n            traceByTransactionHash[trace.transactionHash].push(trace);\n          }\n\n          for (const transactionHash of Object.keys(traceByTransactionHash)) {\n            const traces = await tx\n              .deleteFrom(\"callTraces\")\n              .returningAll()\n              .where(\"transactionHash\", \"=\", transactionHash as Hex)\n              .where(\"chainId\", \"=\", chainId)\n              .execute();\n\n            (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n              ...traceByTransactionHash[transactionHash as Hex].map(\n                (trace) => ({\n                  ...rpcToSqliteTrace(trace),\n                  chainId,\n                }),\n              ),\n            );\n\n            // Use lexographical sort of stringified `traceAddress`.\n            traces.sort((a, b) => {\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n            for (let i = 0; i < traces.length; i++) {\n              const trace = traces[i];\n              const checkpoint = encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: decodeToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              });\n\n              trace.checkpoint = checkpoint;\n            }\n\n            await tx\n              .insertInto(\"callTraces\")\n              .values(traces)\n              .onConflict((oc) => oc.column(\"id\").doNothing())\n              .execute();\n          }\n\n          await this._insertFactoryTraceFilterInterval({\n            tx,\n            chainId,\n            factoryTraceFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryTraceFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryTraceFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryTraceFragments({ ...factory, chainId });\n\n        await Promise.all(\n          fragments.map(async (fragment) => {\n            return await this.db.transaction().execute(async (tx) => {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryTraceFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryTraceFilterIntervals\")\n                .where(\"factoryId\", \"=\", factoryId)\n                .returningAll()\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(decodeToBigInt(i.startBlock)),\n                  Number(decodeToBigInt(i.endBlock)),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: encodeAsText(startBlock),\n                  endBlock: encodeAsText(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryTraceFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n            });\n          }),\n        );\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentFromAddress)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                      f.fromAddress,\n                    )} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryTraceFilterIntervals\")\n          .innerJoin(\n            \"factoryTraceFilters\",\n            \"factoryId\",\n            \"factoryTraceFilters.id\",\n          )\n          .innerJoin(\"factoryFilterFragments\", (join) =>\n            join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n                eb.or([\n                  eb(\"fromAddress\", \"is\", null),\n                  eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n                ]),\n              ]),\n            ),\n          )\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    traces: rpcTraces,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    transactionReceipts: RpcTransactionReceipt[];\n    logs: RpcLog[];\n    traces: SyncCallTrace[];\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeBlock\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((rpcTransaction) => ({\n            ...rpcToSqliteTransaction(rpcTransaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) =>\n              oc.column(\"hash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) =>\n              oc.column(\"transactionHash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                contractAddress: eb.ref(\"excluded.contractAddress\"),\n                cumulativeGasUsed: eb.ref(\"excluded.cumulativeGasUsed\"),\n                effectiveGasPrice: eb.ref(\"excluded.effectiveGasPrice\"),\n                gasUsed: eb.ref(\"excluded.gasUsed\"),\n                logs: eb.ref(\"excluded.logs\"),\n                logsBloom: eb.ref(\"excluded.logsBloom\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTraces.length > 0) {\n          const traces = rpcTraces\n            .map((trace, i) => ({\n              ...rpcToSqliteTrace(trace),\n              chainId,\n              checkpoint: encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: hexToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              }),\n            }))\n            .sort((a, b) => {\n              if (a.transactionHash < b.transactionHash) return -1;\n              if (a.transactionHash > b.transactionHash) return 1;\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      });\n    });\n  };\n\n  private createLogCheckpoint = (\n    rpcLog: RpcLog,\n    block: RpcBlock,\n    chainId: number,\n  ) => {\n    if (block.number === null) {\n      throw new Error(\"Number is missing from RPC block\");\n    }\n    if (rpcLog.transactionIndex === null) {\n      throw new Error(\"Transaction index is missing from RPC log\");\n    }\n    if (rpcLog.logIndex === null) {\n      throw new Error(\"Log index is missing from RPC log\");\n    }\n    return encodeCheckpoint({\n      blockTimestamp: Number(BigInt(block.timestamp)),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: hexToBigInt(rpcLog.transactionIndex),\n      eventType: EVENT_TYPES.logs,\n      eventIndex: hexToBigInt(rpcLog.logIndex),\n    });\n  };\n\n  private createBlockCheckpoint = (block: RpcBlock, chainId: number) => {\n    if (block.number === null) {\n      throw new Error(\"Number is missing from RPC block\");\n    }\n\n    return encodeCheckpoint({\n      blockTimestamp: hexToNumber(block.timestamp),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: maxCheckpoint.transactionIndex,\n      eventType: EVENT_TYPES.blocks,\n      eventIndex: zeroCheckpoint.eventIndex,\n    });\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factoryLogFilters,\n    traceFilters,\n    factoryTraceFilters,\n    blockFilters,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    traceFilters: CallTraceFilterCriteria[];\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [\n            ...logFilters,\n            ...factoryLogFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n            ...factoryTraceFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n          ],\n          interval,\n        });\n\n        await this._insertFactoryLogFilterInterval({\n          tx,\n          chainId,\n          factoryLogFilters,\n          interval,\n        });\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters,\n          interval,\n        });\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters,\n          interval,\n        });\n\n        await this._insertFactoryTraceFilterInterval({\n          tx,\n          chainId,\n          factoryTraceFilters,\n          interval,\n        });\n      });\n    });\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock: fromBlock_,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    return this.db.wrap({ method: \"deleteRealtimeData\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        const fromBlock = encodeAsText(fromBlock_);\n\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n      });\n    });\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({\n            logFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factoryLogFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryLogFilters.flatMap((factory) =>\n      buildFactoryLogFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryLogFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertBlockFilterInterval = async ({\n    tx,\n    chainId,\n    blockFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const blockFilterFragments = blockFilters.flatMap((blockFilter) => {\n      return {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n    });\n\n    await Promise.all(\n      blockFilterFragments.map(async (blockFilterFragment) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(blockFilterFragment)\n          .onConflict((oc) => oc.doUpdateSet(blockFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"blockFilterIntervals\")\n          .values({\n            blockFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertTraceFilterInterval = async ({\n    tx,\n    chainId,\n    traceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    traceFilters: CallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const traceFilterFragments = traceFilters.flatMap((traceFilter) =>\n      buildTraceFragments({ ...traceFilter, chainId }),\n    );\n\n    await Promise.all(\n      traceFilterFragments.map(async (traceFilterFragment) => {\n        const { id: traceFilterId } = await tx\n          .insertInto(\"traceFilters\")\n          .values(traceFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(traceFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"traceFilterIntervals\")\n          .values({\n            traceFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryTraceFilterInterval = async ({\n    tx,\n    chainId,\n    factoryTraceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryTraceFilters.flatMap((factory) =>\n      buildFactoryTraceFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryTraceFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryTraceFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  /** CONTRACT READS */\n\n  insertRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n    result,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n    result: string;\n  }) => {\n    return this.db.wrap({ method: \"insertRpcRequestResult\" }, async () => {\n      await this.db\n        .insertInto(\"rpcRequestResults\")\n        .values({\n          request,\n          blockNumber: encodeAsText(blockNumber),\n          chainId,\n          result,\n        })\n        .onConflict((oc) => oc.doUpdateSet({ result }))\n        .execute();\n    });\n  };\n\n  getRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n  }) => {\n    return this.db.wrap({ method: \"getRpcRequestResult\" }, async () => {\n      const rpcRequestResult = await this.db\n        .selectFrom(\"rpcRequestResults\")\n        .selectAll()\n        .where(\"blockNumber\", \"=\", encodeAsText(blockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"request\", \"=\", request)\n        .executeTakeFirst();\n\n      return rpcRequestResult\n        ? {\n            ...rpcRequestResult,\n            blockNumber: decodeToBigInt(rpcRequestResult.blockNumber),\n          }\n        : null;\n    });\n  };\n\n  async *getEvents({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n    limit,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n    limit: number;\n  }) {\n    let cursor = encodeCheckpoint(fromCheckpoint);\n    const encodedToCheckpoint = encodeCheckpoint(toCheckpoint);\n\n    const sourcesById = sources.reduce<{\n      [sourceId: string]: (typeof sources)[number];\n    }>((acc, cur) => {\n      acc[cur.id] = cur;\n      return acc;\n    }, {});\n\n    // We can assume that source won't be empty.\n    const logSources = sources.filter(\n      (s): s is LogSource | FactoryLogSource =>\n        sourceIsLog(s) || sourceIsFactoryLog(s),\n    );\n    const callTraceSources = sources.filter(\n      (s): s is CallTraceSource | FactoryCallTraceSource =>\n        sourceIsCallTrace(s) || sourceIsFactoryCallTrace(s),\n    );\n    const blockSources = sources.filter(sourceIsBlock);\n\n    const shouldJoinLogs = logSources.length !== 0;\n    const shouldJoinTransactions =\n      logSources.length !== 0 || callTraceSources.length !== 0;\n    const shouldJoinTraces = callTraceSources.length !== 0;\n    const shouldJoinReceipts =\n      logSources.some((source) => source.criteria.includeTransactionReceipts) ||\n      callTraceSources.some(\n        (source) => source.criteria.includeTransactionReceipts,\n      );\n\n    while (true) {\n      const events = await this.db.wrap({ method: \"getEvents\" }, async () => {\n        // Query a batch of logs.\n        const requestedLogs = await this.db\n          .with(\n            \"log_sources(source_id)\",\n            () =>\n              sql`( values ${\n                logSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      logSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"block_sources(source_id)\",\n            () =>\n              sql`( values ${\n                blockSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      blockSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"call_traces_sources(source_id)\",\n            () =>\n              sql`( values ${\n                callTraceSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      callTraceSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\"events\", (db) =>\n            db\n              .selectFrom(\"logs\")\n              .innerJoin(\"log_sources\", (join) => join.onTrue())\n              .where((eb) => {\n                const logFilterCmprs = sources\n                  .filter(sourceIsLog)\n                  .map((logFilter) => {\n                    const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n                    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n                    return eb.and(exprs);\n                  });\n\n                const factoryCmprs = sources\n                  .filter(sourceIsFactoryLog)\n                  .map((factory) => {\n                    const exprs = this.buildFactoryLogFilterCmprs({\n                      eb,\n                      factory,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", factory.id));\n                    return eb.and(exprs);\n                  });\n\n                return eb.or([...logFilterCmprs, ...factoryCmprs]);\n              })\n              .select([\n                \"source_id\",\n                \"checkpoint\",\n                \"blockHash\",\n                \"transactionHash\",\n\n                \"logs.id as log_id\",\n                sql`null`.as(\"callTrace_id\"),\n              ])\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"blocks\")\n                  .innerJoin(\"block_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const exprs = [];\n                    const blockFilters = sources.filter(sourceIsBlock);\n                    for (const blockFilter of blockFilters) {\n                      exprs.push(\n                        eb.and([\n                          eb(\"chainId\", \"=\", blockFilter.chainId),\n                          eb(\n                            \"number\",\n                            \">=\",\n                            encodeAsText(blockFilter.startBlock),\n                          ),\n                          ...(blockFilter.endBlock !== undefined\n                            ? [\n                                eb(\n                                  \"number\",\n                                  \"<=\",\n                                  encodeAsText(blockFilter.endBlock),\n                                ),\n                              ]\n                            : []),\n                          sql`(number - ${blockFilter.criteria.offset}) % ${blockFilter.criteria.interval} = 0`,\n                          eb(\"source_id\", \"=\", blockFilter.id),\n                        ]),\n                      );\n                    }\n                    return eb.or(exprs);\n                  })\n                  .select([\n                    \"block_sources.source_id\",\n                    \"checkpoint\",\n                    \"hash as blockHash\",\n                    sql`null`.as(\"transactionHash\"),\n\n                    sql`null`.as(\"log_id\"),\n                    sql`null`.as(\"callTrace_id\"),\n                  ]),\n              )\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"callTraces\")\n                  .innerJoin(\"call_traces_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const traceFilterCmprs = sources\n                      .filter(sourceIsCallTrace)\n                      .map((callTraceSource) => {\n                        const exprs = this.buildTraceFilterCmprs({\n                          eb,\n                          callTraceSource,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", callTraceSource.id));\n                        return eb.and(exprs);\n                      });\n                    const factoryTraceFilterCmprs = sources\n                      .filter(sourceIsFactoryCallTrace)\n                      .map((factory) => {\n                        const exprs = this.buildFactoryTraceFilterCmprs({\n                          eb,\n                          factory,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", factory.id));\n                        return eb.and(exprs);\n                      });\n\n                    return eb.or([\n                      ...traceFilterCmprs,\n                      ...factoryTraceFilterCmprs,\n                    ]);\n                  })\n                  .select([\n                    \"source_id\",\n                    \"checkpoint\",\n                    \"blockHash\",\n                    \"transactionHash\",\n\n                    sql`null`.as(\"log_id\"),\n                    \"callTraces.id as callTrace_id\",\n                  ]),\n              ),\n          )\n          .selectFrom(\"events\")\n          .innerJoin(\"blocks\", \"blocks.hash\", \"events.blockHash\")\n          .select([\n            \"events.source_id\",\n            \"events.checkpoint\",\n\n            \"blocks.baseFeePerGas as block_baseFeePerGas\",\n            \"blocks.difficulty as block_difficulty\",\n            \"blocks.extraData as block_extraData\",\n            \"blocks.gasLimit as block_gasLimit\",\n            \"blocks.gasUsed as block_gasUsed\",\n            \"blocks.hash as block_hash\",\n            \"blocks.logsBloom as block_logsBloom\",\n            \"blocks.miner as block_miner\",\n            \"blocks.mixHash as block_mixHash\",\n            \"blocks.nonce as block_nonce\",\n            \"blocks.number as block_number\",\n            \"blocks.parentHash as block_parentHash\",\n            \"blocks.receiptsRoot as block_receiptsRoot\",\n            \"blocks.sha3Uncles as block_sha3Uncles\",\n            \"blocks.size as block_size\",\n            \"blocks.stateRoot as block_stateRoot\",\n            \"blocks.timestamp as block_timestamp\",\n            \"blocks.totalDifficulty as block_totalDifficulty\",\n            \"blocks.transactionsRoot as block_transactionsRoot\",\n          ])\n          .$if(shouldJoinLogs, (qb) =>\n            qb\n              .leftJoin(\"logs\", \"logs.id\", \"events.log_id\")\n              .select([\n                \"logs.address as log_address\",\n                \"logs.blockHash as log_blockHash\",\n                \"logs.blockNumber as log_blockNumber\",\n                \"logs.chainId as log_chainId\",\n                \"logs.data as log_data\",\n                \"logs.id as log_id\",\n                \"logs.logIndex as log_logIndex\",\n                \"logs.topic0 as log_topic0\",\n                \"logs.topic1 as log_topic1\",\n                \"logs.topic2 as log_topic2\",\n                \"logs.topic3 as log_topic3\",\n                \"logs.transactionHash as log_transactionHash\",\n                \"logs.transactionIndex as log_transactionIndex\",\n              ]),\n          )\n          .$if(shouldJoinTransactions, (qb) =>\n            qb\n              .leftJoin(\n                \"transactions\",\n                \"transactions.hash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactions.accessList as tx_accessList\",\n                \"transactions.blockHash as tx_blockHash\",\n                \"transactions.blockNumber as tx_blockNumber\",\n                \"transactions.from as tx_from\",\n                \"transactions.gas as tx_gas\",\n                \"transactions.gasPrice as tx_gasPrice\",\n                \"transactions.hash as tx_hash\",\n                \"transactions.input as tx_input\",\n                \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n                \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n                \"transactions.nonce as tx_nonce\",\n                \"transactions.r as tx_r\",\n                \"transactions.s as tx_s\",\n                \"transactions.to as tx_to\",\n                \"transactions.transactionIndex as tx_transactionIndex\",\n                \"transactions.type as tx_type\",\n                \"transactions.value as tx_value\",\n                \"transactions.v as tx_v\",\n              ]),\n          )\n          .$if(shouldJoinTraces, (qb) =>\n            qb\n              .leftJoin(\"callTraces\", \"callTraces.id\", \"events.callTrace_id\")\n              .select([\n                \"callTraces.id as callTrace_id\",\n                \"callTraces.callType as callTrace_callType\",\n                \"callTraces.from as callTrace_from\",\n                \"callTraces.gas as callTrace_gas\",\n                \"callTraces.input as callTrace_input\",\n                \"callTraces.to as callTrace_to\",\n                \"callTraces.value as callTrace_value\",\n                \"callTraces.blockHash as callTrace_blockHash\",\n                \"callTraces.blockNumber as callTrace_blockNumber\",\n                \"callTraces.gasUsed as callTrace_gasUsed\",\n                \"callTraces.output as callTrace_output\",\n                \"callTraces.subtraces as callTrace_subtraces\",\n                \"callTraces.traceAddress as callTrace_traceAddress\",\n                \"callTraces.transactionHash as callTrace_transactionHash\",\n                \"callTraces.transactionPosition as callTrace_transactionPosition\",\n                \"callTraces.chainId as callTrace_chainId\",\n                \"callTraces.checkpoint as callTrace_checkpoint\",\n              ]),\n          )\n          .$if(shouldJoinReceipts, (qb) =>\n            qb\n              .leftJoin(\n                \"transactionReceipts\",\n                \"transactionReceipts.transactionHash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactionReceipts.blockHash as txr_blockHash\",\n                \"transactionReceipts.blockNumber as txr_blockNumber\",\n                \"transactionReceipts.contractAddress as txr_contractAddress\",\n                \"transactionReceipts.cumulativeGasUsed as txr_cumulativeGasUsed\",\n                \"transactionReceipts.effectiveGasPrice as txr_effectiveGasPrice\",\n                \"transactionReceipts.from as txr_from\",\n                \"transactionReceipts.gasUsed as txr_gasUsed\",\n                \"transactionReceipts.logs as txr_logs\",\n                \"transactionReceipts.logsBloom as txr_logsBloom\",\n                \"transactionReceipts.status as txr_status\",\n                \"transactionReceipts.to as txr_to\",\n                \"transactionReceipts.transactionHash as txr_transactionHash\",\n                \"transactionReceipts.transactionIndex as txr_transactionIndex\",\n                \"transactionReceipts.type as txr_type\",\n              ]),\n          )\n          .where(\"events.checkpoint\", \">\", cursor)\n          .where(\"events.checkpoint\", \"<=\", encodedToCheckpoint)\n          .orderBy(\"events.checkpoint\", \"asc\")\n          .limit(limit + 1)\n          .execute();\n\n        return requestedLogs.map((_row) => {\n          // Without this cast, the block_ and tx_ fields are all nullable\n          // which makes this very annoying. Should probably add a runtime check\n          // that those fields are indeed present before continuing here.\n          const row = _row as NonNull<(typeof requestedLogs)[number]>;\n\n          const source = sourcesById[row.source_id];\n\n          const shouldIncludeLog =\n            sourceIsLog(source) || sourceIsFactoryLog(source);\n          const shouldIncludeTransaction =\n            sourceIsLog(source) ||\n            sourceIsFactoryLog(source) ||\n            sourceIsCallTrace(source) ||\n            sourceIsFactoryCallTrace(source);\n          const shouldIncludeTrace =\n            sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source);\n          const shouldIncludeTransactionReceipt =\n            (sourceIsLog(source) &&\n              source.criteria.includeTransactionReceipts) ||\n            (sourceIsFactoryLog(source) &&\n              source.criteria.includeTransactionReceipts);\n          return {\n            chainId: source.chainId,\n            sourceId: row.source_id,\n            encodedCheckpoint: row.checkpoint,\n            log: shouldIncludeLog\n              ? {\n                  address: checksumAddress(row.log_address),\n                  blockHash: row.log_blockHash,\n                  blockNumber: decodeToBigInt(row.log_blockNumber),\n                  data: row.log_data,\n                  id: row.log_id as Log[\"id\"],\n                  logIndex: Number(row.log_logIndex),\n                  removed: false,\n                  topics: [\n                    row.log_topic0,\n                    row.log_topic1,\n                    row.log_topic2,\n                    row.log_topic3,\n                  ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n                  transactionHash: row.log_transactionHash,\n                  transactionIndex: Number(row.log_transactionIndex),\n                }\n              : undefined,\n            block: {\n              baseFeePerGas: row.block_baseFeePerGas\n                ? decodeToBigInt(row.block_baseFeePerGas)\n                : null,\n              difficulty: decodeToBigInt(row.block_difficulty),\n              extraData: row.block_extraData,\n              gasLimit: decodeToBigInt(row.block_gasLimit),\n              gasUsed: decodeToBigInt(row.block_gasUsed),\n              hash: row.block_hash,\n              logsBloom: row.block_logsBloom,\n              miner: checksumAddress(row.block_miner),\n              mixHash: row.block_mixHash,\n              nonce: row.block_nonce,\n              number: decodeToBigInt(row.block_number),\n              parentHash: row.block_parentHash,\n              receiptsRoot: row.block_receiptsRoot,\n              sha3Uncles: row.block_sha3Uncles,\n              size: decodeToBigInt(row.block_size),\n              stateRoot: row.block_stateRoot,\n              timestamp: decodeToBigInt(row.block_timestamp),\n              totalDifficulty: row.block_totalDifficulty\n                ? decodeToBigInt(row.block_totalDifficulty)\n                : null,\n              transactionsRoot: row.block_transactionsRoot,\n            },\n            transaction: shouldIncludeTransaction\n              ? {\n                  blockHash: row.tx_blockHash,\n                  blockNumber: decodeToBigInt(row.tx_blockNumber),\n                  from: checksumAddress(row.tx_from),\n                  gas: decodeToBigInt(row.tx_gas),\n                  hash: row.tx_hash,\n                  input: row.tx_input,\n                  nonce: Number(row.tx_nonce),\n                  r: row.tx_r,\n                  s: row.tx_s,\n                  to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n                  transactionIndex: Number(row.tx_transactionIndex),\n                  value: decodeToBigInt(row.tx_value),\n                  v: row.tx_v ? decodeToBigInt(row.tx_v) : null,\n                  ...(row.tx_type === \"0x0\"\n                    ? {\n                        type: \"legacy\",\n                        gasPrice: decodeToBigInt(row.tx_gasPrice),\n                      }\n                    : row.tx_type === \"0x1\"\n                      ? {\n                          type: \"eip2930\",\n                          gasPrice: decodeToBigInt(row.tx_gasPrice),\n                          accessList: JSON.parse(row.tx_accessList),\n                        }\n                      : row.tx_type === \"0x2\"\n                        ? {\n                            type: \"eip1559\",\n                            maxFeePerGas: decodeToBigInt(row.tx_maxFeePerGas),\n                            maxPriorityFeePerGas: decodeToBigInt(\n                              row.tx_maxPriorityFeePerGas,\n                            ),\n                          }\n                        : row.tx_type === \"0x7e\"\n                          ? {\n                              type: \"deposit\",\n                              maxFeePerGas: row.tx_maxFeePerGas\n                                ? decodeToBigInt(row.tx_maxFeePerGas)\n                                : undefined,\n                              maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas\n                                ? decodeToBigInt(row.tx_maxPriorityFeePerGas)\n                                : undefined,\n                            }\n                          : {\n                              type: row.tx_type,\n                            }),\n                }\n              : undefined,\n            trace: shouldIncludeTrace\n              ? {\n                  id: row.callTrace_id,\n                  from: checksumAddress(row.callTrace_from),\n                  to: checksumAddress(row.callTrace_to),\n                  gas: decodeToBigInt(row.callTrace_gas),\n                  value: decodeToBigInt(row.callTrace_value),\n                  input: row.callTrace_input,\n                  output: row.callTrace_output,\n                  gasUsed: decodeToBigInt(row.callTrace_gasUsed),\n                  subtraces: row.callTrace_subtraces,\n                  traceAddress: JSON.parse(row.callTrace_traceAddress),\n                  blockHash: row.callTrace_blockHash,\n                  blockNumber: decodeToBigInt(row.callTrace_blockNumber),\n                  transactionHash: row.callTrace_transactionHash,\n                  transactionIndex: row.callTrace_transactionPosition,\n                  callType: row.callTrace_callType as CallTrace[\"callType\"],\n                }\n              : undefined,\n            transactionReceipt: shouldIncludeTransactionReceipt\n              ? {\n                  blockHash: row.txr_blockHash,\n                  blockNumber: decodeToBigInt(row.txr_blockNumber),\n                  contractAddress: row.txr_contractAddress\n                    ? checksumAddress(row.txr_contractAddress)\n                    : null,\n                  cumulativeGasUsed: decodeToBigInt(row.txr_cumulativeGasUsed),\n                  effectiveGasPrice: decodeToBigInt(row.txr_effectiveGasPrice),\n                  from: checksumAddress(row.txr_from),\n                  gasUsed: decodeToBigInt(row.txr_gasUsed),\n                  logs: JSON.parse(row.txr_logs).map((log: SyncLog) => ({\n                    address: checksumAddress(log.address),\n                    blockHash: log.blockHash,\n                    blockNumber: hexToBigInt(log.blockNumber),\n                    data: log.data,\n                    logIndex: hexToNumber(log.logIndex),\n                    removed: false,\n                    topics: [\n                      log.topics[0] ?? null,\n                      log.topics[1] ?? null,\n                      log.topics[2] ?? null,\n                      log.topics[3] ?? null,\n                    ].filter((t): t is Hex => t !== null) as\n                      | [Hex, ...Hex[]]\n                      | [],\n                    transactionHash: log.transactionHash,\n                    transactionIndex: hexToNumber(log.transactionIndex),\n                  })),\n                  logsBloom: row.txr_logsBloom,\n                  status:\n                    row.txr_status === \"0x1\"\n                      ? \"success\"\n                      : row.txr_status === \"0x0\"\n                        ? \"reverted\"\n                        : (row.txr_status as TransactionReceipt[\"status\"]),\n                  to: row.txr_to ? checksumAddress(row.txr_to) : null,\n                  transactionHash: row.txr_transactionHash,\n                  transactionIndex: Number(row.txr_transactionIndex),\n                  type:\n                    row.txr_type === \"0x0\"\n                      ? \"legacy\"\n                      : row.txr_type === \"0x1\"\n                        ? \"eip2930\"\n                        : row.tx_type === \"0x2\"\n                          ? \"eip1559\"\n                          : row.tx_type === \"0x7e\"\n                            ? \"deposit\"\n                            : row.tx_type,\n                }\n              : undefined,\n          } satisfies RawEvent;\n        });\n      });\n\n      const hasNextPage = events.length === limit + 1;\n\n      if (!hasNextPage) {\n        yield events;\n        break;\n      } else {\n        events.pop();\n        cursor = events[events.length - 1].encodedCheckpoint;\n        yield events;\n      }\n    }\n  }\n\n  async getLastEventCheckpoint({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n  }): Promise<Checkpoint | undefined> {\n    return this.db.wrap({ method: \"getLastEventCheckpoint\" }, async () => {\n      const checkpoint = await this.db\n        .selectFrom(\"logs\")\n        .where((eb) => {\n          const logFilterCmprs = sources\n            .filter(sourceIsLog)\n            .map((logFilter) => {\n              const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n              return eb.and(exprs);\n            });\n\n          const factoryLogFilterCmprs = sources\n            .filter(sourceIsFactoryLog)\n            .map((factory) => {\n              const exprs = this.buildFactoryLogFilterCmprs({ eb, factory });\n              return eb.and(exprs);\n            });\n\n          return eb.or([...logFilterCmprs, ...factoryLogFilterCmprs]);\n        })\n        .select(\"checkpoint\")\n        .unionAll(\n          this.db\n            .selectFrom(\"blocks\")\n            .where((eb) => {\n              const exprs = [];\n              const blockFilters = sources.filter(sourceIsBlock);\n              for (const blockFilter of blockFilters) {\n                exprs.push(\n                  eb.and([\n                    eb(\"chainId\", \"=\", blockFilter.chainId),\n                    eb(\"number\", \">=\", encodeAsText(blockFilter.startBlock)),\n                    ...(blockFilter.endBlock !== undefined\n                      ? [eb(\"number\", \"<=\", encodeAsText(blockFilter.endBlock))]\n                      : []),\n                    sql`(number - ${blockFilter.criteria.offset}) % ${blockFilter.criteria.interval} = 0`,\n                  ]),\n                );\n              }\n              return eb.or(exprs);\n            })\n            .select(\"checkpoint\"),\n        )\n        .unionAll(\n          this.db\n            .selectFrom(\"callTraces\")\n            .where((eb) => {\n              const traceFilterCmprs = sources\n                .filter(sourceIsCallTrace)\n                .map((callTraceSource) => {\n                  const exprs = this.buildTraceFilterCmprs({\n                    eb,\n                    callTraceSource,\n                  });\n                  return eb.and(exprs);\n                });\n\n              const factoryCallTraceCmprs = sources\n                .filter(sourceIsFactoryCallTrace)\n                .map((factory) => {\n                  const exprs = this.buildFactoryTraceFilterCmprs({\n                    eb,\n                    factory,\n                  });\n                  return eb.and(exprs);\n                });\n\n              return eb.or([...traceFilterCmprs, ...factoryCallTraceCmprs]);\n            })\n            .select(\"checkpoint\"),\n        )\n        .where(\"checkpoint\", \">\", encodeCheckpoint(fromCheckpoint))\n        .where(\"checkpoint\", \"<=\", encodeCheckpoint(toCheckpoint))\n        .orderBy(\"checkpoint\", \"desc\")\n        .executeTakeFirst();\n\n      return checkpoint\n        ? checkpoint.checkpoint\n          ? decodeCheckpoint(checkpoint.checkpoint)\n          : undefined\n        : undefined;\n    });\n  }\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: LogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"logs.chainId\", \"=\", logFilter.chainId));\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.startBlock !== undefined && logFilter.startBlock !== 0)\n      exprs.push(\n        eb(\"logs.blockNumber\", \">=\", encodeAsText(logFilter.startBlock)),\n      );\n    if (logFilter.endBlock)\n      exprs.push(\n        eb(\"logs.blockNumber\", \"<=\", encodeAsText(logFilter.endBlock)),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryLogFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryLogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"logs.chainId\", \"=\", factory.chainId));\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = factory.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"logs.blockNumber\", \">=\", encodeAsText(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", encodeAsText(factory.endBlock)));\n\n    return exprs;\n  };\n\n  private buildTraceFilterCmprs = ({\n    eb,\n    callTraceSource,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    callTraceSource: CallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"callTraces.chainId\", \"=\", callTraceSource.chainId));\n\n    if (callTraceSource.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(callTraceSource.criteria.fromAddress) &&\n        callTraceSource.criteria.fromAddress.length === 1\n          ? callTraceSource.criteria.fromAddress[0]\n          : callTraceSource.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    if (callTraceSource.criteria.toAddress) {\n      // If it's an array of length 1, collapse it.\n      const toAddress =\n        Array.isArray(callTraceSource.criteria.toAddress) &&\n        callTraceSource.criteria.toAddress.length === 1\n          ? callTraceSource.criteria.toAddress[0]\n          : callTraceSource.criteria.toAddress;\n      if (Array.isArray(toAddress)) {\n        exprs.push(eb.or(toAddress.map((a) => eb(\"callTraces.to\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"callTraces.to\", \"=\", toAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        callTraceSource.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (\n      callTraceSource.startBlock !== undefined &&\n      callTraceSource.startBlock !== 0\n    )\n      exprs.push(\n        eb(\n          \"callTraces.blockNumber\",\n          \">=\",\n          encodeAsText(callTraceSource.startBlock),\n        ),\n      );\n    if (callTraceSource.endBlock)\n      exprs.push(\n        eb(\n          \"callTraces.blockNumber\",\n          \"<=\",\n          encodeAsText(callTraceSource.endBlock),\n        ),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryTraceFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryCallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"callTraces.chainId\", \"=\", factory.chainId));\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"callTraces.to\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(factory.criteria.fromAddress) &&\n        factory.criteria.fromAddress.length === 1\n          ? factory.criteria.fromAddress[0]\n          : factory.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        factory.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", encodeAsText(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \"<=\", encodeAsText(factory.endBlock)),\n      );\n\n    return exprs;\n  };\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryLogFilterCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data, ${start}, ${length})`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(\n      childAddressLocation,\n    )}, ${start}, ${length})`;\n  }\n}\n","import type { SyncCallTrace } from \"@/sync/index.js\";\nimport { encodeAsText } from \"@/utils/encoding.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { Generated, Insertable } from \"kysely\";\nimport type { Address, Hash, Hex, RpcTransactionReceipt } from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\nexport type BigIntText = string;\n\ntype BlocksTable = {\n  baseFeePerGas: BigIntText | null;\n  difficulty: BigIntText;\n  extraData: Hex;\n  gasLimit: BigIntText;\n  gasUsed: BigIntText;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: BigIntText;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash | null;\n  size: BigIntText;\n  stateRoot: Hash;\n  timestamp: BigIntText;\n  totalDifficulty: BigIntText | null;\n  transactionsRoot: Hash;\n\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToSqliteBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\" | \"checkpoint\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas\n      ? encodeAsText(block.baseFeePerGas)\n      : null,\n    difficulty: encodeAsText(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: encodeAsText(block.gasLimit),\n    gasUsed: encodeAsText(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: encodeAsText(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles ?? null,\n    size: encodeAsText(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: encodeAsText(block.timestamp),\n    totalDifficulty: block.totalDifficulty\n      ? encodeAsText(block.totalDifficulty)\n      : null,\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  from: Address;\n  gas: BigIntText;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex | null;\n  s: Hex | null;\n  to: Address | null;\n  transactionIndex: number;\n  v: BigIntText | null;\n  value: BigIntText;\n\n  type: Hex;\n  gasPrice: BigIntText | null;\n  maxFeePerGas: BigIntText | null;\n  maxPriorityFeePerGas: BigIntText | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToSqliteTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: encodeAsText(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: encodeAsText(transaction.gas),\n    gasPrice: transaction.gasPrice ? encodeAsText(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? encodeAsText(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? encodeAsText(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r ?? null,\n    s: transaction.s ?? null,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: encodeAsText(transaction.value),\n    v: transaction.v ? encodeAsText(transaction.v) : null,\n  };\n}\n\ntype TransactionReceiptsTable = {\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  contractAddress: Address | null;\n  cumulativeGasUsed: BigIntText;\n  effectiveGasPrice: BigIntText;\n  from: Address;\n  gasUsed: BigIntText;\n  logs: string;\n  logsBloom: Hex;\n  status: Hex;\n  to: Address | null;\n  transactionHash: Hash;\n  transactionIndex: number;\n  type: Hex;\n\n  chainId: number;\n};\n\nexport type InsertableTransactionReceipts =\n  Insertable<TransactionReceiptsTable>;\n\nexport function rpcToSqliteTransactionReceipt(\n  transactionReceipt: RpcTransactionReceipt,\n): Omit<TransactionReceiptsTable, \"chainId\"> {\n  return {\n    blockHash: transactionReceipt.blockHash,\n    blockNumber: encodeAsText(transactionReceipt.blockNumber),\n    contractAddress: transactionReceipt.contractAddress\n      ? toLowerCase(transactionReceipt.contractAddress)\n      : null,\n    cumulativeGasUsed: encodeAsText(transactionReceipt.cumulativeGasUsed),\n    effectiveGasPrice: encodeAsText(transactionReceipt.effectiveGasPrice),\n    from: toLowerCase(transactionReceipt.from),\n    gasUsed: encodeAsText(transactionReceipt.gasUsed),\n    logs: JSON.stringify(transactionReceipt.logs),\n    logsBloom: transactionReceipt.logsBloom,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,\n    transactionHash: transactionReceipt.transactionHash,\n    transactionIndex: Number(transactionReceipt.transactionIndex),\n    type: transactionReceipt.type as Hex,\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n  checkpoint?: string;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToSqliteLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: encodeAsText(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype CallTracesTable = {\n  id: string;\n  callType: string;\n  from: Address;\n  gas: BigIntText;\n  input: Hex;\n  to: Address;\n  value: BigIntText;\n  blockHash: Hex;\n  blockNumber: BigIntText;\n  error: string | null;\n  gasUsed: BigIntText | null;\n  output: Hex | null;\n  subtraces: number;\n  traceAddress: string;\n  transactionHash: Hex;\n  transactionPosition: number;\n  functionSelector: Hex;\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableCallTrace = Insertable<CallTracesTable>;\n\nexport function rpcToSqliteTrace(\n  trace: SyncCallTrace,\n): Omit<InsertableCallTrace, \"chainId\" | \"checkpoint\"> {\n  return {\n    id: `${trace.transactionHash}-${JSON.stringify(trace.traceAddress)}`,\n    callType: trace.action.callType,\n    from: toLowerCase(trace.action.from),\n    gas: encodeAsText(trace.action.gas),\n    input: trace.action.input,\n    to: toLowerCase(trace.action.to),\n    value: encodeAsText(trace.action.value),\n    blockHash: trace.blockHash,\n    blockNumber: encodeAsText(trace.blockNumber),\n    error: trace.error ?? null,\n    gasUsed: trace.result ? encodeAsText(trace.result.gasUsed) : null,\n    output: trace.result ? trace.result.output : null,\n    subtraces: trace.subtraces,\n    traceAddress: JSON.stringify(trace.traceAddress),\n    transactionHash: trace.transactionHash,\n    transactionPosition: trace.transactionPosition,\n    functionSelector: trace.action.input.slice(0, 10).toLowerCase() as Hex,\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: BigIntText;\n  chainId: number;\n  result: string;\n  request: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype FactoryLogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype TraceFiltersTable = {\n  id: string;\n  chainId: number;\n  fromAddress: Address | null;\n  toAddress: Address | null;\n};\n\ntype TraceFilterIntervalsTable = {\n  id: Generated<number>;\n  traceFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype FactoryTraceFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  fromAddress: Address | null;\n};\n\ntype FactoryTraceFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype BlockFiltersTable = {\n  id: string;\n  chainId: number;\n  interval: number;\n  offset: number;\n};\n\ntype BlockFilterIntervalsTable = {\n  id: Generated<number>;\n  blockFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  transactionReceipts: TransactionReceiptsTable;\n  logs: LogsTable;\n  callTraces: CallTracesTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factoryLogFilters: FactoryLogFiltersTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n  traceFilters: TraceFiltersTable;\n  traceFilterIntervals: TraceFilterIntervalsTable;\n  factoryTraceFilters: FactoryTraceFiltersTable;\n  factoryTraceFilterIntervals: FactoryTraceFilterIntervalsTable;\n  blockFilters: BlockFiltersTable;\n  blockFilterIntervals: BlockFilterIntervalsTable;\n};\n","import type { RawEvent } from \"@/sync-store/store.js\";\nimport type {\n  Block,\n  CallTrace,\n  Log,\n  Transaction,\n  TransactionReceipt,\n} from \"@/types/eth.js\";\nimport { never } from \"@/utils/never.js\";\nimport {\n  type Hex,\n  decodeEventLog,\n  decodeFunctionData,\n  decodeFunctionResult,\n} from \"viem\";\nimport type { Service } from \"./service.js\";\n\nexport type SetupEvent = {\n  type: \"setup\";\n  chainId: number;\n  contractName: string;\n  startBlock: bigint;\n  encodedCheckpoint: string;\n};\n\nexport type LogEvent = {\n  type: \"log\";\n  chainId: number;\n  contractName: string;\n  logEventName: string;\n  event: {\n    args: any;\n    log: Log;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type BlockEvent = {\n  type: \"block\";\n  chainId: number;\n  sourceName: string;\n  event: {\n    block: Block;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type CallTraceEvent = {\n  type: \"callTrace\";\n  chainId: number;\n  contractName: string;\n  functionName: string;\n  event: {\n    args: any;\n    result: any;\n    trace: CallTrace;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type Event = LogEvent | BlockEvent | CallTraceEvent;\n\nexport const decodeEvents = (\n  { common, sourceById }: Pick<Service, \"sourceById\" | \"common\">,\n  rawEvents: RawEvent[],\n): Event[] => {\n  const events: Event[] = [];\n\n  for (const event of rawEvents) {\n    const source = sourceById[event.sourceId];\n\n    switch (source.type) {\n      case \"block\": {\n        events.push({\n          type: \"block\",\n          chainId: event.chainId,\n          sourceName: source.sourceName,\n          event: {\n            block: event.block,\n          },\n          encodedCheckpoint: event.encodedCheckpoint,\n        });\n        break;\n      }\n\n      case \"callTrace\":\n      case \"factoryCallTrace\": {\n        try {\n          const abi = source.abi;\n\n          const data = decodeFunctionData({\n            abi,\n            data: event.trace!.input,\n          });\n\n          const result = decodeFunctionResult({\n            abi,\n            data: event.trace!.output,\n            functionName: data.functionName,\n          });\n\n          const selector = event.trace!.input.slice(0, 10) as Hex;\n\n          if (source.abiFunctions.bySelector[selector] === undefined) {\n            throw new Error();\n          }\n\n          const functionName =\n            source.abiFunctions.bySelector[selector]!.safeName;\n\n          events.push({\n            type: \"callTrace\",\n            chainId: event.chainId,\n            contractName: source.contractName,\n            functionName,\n            event: {\n              args: data.args,\n              result,\n              trace: event.trace!,\n              block: event.block,\n              transaction: event.transaction!,\n              transactionReceipt: event.transactionReceipt,\n            },\n            encodedCheckpoint: event.encodedCheckpoint,\n          });\n        } catch (err) {\n          common.logger.debug({\n            service: \"app\",\n            msg: `Unable to decode trace, skipping it. id: ${event.trace?.id}, input: ${event.trace?.input}, output: ${event.trace?.output}`,\n          });\n        }\n        break;\n      }\n\n      case \"log\":\n      case \"factoryLog\": {\n        try {\n          const abi = source.abi;\n\n          const decodedLog = decodeEventLog({\n            abi,\n            data: event.log!.data,\n            topics: event.log!.topics,\n          });\n\n          if (\n            event.log!.topics[0] === undefined ||\n            source.abiEvents.bySelector[event.log!.topics[0]] === undefined\n          ) {\n            throw new Error();\n          }\n\n          const logEventName =\n            source.abiEvents.bySelector[event.log!.topics[0]]!.safeName;\n\n          events.push({\n            type: \"log\",\n            chainId: event.chainId,\n            contractName: source.contractName,\n            logEventName,\n            event: {\n              args: decodedLog.args,\n              log: event.log!,\n              block: event.block,\n              transaction: event.transaction!,\n              transactionReceipt: event.transactionReceipt,\n            },\n            encodedCheckpoint: event.encodedCheckpoint,\n          });\n        } catch (err) {\n          // TODO(kyle) Because we are strictly setting all `topics` now, this should be a bigger error.\n          common.logger.debug({\n            service: \"app\",\n            msg: `Unable to decode log, skipping it. id: ${event.log?.id}, data: ${event.log?.data}, topics: ${event.log?.topics}`,\n          });\n        }\n        break;\n      }\n\n      default:\n        never(source);\n    }\n  }\n\n  return events;\n};\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type Extend, extend } from \"@/utils/extend.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Address,\n  BlockNotFoundError,\n  type BlockTag,\n  type Hash,\n  type Hex,\n  type Log,\n  type LogTopic,\n  type RpcBlock,\n  type RpcTransactionReceipt,\n  TransactionReceiptNotFoundError,\n  numberToHex,\n} from \"viem\";\nimport {\n  type Service,\n  create,\n  getCachedTransport,\n  getHistoricalCheckpoint,\n  kill,\n  startHistorical,\n  startRealtime,\n} from \"./service.js\";\n\nconst methods = {\n  startHistorical,\n  getHistoricalCheckpoint,\n  startRealtime,\n  getCachedTransport,\n  kill,\n};\n\nexport const createSyncService = extend(create, methods);\n\nexport type SyncService = Extend<Service, typeof methods>;\n\nexport type BaseSyncService = {\n  common: Common;\n  requestQueue: RequestQueue;\n  network: Network;\n};\n\nexport type SyncBlock = RpcBlock<Exclude<BlockTag, \"pending\">, true>;\nexport type SyncLog = Log<Hex, Hex, false>;\nexport type SyncTransactionReceipt = RpcTransactionReceipt;\nexport type SyncTrace =\n  | SyncCallTrace\n  | SyncCreateTrace\n  | SyncRewardTrace\n  | SyncSuicideTrace;\nexport type SyncCallTrace = {\n  action: {\n    callType: \"call\" | \"delegatecall\" | \"staticcall\";\n    from: Address;\n    gas: Hex;\n    input: Hex;\n    to: Address;\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  error?: string;\n  result: {\n    gasUsed: Hex;\n    output: Hex;\n  } | null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"call\";\n};\nexport type SyncCreateTrace = {\n  action: {\n    from: Address;\n    gas: Hex;\n    init: Hex;\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: {\n    address: Address;\n    code: Hex;\n    gasUsed: Hex;\n  } | null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"create\";\n};\nexport type SyncSuicideTrace = {\n  action: {\n    address: Address;\n    refundAddress: Address;\n    balance: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"suicide\";\n};\nexport type SyncRewardTrace = {\n  action: {\n    author: Address;\n    rewardType: \"block\" | \"uncle\";\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: null;\n  subtraces: number;\n  traceAddress: number[];\n  type: \"reward\";\n};\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByNumber = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  {\n    blockNumber,\n    blockTag,\n  }:\n    | { blockNumber: Hex | number; blockTag?: never }\n    | { blockNumber?: never; blockTag: \"latest\" },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByNumber\",\n      params: [\n        typeof blockNumber === \"number\"\n          ? numberToHex(blockNumber)\n          : blockNumber ?? blockTag,\n        true,\n      ],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockNumber: (blockNumber ?? blockTag) as any,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByHash = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  { blockHash }: { blockHash: Hex },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByHash\",\n      params: [blockHash, true],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockHash,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getLogs\" rpc request.\n * Handles different error types and retries the request if applicable.\n */\nexport const _eth_getLogs = async (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    address?: Address | Address[];\n    topics?: LogTopic[];\n  } & (\n    | { fromBlock: Hex | number; toBlock: Hex | number }\n    | { blockHash: Hash }\n  ),\n): Promise<SyncLog[]> => {\n  if (\"blockHash\" in params) {\n    return requestQueue\n      .request({\n        method: \"eth_getLogs\",\n        params: [\n          {\n            blockHash: params.blockHash,\n\n            topics: params.topics,\n            address: params.address\n              ? Array.isArray(params.address)\n                ? params.address.map((a) => toLowerCase(a))\n                : toLowerCase(params.address)\n              : undefined,\n          },\n        ],\n      })\n      .then((l) => l as SyncLog[]);\n  }\n\n  return requestQueue\n    .request({\n      method: \"eth_getLogs\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n\n          topics: params.topics,\n          address: params.address\n            ? Array.isArray(params.address)\n              ? params.address.map((a) => toLowerCase(a))\n              : toLowerCase(params.address)\n            : undefined,\n        },\n      ],\n    })\n    .then((l) => l as SyncLog[]);\n};\n\n/**\n * Helper function for \"eth_getTransactionReceipt\" request.\n */\nexport const _eth_getTransactionReceipt = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  { hash }: { hash: Hex },\n): Promise<SyncTransactionReceipt> =>\n  requestQueue\n    .request({\n      method: \"eth_getTransactionReceipt\",\n      params: [hash],\n    })\n    .then((receipt) => {\n      if (!receipt)\n        throw new TransactionReceiptNotFoundError({\n          hash,\n        });\n      return receipt as SyncTransactionReceipt;\n    });\n\n/**\n * Helper function for \"trace_filter\" request.\n *\n * Note: No strict typing is available.\n */\nexport const _trace_filter = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    fromBlock: Hex | number;\n    toBlock: Hex | number;\n    fromAddress?: Address[];\n    toAddress?: Address[];\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_filter\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n          fromAddress: params.fromAddress\n            ? params.fromAddress.map((a) => toLowerCase(a))\n            : undefined,\n          toAddress: params.toAddress\n            ? params.toAddress.map((a) => toLowerCase(a))\n            : undefined,\n        },\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n\n/**\n * Helper function for \"trace_block\" request.\n *\n * Note: No strict typing is available.\n */\nexport const _trace_block = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    blockNumber: Hex | number;\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_block\",\n      params: [\n        typeof params.blockNumber === \"number\"\n          ? numberToHex(params.blockNumber)\n          : params.blockNumber,\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n","import type { Prettify } from \"@/types/utils.js\";\nimport type { DefaultAddOptions, Options, Queue as TPQueue } from \"p-queue\";\nimport PQueue from \"p-queue\";\n\ntype TaskOptions = { priority?: number };\n\nexport type Queue<TTask> = PQueue & {\n  addTask: (task: TTask, options?: TaskOptions) => Promise<void>;\n};\n\ntype QueueOptions = Prettify<\n  Options<TPQueue<() => Promise<unknown>, DefaultAddOptions>, DefaultAddOptions>\n>;\n\nexport type Worker<TTask, TReturn = void> = (arg: {\n  task: TTask;\n  queue: Queue<TTask>;\n}) => Promise<TReturn>;\n\ntype OnError<TTask> = (arg: {\n  error: Error;\n  task: TTask;\n  queue: Queue<TTask>;\n}) => unknown;\n\n/**\n * Creates a Queue object that has a number of features tailored\n * to Ponder's indexing engine, including:\n * - A shared context object accessible by all tasks\n * - An onError callback that is called _within_ the failed task scope,\n *   allowing the user to retry/add more tasks without the queue going idle.\n */\nexport function createQueue<TTask, TReturn = void>({\n  worker,\n  options,\n  onError,\n  onIdle,\n}: {\n  worker: Worker<TTask, TReturn>;\n  options?: QueueOptions;\n  onError?: OnError<TTask>;\n  onIdle?: () => unknown;\n}): Queue<TTask> {\n  const queue = new PQueue(options) as Queue<TTask>;\n\n  if (onIdle) {\n    queue.on(\"idle\", () => onIdle());\n  }\n\n  queue.addTask = async (task, taskOptions) => {\n    const priority = taskOptions?.priority ?? 0;\n\n    try {\n      await queue.add(\n        () => {\n          return worker({\n            task,\n            queue,\n          });\n        },\n        {\n          priority,\n        },\n      );\n    } catch (error_: any) {\n      await onError?.({ error: error_ as Error, task, queue });\n    }\n  };\n\n  return queue;\n}\n","import type { Common } from \"@/common/common.js\";\nimport { getHistoricalSyncProgress } from \"@/common/metrics.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type {\n  BlockSource,\n  CallTraceSource,\n  EventSource,\n  FactoryCallTraceSource,\n  FactoryLogSource,\n  LogSource,\n} from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type SyncCallTrace,\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_filter,\n} from \"@/sync/index.js\";\nimport { type Checkpoint, maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport {\n  BlockProgressTracker,\n  ProgressTracker,\n  getChunks,\n  intervalDifference,\n  intervalIntersection,\n  intervalSum,\n} from \"@/utils/interval.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport { debounce, dedupe } from \"@ponder/common\";\nimport Emittery from \"emittery\";\nimport {\n  type Hash,\n  type RpcBlock,\n  type RpcLog,\n  hexToNumber,\n  numberToHex,\n  toHex,\n} from \"viem\";\nimport { validateHistoricalBlockRange } from \"./validateHistoricalBlockRange.js\";\n\nconst HISTORICAL_CHECKPOINT_EMIT_INTERVAL = 500;\nconst TRACE_FILTER_CHUNK_SIZE = 10;\n\ntype HistoricalSyncEvents = {\n  /**\n   * Emitted when the service has finished processing all historical sync tasks.\n   */\n  syncComplete: undefined;\n  /**\n   * Emitted when the minimum cached timestamp among all registered sources moves forward.\n   * This indicates to consumers that the connected sync store now contains a complete history\n   * of events for all registered sources between their start block and this timestamp (inclusive).\n   */\n  historicalCheckpoint: Checkpoint;\n};\n\ntype FactoryChildAddressTask = {\n  kind: \"FACTORY_CHILD_ADDRESS\";\n  factory: FactoryLogSource | FactoryCallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype LogFilterTask = {\n  kind: \"LOG_FILTER\";\n  logFilter: LogSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryLogFilterTask = {\n  kind: \"FACTORY_LOG_FILTER\";\n  factoryLogFilter: FactoryLogSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype TraceFilterTask = {\n  kind: \"TRACE_FILTER\";\n  traceFilter: CallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryTraceFilterTask = {\n  kind: \"FACTORY_TRACE_FILTER\";\n  factoryTraceFilter: FactoryCallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockFilterTask = {\n  kind: \"BLOCK_FILTER\";\n  blockFilter: BlockSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockTask = {\n  kind: \"BLOCK\";\n  blockNumber: number;\n  callbacks: ((block: HistoricalBlock) => Promise<void>)[];\n};\n\ntype HistoricalSyncTask =\n  | FactoryChildAddressTask\n  | LogFilterTask\n  | FactoryLogFilterTask\n  | TraceFilterTask\n  | FactoryTraceFilterTask\n  | BlockFilterTask\n  | BlockTask;\n\ntype HistoricalBlock = RpcBlock<\"finalized\", true>;\n\nexport class HistoricalSyncService extends Emittery<HistoricalSyncEvents> {\n  private common: Common;\n  private syncStore: SyncStore;\n  private network: Network;\n  private requestQueue: RequestQueue;\n  private sources: EventSource[];\n\n  /**\n   * Block progress trackers for each task type.\n   */\n  private logFilterProgressTrackers: Record<string, ProgressTracker> = {};\n  private factoryChildAddressProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private factoryLogFilterProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private traceFilterProgressTrackers: Record<string, ProgressTracker> = {};\n  private factoryTraceFilterProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private blockFilterProgressTrackers: Record<string, ProgressTracker> = {};\n\n  private blockProgressTracker: BlockProgressTracker =\n    new BlockProgressTracker();\n\n  /**\n   * Functions registered by log filter + child contract tasks. These functions accept\n   * a raw block object, get required data from it, then insert data and cache metadata\n   * into the sync store. The keys of this object are used to keep track of which blocks\n   * must be fetched.\n   */\n  private blockCallbacks: Record<\n    number,\n    ((block: HistoricalBlock) => Promise<void>)[]\n  > = {};\n\n  /**\n   * Block tasks have been added to the queue up to and including this block number.\n   * Used alongside blockCallbacks to keep track of which block tasks to add to the queue.\n   */\n  private blockTasksEnqueuedCheckpoint = 0;\n\n  private queue: Queue<HistoricalSyncTask>;\n\n  /** If true, failed tasks should not log errors or be retried. */\n  private isShuttingDown = false;\n  private progressLogInterval?: NodeJS.Timeout;\n\n  constructor({\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources = [],\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    network: Network;\n    requestQueue: RequestQueue;\n    sources?: EventSource[];\n  }) {\n    super();\n\n    this.common = common;\n    this.syncStore = syncStore;\n    this.network = network;\n    this.requestQueue = requestQueue;\n    this.sources = sources;\n\n    this.queue = this.buildQueue();\n  }\n\n  async setup({\n    latestBlockNumber,\n    finalizedBlockNumber,\n  }: {\n    latestBlockNumber: number;\n    finalizedBlockNumber: number;\n  }) {\n    // Initialize state variables. Required when restarting the service.\n    this.isShuttingDown = false;\n    this.blockTasksEnqueuedCheckpoint = 0;\n\n    await Promise.all(\n      this.sources.map(async (source) => {\n        const { isHistoricalSyncRequired, startBlock, endBlock } =\n          validateHistoricalBlockRange({\n            startBlock: source.startBlock,\n            endBlock: source.endBlock,\n            finalizedBlockNumber,\n            latestBlockNumber,\n          });\n\n        switch (source.type) {\n          case \"log\": {\n            if (!isHistoricalSyncRequired) {\n              this.logFilterProgressTrackers[source.id] = new ProgressTracker({\n                target: [startBlock, finalizedBlockNumber],\n                completed: [[startBlock, finalizedBlockNumber]],\n              });\n              this.common.metrics.ponder_historical_total_blocks.set(\n                {\n                  network: this.network.name,\n                  source: source.contractName,\n                  type: \"log\",\n                },\n                0,\n              );\n              this.common.logger.warn({\n                service: \"historical\",\n                msg: `Skipped syncing '${this.network.name}' logs for '${source.contractName}' because the start block is not finalized`,\n              });\n              return;\n            }\n\n            const completedLogFilterIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: source.criteria,\n              });\n            const logFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedLogFilterIntervals,\n            });\n            this.logFilterProgressTrackers[source.id] =\n              logFilterProgressTracker;\n\n            const requiredLogFilterIntervals =\n              logFilterProgressTracker.getRequired();\n\n            const logFilterTaskChunks = getChunks({\n              intervals: requiredLogFilterIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of logFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"LOG_FILTER\",\n                  logFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (logFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredLogFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' LOG_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredLogFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' logs for '${\n                source.contractName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n          case \"factoryLog\": {\n            if (!isHistoricalSyncRequired) {\n              this.factoryChildAddressProgressTrackers[source.id] =\n                new ProgressTracker({\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                });\n              this.factoryLogFilterProgressTrackers[source.id] =\n                new ProgressTracker({\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                });\n              this.common.metrics.ponder_historical_total_blocks.set(\n                {\n                  network: this.network.name,\n                  source: source.contractName,\n                  type: \"log\",\n                },\n                0,\n              );\n              this.common.logger.warn({\n                service: \"historical\",\n                msg: `Skipped syncing '${this.network.name}' logs for '${source.contractName}' because the start block is not finalized`,\n              });\n              return;\n            }\n\n            // Note that factory child address progress is stored using\n            // log intervals for the factory log.\n            const completedFactoryChildAddressIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: {\n                  address: source.criteria.address,\n                  topics: [source.criteria.eventSelector],\n                  includeTransactionReceipts: false,\n                },\n              });\n            const factoryChildAddressProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryChildAddressIntervals,\n            });\n            this.factoryChildAddressProgressTrackers[source.id] =\n              factoryChildAddressProgressTracker;\n\n            const requiredFactoryChildAddressIntervals =\n              factoryChildAddressProgressTracker.getRequired();\n            const factoryChildAddressTaskChunks = getChunks({\n              intervals: requiredFactoryChildAddressIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of factoryChildAddressTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_CHILD_ADDRESS\",\n                  factory: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (factoryChildAddressTaskChunks.length > 0) {\n              const total = intervalSum(requiredFactoryChildAddressIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_CHILD_ADDRESS tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryChildAddressBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryChildAddressBlockCount =\n              targetFactoryChildAddressBlockCount -\n              intervalSum(requiredFactoryChildAddressIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"log\",\n              },\n              targetFactoryChildAddressBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"log\",\n              },\n              cachedFactoryChildAddressBlockCount,\n            );\n\n            const completedFactoryLogFilterIntervals =\n              await this.syncStore.getFactoryLogFilterIntervals({\n                chainId: source.chainId,\n                factory: source.criteria,\n              });\n            const factoryLogFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryLogFilterIntervals,\n            });\n            this.factoryLogFilterProgressTrackers[source.id] =\n              factoryLogFilterProgressTracker;\n\n            // Only add factory log filter tasks for any intervals where the\n            // child address tasks are completed, but the factory log filter tasks are not,\n            // because these won't be added automatically by child address tasks.\n            const requiredFactoryLogFilterIntervals =\n              factoryLogFilterProgressTracker.getRequired();\n            const missingFactoryLogFilterIntervals = intervalDifference(\n              requiredFactoryLogFilterIntervals,\n              requiredFactoryChildAddressIntervals,\n            );\n\n            const missingFactoryLogFilterTaskChunks = getChunks({\n              intervals: missingFactoryLogFilterIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [\n              fromBlock,\n              toBlock,\n            ] of missingFactoryLogFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_LOG_FILTER\",\n                  factoryLogFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (missingFactoryLogFilterTaskChunks.length > 0) {\n              const total = intervalSum(missingFactoryLogFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_LOG_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryLogFilterBlockCount = endBlock - startBlock + 1;\n            const cachedFactoryLogFilterBlockCount =\n              targetFactoryLogFilterBlockCount -\n              intervalSum(requiredFactoryLogFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              targetFactoryLogFilterBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              cachedFactoryLogFilterBlockCount,\n            );\n\n            // Use factory log filter progress for the logger because it better represents\n            // user-facing progress.\n            const cacheRate = Math.min(\n              1,\n              cachedFactoryLogFilterBlockCount /\n                (targetFactoryLogFilterBlockCount || 1),\n            );\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' logs for '${\n                source.contractName\n              }' with ${formatPercentage(cacheRate)} cached`,\n            });\n          }\n          break;\n\n          case \"callTrace\": {\n            if (!isHistoricalSyncRequired) {\n              this.traceFilterProgressTrackers[source.id] = new ProgressTracker(\n                {\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                },\n              );\n              this.common.metrics.ponder_historical_total_blocks.set(\n                {\n                  network: this.network.name,\n                  source: source.contractName,\n                  type: \"trace\",\n                },\n                0,\n              );\n              this.common.logger.warn({\n                service: \"historical\",\n                msg: `Skipped syncing '${this.network.name}' call traces for '${source.contractName}' because the start block is not finalized`,\n              });\n              return;\n            }\n\n            const completedTraceFilterIntervals =\n              await this.syncStore.getTraceFilterIntervals({\n                chainId: source.chainId,\n                traceFilter: source.criteria,\n              });\n            const traceFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedTraceFilterIntervals,\n            });\n            this.traceFilterProgressTrackers[source.id] =\n              traceFilterProgressTracker;\n\n            const requiredTraceFilterIntervals =\n              traceFilterProgressTracker.getRequired();\n\n            const traceFilterTaskChunks = getChunks({\n              intervals: requiredTraceFilterIntervals,\n              maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n            });\n\n            for (const [fromBlock, toBlock] of traceFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"TRACE_FILTER\",\n                  traceFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (traceFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredTraceFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' TRACE_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredTraceFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' call traces for '${\n                source.contractName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n          case \"factoryCallTrace\": {\n            if (!isHistoricalSyncRequired) {\n              this.factoryChildAddressProgressTrackers[source.id] =\n                new ProgressTracker({\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                });\n              this.factoryTraceFilterProgressTrackers[source.id] =\n                new ProgressTracker({\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                });\n              this.common.metrics.ponder_historical_total_blocks.set(\n                {\n                  network: this.network.name,\n                  source: source.contractName,\n                  type: \"trace\",\n                },\n                0,\n              );\n              this.common.logger.warn({\n                service: \"historical\",\n                msg: `Skipped syncing '${this.network.name}' call traces for '${source.contractName}' because the start block is not finalized`,\n              });\n              return;\n            }\n\n            // Note that factory child address progress is stored using\n            // log intervals for the factory log.\n            const completedFactoryChildAddressIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: {\n                  address: source.criteria.address,\n                  topics: [source.criteria.eventSelector],\n                  includeTransactionReceipts: false,\n                },\n              });\n            const factoryChildAddressProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryChildAddressIntervals,\n            });\n            this.factoryChildAddressProgressTrackers[source.id] =\n              factoryChildAddressProgressTracker;\n\n            const requiredFactoryChildAddressIntervals =\n              factoryChildAddressProgressTracker.getRequired();\n            const factoryChildAddressTaskChunks = getChunks({\n              intervals: requiredFactoryChildAddressIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of factoryChildAddressTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_CHILD_ADDRESS\",\n                  factory: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (factoryChildAddressTaskChunks.length > 0) {\n              const total = intervalSum(requiredFactoryChildAddressIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_CHILD_ADDRESS tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryChildAddressBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryChildAddressBlockCount =\n              targetFactoryChildAddressBlockCount -\n              intervalSum(requiredFactoryChildAddressIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"trace\",\n              },\n              targetFactoryChildAddressBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"trace\",\n              },\n              cachedFactoryChildAddressBlockCount,\n            );\n\n            const completedFactoryTraceFilterIntervals =\n              await this.syncStore.getFactoryTraceFilterIntervals({\n                chainId: source.chainId,\n                factory: source.criteria,\n              });\n            const factoryTraceFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryTraceFilterIntervals,\n            });\n            this.factoryTraceFilterProgressTrackers[source.id] =\n              factoryTraceFilterProgressTracker;\n\n            // Only add factory trace filter tasks for any intervals where the\n            // child address tasks are completed, but the factory trace filter tasks are not,\n            // because these won't be added automatically by child address tasks.\n            const requiredFactoryTraceFilterIntervals =\n              factoryTraceFilterProgressTracker.getRequired();\n            const missingFactoryTraceFilterIntervals = intervalDifference(\n              requiredFactoryTraceFilterIntervals,\n              requiredFactoryChildAddressIntervals,\n            );\n\n            const missingFactoryTraceFilterTaskChunks = getChunks({\n              intervals: missingFactoryTraceFilterIntervals,\n              maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n            });\n\n            for (const [\n              fromBlock,\n              toBlock,\n            ] of missingFactoryTraceFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_TRACE_FILTER\",\n                  factoryTraceFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (missingFactoryTraceFilterTaskChunks.length > 0) {\n              const total = intervalSum(missingFactoryTraceFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_TRACE_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryTraceFilterBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryTraceFilterBlockCount =\n              targetFactoryTraceFilterBlockCount -\n              intervalSum(requiredFactoryTraceFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              targetFactoryTraceFilterBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              cachedFactoryTraceFilterBlockCount,\n            );\n\n            // Use factory trace filter progress for the logger because it better represents\n            // user-facing progress.\n            const cacheRate = Math.min(\n              1,\n              cachedFactoryTraceFilterBlockCount /\n                (targetFactoryTraceFilterBlockCount || 1),\n            );\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' call traces for '${\n                source.contractName\n              }' with ${formatPercentage(cacheRate)} cached`,\n            });\n          }\n          break;\n\n          case \"block\": {\n            if (!isHistoricalSyncRequired) {\n              this.blockFilterProgressTrackers[source.id] = new ProgressTracker(\n                {\n                  target: [startBlock, finalizedBlockNumber],\n                  completed: [[startBlock, finalizedBlockNumber]],\n                },\n              );\n              this.common.metrics.ponder_historical_total_blocks.set(\n                {\n                  network: this.network.name,\n                  source: source.sourceName,\n                  type: \"block\",\n                },\n                0,\n              );\n              this.common.logger.warn({\n                service: \"historical\",\n                msg: `Skipped syncing '${this.network.name}' blocks for '${source.sourceName}' because the start block is not finalized`,\n              });\n              return;\n            }\n\n            const completedBlockFilterIntervals =\n              await this.syncStore.getBlockFilterIntervals({\n                chainId: source.chainId,\n                blockFilter: source.criteria,\n              });\n            const blockFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedBlockFilterIntervals,\n            });\n            this.blockFilterProgressTrackers[source.id] =\n              blockFilterProgressTracker;\n\n            const requiredBlockFilterIntervals =\n              blockFilterProgressTracker.getRequired();\n\n            // block filters are chunked into intervals to avoid unmanageable\n            // amounts of block callbacks being added at once.\n\n            const blockFilterTaskChunks = getChunks({\n              intervals: requiredBlockFilterIntervals,\n              maxChunkSize: this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of blockFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"BLOCK_FILTER\",\n                  blockFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (blockFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredBlockFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' BLOCK_FILTER tasks for '${source.sourceName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredBlockFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.sourceName,\n                type: \"block\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.sourceName,\n                type: \"block\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' blocks for '${\n                source.sourceName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n          default:\n            never(source);\n        }\n      }),\n    );\n  }\n\n  start() {\n    this.common.metrics.ponder_historical_start_timestamp.set(Date.now());\n\n    // Emit status update logs on an interval for each active log filter.\n    this.progressLogInterval = setInterval(async () => {\n      const historical = await getHistoricalSyncProgress(this.common.metrics);\n\n      historical.sources.forEach(\n        ({ networkName, sourceName, progress, eta }) => {\n          if (progress === 1 || networkName !== this.network.name) return;\n          this.common.logger.info({\n            service: \"historical\",\n            msg: `Syncing '${\n              this.network.name\n            }' for '${sourceName}' with ${formatPercentage(\n              progress ?? 0,\n            )} complete${\n              eta !== undefined ? ` and ~${formatEta(eta)} remaining` : \"\"\n            }`,\n          });\n        },\n      );\n    }, 10_000);\n\n    // Edge case: If there are no tasks in the queue, this means the entire\n    // requested range was cached, so the sync is complete.\n    if (this.queue.size === 0) {\n      clearInterval(this.progressLogInterval);\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Finished '${this.network.name}' historical sync`,\n      });\n      this.emit(\"syncComplete\");\n    }\n\n    this.queue.start();\n  }\n\n  kill = () => {\n    this.isShuttingDown = true;\n    clearInterval(this.progressLogInterval);\n    this.queue.pause();\n    this.queue.clear();\n    this.common.logger.debug({\n      service: \"historical\",\n      msg: `Killed '${this.network.name}' historical sync`,\n    });\n  };\n\n  onIdle = () =>\n    new Promise((resolve) =>\n      setImmediate(() => this.queue.onIdle().then(resolve)),\n    );\n\n  private buildQueue = () => {\n    const worker: Worker<HistoricalSyncTask> = async ({ task, queue }) => {\n      switch (task.kind) {\n        case \"FACTORY_CHILD_ADDRESS\": {\n          await this.factoryChildAddressTaskWorker(task);\n          break;\n        }\n        case \"LOG_FILTER\": {\n          await this.logFilterTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_LOG_FILTER\": {\n          await this.factoryLogFilterTaskWorker(task);\n          break;\n        }\n        case \"TRACE_FILTER\": {\n          await this.traceFilterTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_TRACE_FILTER\": {\n          await this.factoryTraceFilterTaskWorker(task);\n          break;\n        }\n        case \"BLOCK_FILTER\": {\n          await this.blockFilterTaskWorker(task);\n          break;\n        }\n        case \"BLOCK\": {\n          await this.blockTaskWorker(task);\n          break;\n        }\n        default:\n          never(task);\n      }\n\n      // If this is not the final task, return.\n      if (queue.size > 0 || queue.pending > 1) return;\n      // If this is the final task but the kill() method has been called, do nothing.\n      if (this.isShuttingDown) return;\n\n      // If this is the final task, run the cleanup/completion logic.\n      clearInterval(this.progressLogInterval);\n      const startTimestamp =\n        (await this.common.metrics.ponder_historical_start_timestamp.get())\n          .values?.[0]?.value ?? Date.now();\n      const duration = Date.now() - startTimestamp;\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Finished '${this.network.name}' historical sync in ${formatEta(\n          duration,\n        )}`,\n      });\n      this.emit(\"syncComplete\");\n    };\n\n    const queue = createQueue<HistoricalSyncTask>({\n      worker,\n      options: {\n        concurrency: this.network.maxHistoricalTaskConcurrency,\n        autoStart: false,\n      },\n      onError: ({ error, task, queue }) => {\n        if (this.isShuttingDown) return;\n\n        switch (task.kind) {\n          case \"FACTORY_CHILD_ADDRESS\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' child address logs for '${task.factory.contractName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' logs for '${task.logFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"FACTORY_LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' logs for '${task.factoryLogFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"TRACE_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' call traces for '${task.traceFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n\n          case \"FACTORY_TRACE_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' call traces for '${task.factoryTraceFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"BLOCK_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' blocks for '${task.blockFilter.sourceName}' from block ${task.fromBlock} to ${task.toBlock} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"BLOCK\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' block ${task.blockNumber} with error: ${error.message}`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.blockNumber;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n\n          default:\n            never(task);\n        }\n\n        this.common.logger.warn({\n          service: \"historical\",\n          msg: `Retrying failed '${this.network.name}' sync task`,\n        });\n      },\n    });\n\n    return queue;\n  };\n\n  private logFilterTaskWorker = async ({\n    logFilter,\n    fromBlock,\n    toBlock,\n  }: LogFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' LOG_FILTER task for '${logFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const logs = await _eth_getLogs(\n      { requestQueue: this.requestQueue },\n      {\n        address: logFilter.criteria.address,\n        topics: logFilter.criteria.topics,\n        fromBlock: toHex(fromBlock),\n        toBlock: toHex(toBlock),\n      },\n    );\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        const { transactionHashes } = logInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n        const transactionReceipts =\n          logFilter.criteria.includeTransactionReceipts === true\n            ? await Promise.all(\n                transactions.map((tx) =>\n                  _eth_getTransactionReceipt(\n                    { requestQueue: this.requestQueue },\n                    { hash: tx.hash },\n                  ),\n                ),\n              )\n            : [];\n\n        await this.syncStore.insertLogFilterInterval({\n          logs: logInterval.logs,\n          interval: {\n            startBlock: BigInt(logInterval.startBlock),\n            endBlock: BigInt(logInterval.endBlock),\n          },\n          logFilter: logFilter.criteria,\n          chainId: logFilter.chainId,\n          block,\n          transactions,\n          transactionReceipts,\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: logFilter.contractName,\n            type: \"log\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.logFilterProgressTrackers[logFilter.id].addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' LOG_FILTER task for '${logFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryLogFilterTaskWorker = async ({\n    factoryLogFilter,\n    fromBlock,\n    toBlock,\n  }: FactoryLogFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_LOG_FILTER task for '${factoryLogFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const iterator = this.syncStore.getFactoryChildAddresses({\n      chainId: factoryLogFilter.chainId,\n      factory: factoryLogFilter.criteria,\n      fromBlock: BigInt(factoryLogFilter.startBlock),\n      toBlock: BigInt(toBlock),\n    });\n\n    const logs: RpcLog[] = [];\n    for await (const childContractAddressBatch of iterator) {\n      const _logs = await _eth_getLogs(\n        { requestQueue: this.requestQueue },\n        {\n          address: childContractAddressBatch,\n          topics: factoryLogFilter.criteria.topics,\n          fromBlock: numberToHex(fromBlock),\n          toBlock: numberToHex(toBlock),\n        },\n      );\n      logs.push(..._logs);\n    }\n\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock, logs, transactionHashes } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n        const transactionReceipts =\n          factoryLogFilter.criteria.includeTransactionReceipts === true\n            ? await Promise.all(\n                transactions.map((tx) =>\n                  _eth_getTransactionReceipt(\n                    { requestQueue: this.requestQueue },\n                    { hash: tx.hash },\n                  ),\n                ),\n              )\n            : [];\n\n        await this.syncStore.insertFactoryLogFilterInterval({\n          chainId: factoryLogFilter.chainId,\n          factory: factoryLogFilter.criteria,\n          block,\n          transactions,\n          transactionReceipts,\n          logs,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: factoryLogFilter.contractName,\n            type: \"log\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.factoryLogFilterProgressTrackers[\n      factoryLogFilter.id\n    ].addCompletedInterval([fromBlock, toBlock]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_LOG_FILTER task for '${factoryLogFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryChildAddressTaskWorker = async ({\n    factory,\n    fromBlock,\n    toBlock,\n  }: FactoryChildAddressTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_CHILD_ADDRESS task for '${factory.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const logs = await _eth_getLogs(\n      { requestQueue: this.requestQueue },\n      {\n        address: factory.criteria.address,\n        topics: [factory.criteria.eventSelector],\n        fromBlock: toHex(fromBlock),\n        toBlock: toHex(toBlock),\n      },\n    );\n\n    // Insert the new child address logs into the store.\n    await this.syncStore.insertFactoryChildAddressLogs({\n      chainId: factory.chainId,\n      logs,\n    });\n\n    // Register block callbacks for the child address logs. This is how\n    // the intervals will be recorded (marking the child address logs as\n    // cached on subsequent starts).\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n    for (const logInterval of logIntervals) {\n      if (this.blockCallbacks[logInterval.endBlock] === undefined)\n        this.blockCallbacks[logInterval.endBlock] = [];\n\n      this.blockCallbacks[logInterval.endBlock].push(async (block) => {\n        const { transactionHashes } = logInterval;\n\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertLogFilterInterval({\n          logs: logInterval.logs,\n          interval: {\n            startBlock: BigInt(logInterval.startBlock),\n            endBlock: BigInt(logInterval.endBlock),\n          },\n          logFilter: {\n            address: factory.criteria.address,\n            topics: [factory.criteria.eventSelector],\n            includeTransactionReceipts: false,\n          },\n          chainId: factory.chainId,\n          block,\n          transactions,\n          transactionReceipts: [],\n        });\n      });\n    }\n\n    // Update the checkpoint, and if necessary, enqueue factory log filter tasks.\n    const { isUpdated, prevCheckpoint, newCheckpoint } =\n      this.factoryChildAddressProgressTrackers[factory.id].addCompletedInterval(\n        [fromBlock, toBlock],\n      );\n\n    switch (factory.type) {\n      case \"factoryLog\": {\n        if (isUpdated) {\n          // It's possible for the factory log filter to have already completed some or\n          // all of the block interval here. To avoid duplicates, only add intervals that\n          // are still marked as required.\n          const requiredIntervals = intervalIntersection(\n            [[prevCheckpoint + 1, newCheckpoint]],\n            this.factoryLogFilterProgressTrackers[factory.id].getRequired(),\n          );\n          const factoryLogFilterChunks = getChunks({\n            intervals: requiredIntervals,\n            maxChunkSize:\n              factory.maxBlockRange ?? this.network.defaultMaxBlockRange,\n          });\n\n          for (const [fromBlock, toBlock] of factoryLogFilterChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_LOG_FILTER\",\n                factoryLogFilter: factory,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n        }\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: `${factory.contractName}_factory`,\n            type: \"log\",\n          },\n          toBlock - fromBlock + 1,\n        );\n        break;\n      }\n\n      case \"factoryCallTrace\": {\n        if (isUpdated) {\n          // It's possible for the factory log filter to have already completed some or\n          // all of the block interval here. To avoid duplicates, only add intervals that\n          // are still marked as required.\n          const requiredIntervals = intervalIntersection(\n            [[prevCheckpoint + 1, newCheckpoint]],\n            this.factoryTraceFilterProgressTrackers[factory.id].getRequired(),\n          );\n          const factoryTraceFilterChunks = getChunks({\n            intervals: requiredIntervals,\n            maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n          });\n\n          for (const [fromBlock, toBlock] of factoryTraceFilterChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_TRACE_FILTER\",\n                factoryTraceFilter: factory,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n        }\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: `${factory.contractName}_factory`,\n            type: \"trace\",\n          },\n          toBlock - fromBlock + 1,\n        );\n        break;\n      }\n\n      default:\n        never(factory);\n    }\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_CHILD_ADDRESS task for '${factory.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private blockFilterTaskWorker = async ({\n    blockFilter,\n    fromBlock,\n    toBlock,\n  }: BlockFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' BLOCK_FILTER task for '${blockFilter.sourceName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const baseOffset =\n      (fromBlock - blockFilter.criteria.offset) % blockFilter.criteria.interval;\n    const offset =\n      baseOffset === 0 ? 0 : blockFilter.criteria.interval - baseOffset;\n\n    // Determine which blocks are matched by the block filter, and add a callback for\n    // each block. A block callback, and subsequent \"eth_getBlock\" request can be\n    // skipped if the block is already present in the database.\n\n    const requiredBlocks: number[] = [];\n    for (\n      let blockNumber = fromBlock + offset;\n      blockNumber <= toBlock;\n      blockNumber += blockFilter.criteria.interval\n    ) {\n      requiredBlocks.push(blockNumber);\n    }\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the eth_getLogs request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    let prevBlockNumber = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      const hasBlock = await this.syncStore.getBlock({\n        chainId: blockFilter.chainId,\n        blockNumber,\n      });\n\n      const startBlock = prevBlockNumber;\n      const endBlock = blockNumber;\n\n      if (hasBlock) {\n        await this.syncStore.insertBlockFilterInterval({\n          chainId: blockFilter.chainId,\n          blockFilter: blockFilter.criteria,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: blockFilter.sourceName,\n            type: \"block\",\n          },\n          endBlock - startBlock + 1,\n        );\n      } else {\n        if (this.blockCallbacks[blockNumber] === undefined)\n          this.blockCallbacks[blockNumber] = [];\n\n        this.blockCallbacks[blockNumber].push(async (block) => {\n          await this.syncStore.insertBlockFilterInterval({\n            chainId: blockFilter.chainId,\n            blockFilter: blockFilter.criteria,\n            block,\n            interval: {\n              startBlock: BigInt(startBlock),\n              endBlock: BigInt(endBlock),\n            },\n          });\n\n          this.common.metrics.ponder_historical_completed_blocks.inc(\n            {\n              network: this.network.name,\n              source: blockFilter.sourceName,\n              type: \"block\",\n            },\n            endBlock - startBlock + 1,\n          );\n        });\n      }\n\n      prevBlockNumber = blockNumber + 1;\n    }\n\n    this.blockFilterProgressTrackers[blockFilter.id].addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' BLOCK_FILTER task for '${blockFilter.sourceName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private traceFilterTaskWorker = async ({\n    traceFilter,\n    fromBlock,\n    toBlock,\n  }: TraceFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' TRACE_FILTER task for '${traceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const traces = await _trace_filter(\n      { requestQueue: this.requestQueue },\n      {\n        fromBlock,\n        toBlock,\n        fromAddress: traceFilter.criteria.fromAddress,\n        toAddress: traceFilter.criteria.toAddress,\n      },\n    ).then(\n      (traces) => traces.filter((t) => t.type === \"call\") as SyncCallTrace[],\n    );\n\n    // Request transactionReceipts to check for reverted transactions.\n    const transactionReceipts = await Promise.all(\n      dedupe(traces.map((t) => t.transactionHash)).map((hash) =>\n        _eth_getTransactionReceipt(\n          {\n            requestQueue: this.requestQueue,\n          },\n          {\n            hash,\n          },\n        ),\n      ),\n    );\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    const persistentTraces = traces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    const tracesByBlockNumber: Record<number, SyncCallTrace[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    for (const trace of persistentTraces) {\n      const blockNumber = hexToNumber(trace.blockNumber);\n\n      if (tracesByBlockNumber[blockNumber] === undefined) {\n        tracesByBlockNumber[blockNumber] = [];\n      }\n      if (txHashesByBlockNumber[blockNumber] === undefined) {\n        txHashesByBlockNumber[blockNumber] = new Set<Hash>();\n      }\n\n      tracesByBlockNumber[blockNumber]!.push(trace);\n      txHashesByBlockNumber[blockNumber]!.add(trace.transactionHash);\n    }\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the trace_filter request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const traceIntervals: {\n      startBlock: number;\n      endBlock: number;\n      traces: SyncCallTrace[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      traceIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        traces: tracesByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    for (const traceInterval of traceIntervals) {\n      const { startBlock, endBlock } = traceInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        const { transactionHashes } = traceInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertTraceFilterInterval({\n          traces: traceInterval.traces,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n          traceFilter: traceFilter.criteria,\n          chainId: traceFilter.chainId,\n          block,\n          transactions,\n          // trace intervals always include transaction receipts because\n          // the transactions receipts are already needed determine the\n          // persistence of a trace.\n          transactionReceipts: transactionReceipts.filter((txr) =>\n            transactionHashes.has(txr.transactionHash),\n          ),\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: traceFilter.contractName,\n            type: \"trace\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n    this.traceFilterProgressTrackers[traceFilter.id].addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' TRACE_FILTER task for '${traceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryTraceFilterTaskWorker = async ({\n    factoryTraceFilter,\n    fromBlock,\n    toBlock,\n  }: FactoryTraceFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_TRACE_FILTER task for '${factoryTraceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const iterator = this.syncStore.getFactoryChildAddresses({\n      chainId: factoryTraceFilter.chainId,\n      factory: factoryTraceFilter.criteria,\n      fromBlock: BigInt(factoryTraceFilter.startBlock),\n      toBlock: BigInt(toBlock),\n    });\n\n    const traces: SyncCallTrace[] = [];\n    for await (const childContractAddressBatch of iterator) {\n      const _traces = await _trace_filter(\n        { requestQueue: this.requestQueue },\n        {\n          fromBlock,\n          toBlock,\n          fromAddress: factoryTraceFilter.criteria.fromAddress,\n          toAddress: childContractAddressBatch,\n        },\n      ).then(\n        (traces) => traces.filter((t) => t.type === \"call\") as SyncCallTrace[],\n      );\n      traces.push(..._traces);\n    }\n\n    // Request transactionReceipts to check for reverted transactions.\n    const transactionReceipts = await Promise.all(\n      dedupe(traces.map((t) => t.transactionHash)).map((hash) =>\n        _eth_getTransactionReceipt(\n          {\n            requestQueue: this.requestQueue,\n          },\n          {\n            hash,\n          },\n        ),\n      ),\n    );\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    const persistentTraces = traces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    const tracesByBlockNumber: Record<number, SyncCallTrace[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    for (const trace of persistentTraces) {\n      const blockNumber = hexToNumber(trace.blockNumber);\n\n      if (tracesByBlockNumber[blockNumber] === undefined) {\n        tracesByBlockNumber[blockNumber] = [];\n      }\n      if (txHashesByBlockNumber[blockNumber] === undefined) {\n        txHashesByBlockNumber[blockNumber] = new Set<Hash>();\n      }\n\n      tracesByBlockNumber[blockNumber]!.push(trace);\n      txHashesByBlockNumber[blockNumber]!.add(trace.transactionHash);\n    }\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the trace_filter request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const traceIntervals: {\n      startBlock: number;\n      endBlock: number;\n      traces: SyncCallTrace[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      traceIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        traces: tracesByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    for (const traceInterval of traceIntervals) {\n      const { startBlock, endBlock } = traceInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        const { transactionHashes } = traceInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertFactoryTraceFilterInterval({\n          chainId: factoryTraceFilter.chainId,\n          factory: factoryTraceFilter.criteria,\n          block,\n          transactions,\n          // factory trace intervals always include transaction receipts because\n          // the transactions receipts are already needed determine the\n          // persistence of a trace.\n          transactionReceipts: transactionReceipts.filter((txr) =>\n            transactionHashes.has(txr.transactionHash),\n          ),\n          traces: traceInterval.traces,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: factoryTraceFilter.contractName,\n            type: \"trace\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.factoryTraceFilterProgressTrackers[\n      factoryTraceFilter.id\n    ].addCompletedInterval([fromBlock, toBlock]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_TRACE_FILTER task for '${factoryTraceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private blockTaskWorker = async ({ blockNumber, callbacks }: BlockTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' BLOCK task for block ${blockNumber} with ${callbacks.length} callbacks`,\n    });\n\n    const block = await _eth_getBlockByNumber(\n      { requestQueue: this.requestQueue },\n      {\n        blockNumber,\n      },\n    );\n\n    for (const callback of callbacks) {\n      await callback(block);\n    }\n\n    const newBlockCheckpoint = this.blockProgressTracker.addCompletedBlock({\n      blockNumber,\n      blockTimestamp: hexToNumber(block.timestamp),\n    });\n\n    if (newBlockCheckpoint) {\n      this.debouncedEmitCheckpoint.call({\n        ...maxCheckpoint,\n        blockTimestamp: newBlockCheckpoint.blockTimestamp,\n        chainId: BigInt(this.network.chainId),\n        blockNumber: BigInt(newBlockCheckpoint.blockNumber),\n      });\n    }\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' BLOCK task for block ${blockNumber} with ${callbacks.length} callbacks`,\n    });\n  };\n\n  private buildLogIntervals = ({\n    fromBlock,\n    toBlock,\n    logs,\n  }: {\n    fromBlock: number;\n    toBlock: number;\n    logs: RpcLog[];\n  }) => {\n    const logsByBlockNumber: Record<number, RpcLog[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    logs.forEach((log) => {\n      const blockNumber = hexToNumber(log.blockNumber!);\n      (txHashesByBlockNumber[blockNumber] ||= new Set<Hash>()).add(\n        log.transactionHash!,\n      );\n      (logsByBlockNumber[blockNumber] ||= []).push(log);\n    });\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the eth_getLogs request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const requiredIntervals: {\n      startBlock: number;\n      endBlock: number;\n      logs: RpcLog[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      requiredIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        logs: logsByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    return requiredIntervals;\n  };\n\n  private enqueueBlockTasks = () => {\n    // If a source has an endBlock and is completed, its checkpoint\n    // will be equal to its endBlock. This poses a problem if other sources\n    // don't have an endBlock and are still in progress, because this value\n    // will get \"stuck\" at the endBlock. To avoid this, filter out any sources\n    // that have no more required intervals.\n    const blockTasksCanBeEnqueuedTo = Math.min(\n      ...[\n        ...Object.values(this.logFilterProgressTrackers),\n        ...Object.values(this.factoryChildAddressProgressTrackers),\n        ...Object.values(this.factoryLogFilterProgressTrackers),\n        ...Object.values(this.traceFilterProgressTrackers),\n        ...Object.values(this.factoryTraceFilterProgressTrackers),\n        ...Object.values(this.blockFilterProgressTrackers),\n      ]\n        .filter((i) => i.getRequired().length > 0)\n        .map((i) => i.getCheckpoint()),\n    );\n\n    if (blockTasksCanBeEnqueuedTo > this.blockTasksEnqueuedCheckpoint) {\n      const newBlocks = Object.keys(this.blockCallbacks)\n        .map(Number)\n        .filter((blockNumber) => blockNumber <= blockTasksCanBeEnqueuedTo);\n\n      this.blockProgressTracker.addPendingBlocks({ blockNumbers: newBlocks });\n\n      for (const blockNumber of newBlocks) {\n        this.queue.addTask(\n          {\n            kind: \"BLOCK\",\n            blockNumber,\n            callbacks: this.blockCallbacks[blockNumber],\n          },\n          { priority: Number.MAX_SAFE_INTEGER - blockNumber },\n        );\n        delete this.blockCallbacks[blockNumber];\n      }\n\n      this.blockTasksEnqueuedCheckpoint = blockTasksCanBeEnqueuedTo;\n    }\n  };\n\n  private debouncedEmitCheckpoint = debounce(\n    HISTORICAL_CHECKPOINT_EMIT_INTERVAL,\n    (checkpoint: Checkpoint) => {\n      this.emit(\"historicalCheckpoint\", checkpoint);\n    },\n  );\n}\n","export function validateHistoricalBlockRange({\n  startBlock,\n  endBlock: userDefinedEndBlock,\n  finalizedBlockNumber,\n  latestBlockNumber,\n}: {\n  startBlock: number;\n  endBlock?: number;\n  finalizedBlockNumber: number;\n  latestBlockNumber: number;\n}) {\n  if (startBlock > latestBlockNumber) {\n    throw new Error(\n      `Start block number (${startBlock}) cannot be greater than latest block number (${latestBlockNumber}).\n         Are you sure the RPC endpoint is for the correct network?`,\n    );\n  }\n\n  if (startBlock > finalizedBlockNumber) {\n    // If the start block is in the unfinalized range, the historical sync is not needed.\n    // Set the checkpoint to the current timestamp, then return (don't create the queue).\n    return {\n      isHistoricalSyncRequired: false,\n      startBlock,\n      endBlock: userDefinedEndBlock,\n    } as const;\n  }\n\n  if (userDefinedEndBlock) {\n    if (userDefinedEndBlock < startBlock) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be less than start block number (${startBlock}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n\n    if (userDefinedEndBlock > latestBlockNumber) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be greater than latest block number (${latestBlockNumber}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n\n    if (userDefinedEndBlock > finalizedBlockNumber) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be greater than finalized block number (${finalizedBlockNumber}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n  }\n\n  const resolvedEndBlock = userDefinedEndBlock ?? finalizedBlockNumber;\n\n  return {\n    isHistoricalSyncRequired: true,\n    startBlock,\n    endBlock: resolvedEndBlock,\n  } as const;\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type BlockSource,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type SyncBlock,\n  type SyncCallTrace,\n  type SyncLog,\n  _eth_getBlockByHash,\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_block,\n} from \"@/sync/index.js\";\nimport { type Checkpoint, maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { range } from \"@/utils/range.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport { type Address, type Hash, hexToNumber } from \"viem\";\nimport { isMatchedLogInBloomFilter, zeroLogsBloom } from \"./bloom.js\";\nimport { filterCallTraces, filterLogs } from \"./filter.js\";\nimport { type LightBlock, syncBlockToLightBlock } from \"./format.js\";\n\nexport type Service = {\n  // static\n  common: Common;\n  syncStore: SyncStore;\n  network: Network;\n  requestQueue: RequestQueue;\n  sources: EventSource[];\n\n  // state\n  isKilled: boolean;\n  finalizedBlock: LightBlock;\n  /**\n   * Blocks and logs that have been ingested and are\n   * waiting to be finalized. It is an invariant that\n   * all blocks are linked to each other,\n   * `parentHash` => `hash`.\n   */\n  localChain: LightBlock[];\n  queue: Queue<void, SyncBlock> | undefined;\n  consecutiveErrors: number;\n\n  // callbacks\n  onEvent: (event: RealtimeSyncEvent) => void;\n  onFatalError: (error: Error) => void;\n\n  // derived static\n  hasTransactionReceiptSource: boolean;\n  logSources: LogSource[];\n  factoryLogSources: FactoryLogSource[];\n  callTraceSources: CallTraceSource[];\n  factoryCallTraceSources: FactoryCallTraceSource[];\n  blockSources: BlockSource[];\n};\n\nexport type RealtimeSyncEvent =\n  | {\n      type: \"reorg\";\n      chainId: number;\n      safeCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"checkpoint\";\n      chainId: number;\n      checkpoint: Checkpoint;\n    }\n  | {\n      type: \"finalize\";\n      chainId: number;\n      checkpoint: Checkpoint;\n    };\n\nconst ERROR_TIMEOUT = [\n  1, 2, 5, 10, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n] as const;\nconst MAX_QUEUED_BLOCKS = 25;\n\nexport const create = ({\n  common,\n  syncStore,\n  network,\n  requestQueue,\n  sources,\n  finalizedBlock,\n  onEvent,\n  onFatalError,\n}: {\n  common: Common;\n  syncStore: SyncStore;\n  network: Network;\n  requestQueue: RequestQueue;\n  sources: EventSource[];\n  finalizedBlock: SyncBlock;\n  onEvent: (event: RealtimeSyncEvent) => void;\n  onFatalError: (error: Error) => void;\n}): Service => {\n  const logSources = sources.filter(sourceIsLog);\n  const factoryLogSources = sources.filter(sourceIsFactoryLog);\n  const blockSources = sources.filter(sourceIsBlock);\n  const callTraceSources = sources.filter(sourceIsCallTrace);\n  const factoryCallTraceSources = sources.filter(sourceIsFactoryCallTrace);\n\n  return {\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources,\n    isKilled: false,\n    finalizedBlock: syncBlockToLightBlock(finalizedBlock),\n    localChain: [],\n    queue: undefined,\n    consecutiveErrors: 0,\n    onEvent,\n    onFatalError,\n    hasTransactionReceiptSource:\n      logSources.some((s) => s.criteria.includeTransactionReceipts) ||\n      factoryLogSources.some((s) => s.criteria.includeTransactionReceipts),\n    logSources,\n    factoryLogSources,\n    callTraceSources,\n    factoryCallTraceSources,\n    blockSources,\n  };\n};\n\nexport const start = (service: Service) => {\n  /**\n   * The queue reacts to a new block. The four states are:\n   * 1) Block is the same as the one just processed, no-op.\n   * 2) Block is exactly one block ahead of the last processed,\n   *    handle this new block (happy path).\n   * 3) Block is more than one ahead of the last processed,\n   *    fetch all intermediate blocks and enqueue them again.\n   * 4) Block is behind the last processed. This is a sign that\n   *    a reorg has occurred.\n   */\n  const queue = createQueue({\n    browser: false,\n    concurrency: 1,\n    initialStart: true,\n    worker: async (newHeadBlock: SyncBlock) => {\n      const latestLocalBlock = getLatestLocalBlock(service);\n      const newHeadBlockNumber = hexToNumber(newHeadBlock.number);\n\n      // We already saw and handled this block. No-op.\n      if (latestLocalBlock.hash === newHeadBlock.hash) {\n        service.common.logger.trace({\n          service: \"realtime\",\n          msg: `Skipped processing '${service.network.name}' block ${newHeadBlockNumber}, already synced`,\n        });\n\n        return;\n      }\n\n      try {\n        // Quickly check for a reorg by comparing block numbers. If the block\n        // number has not increased, a reorg must have occurred.\n        if (latestLocalBlock.number >= newHeadBlockNumber) {\n          await handleReorg(service, newHeadBlock);\n\n          queue.clear();\n          return;\n        }\n\n        // Blocks are missing. They should be fetched and enqueued.\n        if (latestLocalBlock.number + 1 < newHeadBlockNumber) {\n          // Retrieve missing blocks, but only fetch a certain amount.\n          const missingBlockRange = range(\n            latestLocalBlock.number + 1,\n            Math.min(\n              newHeadBlockNumber,\n              latestLocalBlock.number + MAX_QUEUED_BLOCKS,\n            ),\n          );\n          const pendingBlocks = await Promise.all(\n            missingBlockRange.map((blockNumber) =>\n              _eth_getBlockByNumber(service, { blockNumber }),\n            ),\n          );\n\n          service.common.logger.debug({\n            service: \"realtime\",\n            msg: `Fetched ${missingBlockRange.length} missing '${\n              service.network.name\n            }' blocks from ${latestLocalBlock.number + 1} to ${Math.min(\n              newHeadBlockNumber,\n              latestLocalBlock.number + MAX_QUEUED_BLOCKS,\n            )}`,\n          });\n\n          // This is needed to ensure proper `kill()` behavior. When the service\n          // is killed, nothing should be added to the queue, or else `onIdle()`\n          // will never resolve.\n          if (service.isKilled) return;\n\n          queue.clear();\n\n          for (const pendingBlock of pendingBlocks) {\n            queue.add(pendingBlock);\n          }\n\n          queue.add(newHeadBlock);\n\n          return;\n        }\n\n        // Check if a reorg occurred by validating the chain of block hashes.\n        if (newHeadBlock.parentHash !== latestLocalBlock.hash) {\n          await handleReorg(service, newHeadBlock);\n          queue.clear();\n          return;\n        }\n\n        // New block is exactly one block ahead of the local chain.\n        // Attempt to ingest it.\n        await handleBlock(service, { newHeadBlock });\n\n        // Reset the error state after successfully completing the happy path.\n        service.consecutiveErrors = 0;\n\n        return;\n      } catch (_error) {\n        if (service.isKilled) return;\n\n        const error = _error as Error;\n\n        service.common.logger.warn({\n          service: \"realtime\",\n          msg: `Failed to process '${service.network.name}' block ${newHeadBlockNumber} with error: ${error.message}`,\n        });\n\n        const duration = ERROR_TIMEOUT[service.consecutiveErrors];\n\n        service.common.logger.warn({\n          service: \"realtime\",\n          msg: `Retrying '${service.network.name}' sync after ${duration} ${\n            duration === 1 ? \"second\" : \"seconds\"\n          }.`,\n        });\n\n        await wait(duration * 1_000);\n\n        // Remove all blocks from the queue. This protects against an\n        // erroneous block causing a fatal error.\n        queue.clear();\n\n        // After a certain number of attempts, emit a fatal error.\n        if (++service.consecutiveErrors === ERROR_TIMEOUT.length) {\n          service.common.logger.error({\n            service: \"realtime\",\n            msg: `Fatal error: Unable to process '${service.network.name}' block ${newHeadBlockNumber} after ${ERROR_TIMEOUT.length} attempts.`,\n            error,\n          });\n\n          service.onFatalError(error);\n        }\n      }\n    },\n  });\n\n  const enqueue = async () => {\n    try {\n      const block = await _eth_getBlockByNumber(service, {\n        blockTag: \"latest\",\n      });\n\n      return queue.add(block);\n    } catch (_error) {\n      if (service.isKilled) return;\n\n      const error = _error as Error;\n\n      service.common.logger.warn({\n        service: \"realtime\",\n        msg: `Failed to fetch latest '${service.network.name}' block with error: ${error.message}`,\n      });\n    }\n  };\n\n  setInterval(enqueue, service.network.pollingInterval);\n\n  service.queue = queue;\n\n  // Note: this is done just for testing.\n  return enqueue().then(() => queue);\n};\n\nexport const kill = async (service: Service) => {\n  service.isKilled = true;\n  service.queue?.pause();\n  service.queue?.clear();\n  await service.queue?.onIdle();\n};\n\n/**\n * 1) Determine if a reorg occurred.\n * 2) Insert new event data into the store.\n * 3) Determine if a new range of events has become finalized,\n *    if so insert interval to store and remove the finalized data.\n *\n * @param newHeadBlock Block to be injested. Must be exactly\n * 1 block ahead of the local chain.\n * @returns true if a reorg occurred\n */\nexport const handleBlock = async (\n  service: Service,\n  { newHeadBlock }: { newHeadBlock: SyncBlock },\n) => {\n  const newHeadBlockNumber = hexToNumber(newHeadBlock.number);\n  const newHeadBlockTimestamp = hexToNumber(newHeadBlock.timestamp);\n\n  service.common.logger.debug({\n    service: \"realtime\",\n    msg: `Started syncing '${service.network.name}' block ${newHeadBlockNumber}`,\n  });\n\n  // \"eth_getLogs\" calls can be skipped if a negative match is given from \"logsBloom\".\n  const shouldRequestLogs =\n    service.factoryLogSources.length > 0 ||\n    newHeadBlock.logsBloom === zeroLogsBloom ||\n    isMatchedLogInBloomFilter({\n      bloom: newHeadBlock.logsBloom,\n      logFilters: service.logSources.map((s) => s.criteria),\n    });\n  const shouldRequestTraces =\n    service.callTraceSources.length > 0 ||\n    service.factoryCallTraceSources.length > 0;\n\n  // Request logs\n  const blockLogs = shouldRequestLogs\n    ? await _eth_getLogs(service, { blockHash: newHeadBlock.hash })\n    : [];\n  const newLogs = await getMatchedLogs(service, {\n    logs: blockLogs,\n    upToBlockNumber: BigInt(newHeadBlockNumber),\n  });\n\n  // Protect against RPCs returning empty logs. Known to happen near chain tip.\n  if (\n    shouldRequestLogs &&\n    newHeadBlock.logsBloom !== zeroLogsBloom &&\n    blockLogs.length === 0\n  ) {\n    throw new Error(\n      `Detected invalid '${service.network.name}' eth_getLogs response.`,\n    );\n  }\n\n  if (\n    shouldRequestLogs &&\n    (service.logSources.length > 0 || service.factoryLogSources.length > 0)\n  ) {\n    service.common.logger.debug({\n      service: \"realtime\",\n      msg: `Skipped fetching logs for '${service.network.name}' block ${newHeadBlockNumber} due to bloom filter result`,\n    });\n  }\n\n  // Request traces\n  const blockTraces = shouldRequestTraces\n    ? await _trace_block(service, {\n        blockNumber: newHeadBlockNumber,\n      })\n    : [];\n  const blockCallTraces = blockTraces.filter(\n    (trace) => trace.type === \"call\",\n  ) as SyncCallTrace[];\n  const newCallTraces = await getMatchedCallTraces(service, {\n    callTraces: blockCallTraces,\n    logs: blockLogs,\n    upToBlockNumber: BigInt(newHeadBlockNumber),\n  });\n\n  // Check that traces refer to the correct block\n  for (const callTrace of newCallTraces) {\n    if (callTrace.blockHash !== newHeadBlock.hash) {\n      throw new Error(\n        `Received call trace with block hash '${callTrace.blockHash}' that does not match current head block '${newHeadBlock.hash}'`,\n      );\n    }\n  }\n\n  // Protect against RPCs returning empty traces. Known to happen near chain tip.\n  // Use the fact that any stateRoot change produces a trace.\n  if (\n    shouldRequestTraces &&\n    newHeadBlock.transactions.length !== 0 &&\n    blockTraces.length === 0\n  ) {\n    throw new Error(\n      `Detected invalid '${service.network.name}' trace_block response.`,\n    );\n  }\n\n  const transactionHashes = new Set<Hash>();\n  for (const log of newLogs) {\n    transactionHashes.add(log.transactionHash);\n  }\n  for (const callTrace of newCallTraces) {\n    transactionHashes.add(callTrace.transactionHash);\n  }\n\n  const transactions = newHeadBlock.transactions.filter((t) =>\n    transactionHashes.has(t.hash),\n  );\n\n  const newTransactionReceipts =\n    service.hasTransactionReceiptSource || newCallTraces.length > 0\n      ? await Promise.all(\n          transactions.map(({ hash }) =>\n            _eth_getTransactionReceipt(service, { hash }),\n          ),\n        )\n      : [];\n\n  // Filter out reverted call traces\n  const revertedTransactions = new Set<Hash>();\n  for (const receipt of newTransactionReceipts) {\n    if (receipt.status === \"0x0\") {\n      revertedTransactions.add(receipt.transactionHash);\n    }\n  }\n\n  const newPersistentCallTraces = newCallTraces.filter(\n    (trace) => revertedTransactions.has(trace.transactionHash) === false,\n  );\n\n  // Add pending event data to sync store and local event data. Ordering is\n  // important because the sync store operation may throw an error, causing a retry.\n\n  const hasLogEvent = newLogs.length > 0;\n  const hasCallTraceEvent = newPersistentCallTraces.length > 0;\n  const hasBlockEvent = service.blockSources.some(\n    (blockSource) =>\n      (newHeadBlockNumber - blockSource.criteria.offset) %\n        blockSource.criteria.interval ===\n      0,\n  );\n\n  if (hasLogEvent || hasCallTraceEvent || hasBlockEvent) {\n    await service.syncStore.insertRealtimeBlock({\n      chainId: service.network.chainId,\n      block: newHeadBlock,\n      transactions,\n      transactionReceipts: newTransactionReceipts,\n      logs: newLogs,\n      traces: newPersistentCallTraces,\n    });\n  }\n\n  if (hasLogEvent || hasCallTraceEvent) {\n    const logCountText =\n      newLogs.length === 1 ? \"1 log\" : `${newLogs.length} logs`;\n    const traceCountText =\n      newCallTraces.length === 1\n        ? \"1 call trace\"\n        : `${newCallTraces.length} call traces`;\n    const text = [logCountText, traceCountText].join(\" and \");\n    service.common.logger.info({\n      service: \"realtime\",\n      msg: `Synced ${text} from '${service.network.name}' block ${newHeadBlockNumber}`,\n    });\n  } else if (hasBlockEvent) {\n    service.common.logger.info({\n      service: \"realtime\",\n      msg: `Synced block ${newHeadBlockNumber} from '${service.network.name}' `,\n    });\n  }\n\n  service.onEvent({\n    type: \"checkpoint\",\n    chainId: service.network.chainId,\n    checkpoint: {\n      ...maxCheckpoint,\n      blockTimestamp: newHeadBlockTimestamp,\n      chainId: BigInt(service.network.chainId),\n      blockNumber: BigInt(newHeadBlockNumber),\n    } satisfies Checkpoint,\n  });\n\n  service.localChain.push(syncBlockToLightBlock(newHeadBlock));\n\n  service.common.metrics.ponder_realtime_latest_block_number.set(\n    { network: service.network.name },\n    newHeadBlockNumber,\n  );\n  service.common.metrics.ponder_realtime_latest_block_timestamp.set(\n    { network: service.network.name },\n    newHeadBlockTimestamp,\n  );\n\n  // Determine if a new range has become finalized by evaluating if the\n  // latest block number is 2 * finalityBlockCount >= finalized block number.\n  // Essentially, there is a range the width of finalityBlockCount that is entirely\n  // finalized.\n  const blockMovesFinality =\n    newHeadBlockNumber >=\n    service.finalizedBlock.number + 2 * service.network.finalityBlockCount;\n  if (blockMovesFinality) {\n    const pendingFinalizedBlock = service.localChain.find(\n      (block) =>\n        block.number ===\n        newHeadBlockNumber - service.network.finalityBlockCount,\n    )!;\n\n    // Insert cache intervals into the store and update the local chain.\n    // Ordering is important here because the database query can fail.\n    await service.syncStore.insertRealtimeInterval({\n      chainId: service.network.chainId,\n      logFilters: service.logSources.map((l) => l.criteria),\n      factoryLogFilters: service.factoryLogSources.map((f) => f.criteria),\n      blockFilters: service.blockSources.map((b) => b.criteria),\n      traceFilters: service.callTraceSources.map((f) => f.criteria),\n      factoryTraceFilters: service.factoryCallTraceSources.map(\n        (f) => f.criteria,\n      ),\n      interval: {\n        startBlock: BigInt(service.finalizedBlock.number + 1),\n        endBlock: BigInt(pendingFinalizedBlock.number),\n      },\n    });\n\n    service.common.logger.debug({\n      service: \"realtime\",\n      msg: `Finalized ${\n        pendingFinalizedBlock.number - service.finalizedBlock.number + 1\n      } '${service.network.name}' blocks from ${\n        service.finalizedBlock.number + 1\n      } to ${pendingFinalizedBlock.number}`,\n    });\n\n    service.localChain = service.localChain.filter(\n      (block) => block.number > pendingFinalizedBlock.number,\n    );\n\n    service.finalizedBlock = pendingFinalizedBlock;\n\n    service.onEvent({\n      type: \"finalize\",\n      chainId: service.network.chainId,\n      checkpoint: {\n        ...maxCheckpoint,\n        blockTimestamp: service.finalizedBlock.timestamp,\n        chainId: BigInt(service.network.chainId),\n        blockNumber: BigInt(service.finalizedBlock.number),\n      } satisfies Checkpoint,\n    });\n  }\n\n  service.common.logger.debug({\n    service: \"realtime\",\n    msg: `Finished syncing '${service.network.name}' block ${newHeadBlockNumber}`,\n  });\n};\n\n/**\n * Traverse the remote chain until we find a block that is\n * compatible with out local chain.\n *\n * @param newHeadBlock Block that caused reorg to be detected.\n * Must be at most 1 block ahead of the local chain.\n */\nexport const handleReorg = async (\n  service: Service,\n  newHeadBlock: SyncBlock,\n) => {\n  const forkedBlockNumber = hexToNumber(newHeadBlock.number);\n\n  service.common.logger.warn({\n    service: \"realtime\",\n    msg: `Detected forked '${service.network.name}' block at height ${forkedBlockNumber}`,\n  });\n\n  // Prune the local chain of blocks that have been reorged out\n  const newLocalChain = service.localChain.filter(\n    (block) => block.number < forkedBlockNumber,\n  );\n\n  // Block we are attempting to fit into the local chain.\n  let remoteBlock = newHeadBlock;\n\n  while (true) {\n    const parentBlock = getLatestLocalBlock({\n      localChain: newLocalChain,\n      finalizedBlock: service.finalizedBlock,\n    });\n\n    if (parentBlock.hash === remoteBlock.parentHash) {\n      await service.syncStore.deleteRealtimeData({\n        chainId: service.network.chainId,\n        fromBlock: BigInt(parentBlock.number),\n      });\n\n      service.localChain = newLocalChain;\n\n      service.onEvent({\n        type: \"reorg\",\n        chainId: service.network.chainId,\n        safeCheckpoint: {\n          ...maxCheckpoint,\n          blockTimestamp: parentBlock.timestamp,\n          chainId: BigInt(service.network.chainId),\n          blockNumber: BigInt(parentBlock.number),\n        },\n      });\n\n      service.common.logger.warn({\n        service: \"realtime\",\n        msg: `Reconciled ${\n          forkedBlockNumber - parentBlock.number\n        }-block reorg on '${service.network.name}' with common ancestor block ${\n          parentBlock.number\n        }`,\n      });\n\n      return;\n    }\n\n    if (newLocalChain.length === 0) break;\n    else {\n      remoteBlock = await _eth_getBlockByHash(service, {\n        blockHash: remoteBlock.parentHash,\n      });\n      newLocalChain.pop();\n    }\n  }\n\n  // No compatible block was found in the local chain, must be a deep reorg.\n\n  const msg = `Encountered unrecoverable '${service.network.name}' reorg beyond finalized block ${service.finalizedBlock.number}`;\n\n  service.common.logger.warn({ service: \"realtime\", msg });\n  service.onFatalError(new Error(msg));\n\n  service.localChain = [];\n};\n\nconst getMatchedLogs = async (\n  service: Service,\n  {\n    logs,\n    upToBlockNumber,\n  }: {\n    logs: SyncLog[];\n    upToBlockNumber: bigint;\n  },\n) => {\n  if (service.factoryLogSources.length === 0) {\n    return filterLogs({\n      logs,\n      logFilters: service.logSources.map((s) => s.criteria),\n    });\n  } else {\n    // Find and insert any new child contracts.\n    const matchedFactoryLogs = filterLogs({\n      logs,\n      logFilters: service.factoryLogSources.map((fs) => ({\n        address: fs.criteria.address,\n        topics: [fs.criteria.eventSelector],\n      })),\n    });\n\n    await service.syncStore.insertFactoryChildAddressLogs({\n      chainId: service.network.chainId,\n      logs: matchedFactoryLogs,\n    });\n\n    // Find any logs matching log filters or child contract filters.\n    // NOTE: It might make sense to just insert all logs rather than introduce\n    // a potentially slow DB operation here. It's a tradeoff between sync\n    // latency and database growth.\n    // NOTE: Also makes sense to hold factoryChildAddresses in memory rather than\n    // a query each interval.\n    const factoryLogFilters = await Promise.all(\n      service.factoryLogSources.map(async (factory) => {\n        const iterator = service.syncStore.getFactoryChildAddresses({\n          chainId: service.network.chainId,\n          factory: factory.criteria,\n          fromBlock: BigInt(factory.startBlock),\n          toBlock: upToBlockNumber,\n        });\n        const childContractAddresses: Address[] = [];\n        for await (const batch of iterator) {\n          childContractAddresses.push(...batch);\n        }\n        return {\n          address: childContractAddresses,\n          topics: factory.criteria.topics,\n        };\n      }),\n    );\n\n    return filterLogs({\n      logs,\n      logFilters: [\n        ...service.logSources.map((l) => l.criteria),\n        ...factoryLogFilters.filter((f) => f.address.length !== 0),\n      ],\n    });\n  }\n};\n\nconst getMatchedCallTraces = async (\n  service: Service,\n  {\n    callTraces,\n    logs,\n    upToBlockNumber,\n  }: {\n    callTraces: SyncCallTrace[];\n    logs: SyncLog[];\n    upToBlockNumber: bigint;\n  },\n) => {\n  if (service.factoryCallTraceSources.length === 0) {\n    return filterCallTraces({\n      callTraces,\n      callTraceFilters: service.callTraceSources.map((s) => s.criteria),\n    });\n  } else {\n    // Find and insert any new child contracts.\n    const matchedFactoryLogs = filterLogs({\n      logs,\n      logFilters: service.factoryLogSources.map((fs) => ({\n        address: fs.criteria.address,\n        topics: [fs.criteria.eventSelector],\n      })),\n    });\n\n    await service.syncStore.insertFactoryChildAddressLogs({\n      chainId: service.network.chainId,\n      logs: matchedFactoryLogs,\n    });\n\n    // Find any logs matching log filters or child contract filters.\n    // NOTE: It might make sense to just insert all logs rather than introduce\n    // a potentially slow DB operation here. It's a tradeoff between sync\n    // latency and database growth.\n    // NOTE: Also makes sense to hold factoryChildAddresses in memory rather than\n    // a query each interval.\n    const factoryTraceFilters = await Promise.all(\n      service.factoryCallTraceSources.map(async (factory) => {\n        const iterator = service.syncStore.getFactoryChildAddresses({\n          chainId: service.network.chainId,\n          factory: factory.criteria,\n          fromBlock: BigInt(factory.startBlock),\n          toBlock: upToBlockNumber,\n        });\n        const childContractAddresses: Address[] = [];\n        for await (const batch of iterator) {\n          childContractAddresses.push(...batch);\n        }\n        return {\n          toAddress: childContractAddresses,\n          fromAddress: factory.criteria.fromAddress,\n        };\n      }),\n    );\n\n    return filterCallTraces({\n      callTraces,\n      callTraceFilters: [\n        ...service.callTraceSources.map((s) => s.criteria),\n        ...factoryTraceFilters.filter((f) => f.toAddress.length !== 0),\n      ],\n    });\n  }\n};\n\nconst getLatestLocalBlock = ({\n  localChain,\n  finalizedBlock,\n}: Pick<Service, \"localChain\" | \"finalizedBlock\">) => {\n  if (localChain.length === 0) {\n    return finalizedBlock;\n  } else return localChain[localChain.length - 1];\n};\n","import {\n  isContractAddressInBloom,\n  isTopicInBloom,\n} from \"ethereum-bloom-filters\";\nimport type { Address, Hex, LogTopic } from \"viem\";\n\nexport const zeroLogsBloom =\n  \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n\nexport function isMatchedLogInBloomFilter({\n  bloom,\n  logFilters,\n}: {\n  bloom: Hex;\n  logFilters: {\n    address?: Address | Address[];\n    topics?: LogTopic[];\n  }[];\n}) {\n  const allAddresses: Address[] = [];\n  logFilters.forEach((logFilter) => {\n    const address =\n      logFilter.address === undefined\n        ? []\n        : Array.isArray(logFilter.address)\n          ? logFilter.address\n          : [logFilter.address];\n    allAddresses.push(...address);\n  });\n  if (allAddresses.some((a) => isContractAddressInBloom(bloom, a))) {\n    return true;\n  }\n\n  const allTopics: Hex[] = [];\n  logFilters.forEach((logFilter) => {\n    logFilter.topics?.forEach((topic) => {\n      if (topic === null) return;\n      if (Array.isArray(topic)) allTopics.push(...topic);\n      else allTopics.push(topic);\n    });\n  });\n  if (allTopics.some((a) => isTopicInBloom(bloom, a))) {\n    return true;\n  }\n\n  return false;\n}\n","import type {\n  CallTraceFilterCriteria,\n  LogFilterCriteria,\n} from \"@/config/sources.js\";\nimport type { SyncCallTrace, SyncLog } from \"@/sync/index.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\n\nexport function filterLogs({\n  logs,\n  logFilters,\n}: {\n  logs: SyncLog[];\n  logFilters: Pick<LogFilterCriteria, \"address\" | \"topics\">[];\n}) {\n  return logs.filter((log) =>\n    logFilters.some((logFilter) => isLogMatchedByFilter({ log, logFilter })),\n  );\n}\n\nexport function isLogMatchedByFilter({\n  log,\n  logFilter,\n}: {\n  log: Pick<SyncLog, \"address\" | \"topics\">;\n  logFilter: Pick<LogFilterCriteria, \"address\" | \"topics\">;\n}) {\n  const logAddress = toLowerCase(log.address);\n\n  if (logFilter.address !== undefined && logFilter.address.length > 0) {\n    if (Array.isArray(logFilter.address)) {\n      if (!logFilter.address.includes(logAddress)) return false;\n    } else {\n      if (logAddress !== logFilter.address) return false;\n    }\n  }\n\n  if (logFilter.topics) {\n    for (const [index, topic] of logFilter.topics.entries()) {\n      if (topic === null || topic === undefined) continue;\n\n      if (log.topics[index] === null || log.topics[index] === undefined)\n        return false;\n\n      if (Array.isArray(topic)) {\n        if (!topic.includes(toLowerCase(log.topics[index]))) return false;\n      } else {\n        if (toLowerCase(log.topics[index]) !== topic) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function filterCallTraces({\n  callTraces,\n  callTraceFilters,\n}: {\n  callTraces: SyncCallTrace[];\n  callTraceFilters: Pick<\n    CallTraceFilterCriteria,\n    \"fromAddress\" | \"toAddress\"\n  >[];\n}) {\n  return callTraces.filter((callTrace) =>\n    callTraceFilters.some((callTraceFilter) =>\n      isCallTraceMatchedByFilter({ callTrace, callTraceFilter }),\n    ),\n  );\n}\n\nexport function isCallTraceMatchedByFilter({\n  callTrace,\n  callTraceFilter,\n}: {\n  callTrace: Pick<SyncCallTrace, \"action\">;\n  callTraceFilter: Pick<CallTraceFilterCriteria, \"fromAddress\" | \"toAddress\">;\n}) {\n  const fromAddress = toLowerCase(callTrace.action.from);\n  const toAddress = toLowerCase(callTrace.action.to);\n\n  if (\n    callTraceFilter.fromAddress !== undefined &&\n    callTraceFilter.fromAddress.length > 0\n  ) {\n    if (!callTraceFilter.fromAddress.includes(fromAddress)) return false;\n  }\n\n  if (\n    callTraceFilter.toAddress !== undefined &&\n    callTraceFilter.toAddress.length > 0\n  ) {\n    if (!callTraceFilter.toAddress.includes(toAddress)) return false;\n  }\n\n  return true;\n}\n","import type { SyncBlock } from \"@/sync/index.js\";\nimport { type Block, type BlockTag, hexToNumber } from \"viem\";\n\nexport type LightBlock = Pick<\n  Block<number, boolean, Exclude<BlockTag, \"pending\">>,\n  \"hash\" | \"parentHash\" | \"number\" | \"timestamp\"\n>;\n\nexport const syncBlockToLightBlock = ({\n  hash,\n  parentHash,\n  number,\n  timestamp,\n}: SyncBlock): LightBlock => ({\n  hash,\n  parentHash,\n  number: hexToNumber(number),\n  timestamp: hexToNumber(timestamp),\n});\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport { create, kill, start } from \"./service.js\";\nimport type { RealtimeSyncEvent, Service } from \"./service.js\";\n\nconst methods = {\n  start,\n  kill,\n};\n\nexport const createRealtimeSyncService = extend(create, methods);\n\nexport type RealtimeSyncService = Extend<Service, typeof methods>;\n\nexport type { RealtimeSyncEvent };\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport {\n  type GetLogsRetryHelperParameters,\n  getLogsRetryHelper,\n} from \"@ponder/utils\";\nimport {\n  BlockNotFoundError,\n  type EIP1193Parameters,\n  HttpRequestError,\n  InternalRpcError,\n  InvalidInputRpcError,\n  LimitExceededRpcError,\n  type PublicRpcSchema,\n  RpcError,\n  type RpcLog,\n  hexToBigInt,\n  isHex,\n} from \"viem\";\nimport { startClock } from \"./timer.js\";\nimport { wait } from \"./wait.js\";\n\ntype RequestReturnType<\n  method extends EIP1193Parameters<PublicRpcSchema>[\"method\"],\n> = Extract<PublicRpcSchema[number], { Method: method }>[\"ReturnType\"];\n\nexport type RequestQueue = Omit<\n  Queue<\n    RequestReturnType<EIP1193Parameters<PublicRpcSchema>[\"method\"]>,\n    EIP1193Parameters<PublicRpcSchema>\n  >,\n  \"add\"\n> & {\n  request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n    parameters: TParameters,\n  ) => Promise<RequestReturnType<TParameters[\"method\"]>>;\n};\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\n/**\n * Creates a queue built to manage rpc requests.\n */\nexport const createRequestQueue = ({\n  network,\n  common,\n}: {\n  network: Network;\n  common: Common;\n}): RequestQueue => {\n  const fetchRequest = async (request: EIP1193Parameters<PublicRpcSchema>) => {\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      try {\n        const stopClock = startClock();\n        const response = await network.transport.request(request);\n        common.metrics.ponder_rpc_request_duration.observe(\n          { method: request.method, network: network.name },\n          stopClock(),\n        );\n\n        return response;\n      } catch (_error) {\n        const error = _error as Error;\n\n        if (\n          request.method === \"eth_getLogs\" &&\n          isHex(request.params[0].fromBlock) &&\n          isHex(request.params[0].toBlock)\n        ) {\n          const getLogsErrorResponse = getLogsRetryHelper({\n            params: request.params as GetLogsRetryHelperParameters[\"params\"],\n            error: error as RpcError,\n          });\n\n          if (getLogsErrorResponse.shouldRetry === false) throw error;\n\n          common.logger.debug({\n            service: \"sync\",\n            msg: `Caught eth_getLogs error on '${\n              network.name\n            }', retrying with ranges: [${getLogsErrorResponse.ranges\n              .map(\n                ({ fromBlock, toBlock }) =>\n                  `[${hexToBigInt(fromBlock).toString()}, ${hexToBigInt(\n                    toBlock,\n                  ).toString()}]`,\n              )\n              .join(\", \")}].`,\n          });\n\n          const logs: RpcLog[] = [];\n          for (const { fromBlock, toBlock } of getLogsErrorResponse.ranges) {\n            const _logs = await fetchRequest({\n              method: \"eth_getLogs\",\n              params: [\n                {\n                  topics: request.params![0].topics,\n                  address: request.params![0].address,\n                  fromBlock,\n                  toBlock,\n                },\n              ],\n            });\n\n            logs.push(...(_logs as RpcLog[]));\n          }\n\n          return logs;\n        }\n\n        if (shouldRetry(error) === false) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request with non-retryable error: ${error.message}`,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request after ${\n              i + 1\n            } attempts with error: ${error.message}`,\n          });\n          throw error;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        common.logger.debug({\n          service: \"sync\",\n          msg: `Failed '${request.method}' RPC request, retrying after ${duration} milliseconds. Error: ${error.message}`,\n        });\n        await wait(duration);\n      }\n    }\n  };\n\n  const requestQueue: Queue<\n    unknown,\n    {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }\n  > = createQueue({\n    frequency: network.maxRequestsPerSecond,\n    concurrency: Math.ceil(network.maxRequestsPerSecond / 4),\n    initialStart: true,\n    browser: false,\n    worker: async (task: {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }) => {\n      common.metrics.ponder_rpc_request_lag.observe(\n        { method: task.request.method, network: network.name },\n        task.stopClockLag(),\n      );\n\n      return await fetchRequest(task.request);\n    },\n  });\n\n  return {\n    ...requestQueue,\n    request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n      params: TParameters,\n    ) => {\n      const stopClockLag = startClock();\n\n      return requestQueue.add({ request: params, stopClockLag });\n    },\n  } as RequestQueue;\n};\n\n/**\n * @link https://github.com/wevm/viem/blob/main/src/utils/buildRequest.ts#L192\n */\nfunction shouldRetry(error: Error) {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    if (error.code === -1) return true; // Unknown error\n    if (error.code === InvalidInputRpcError.code) return true;\n    if (error.code === LimitExceededRpcError.code) return true;\n    if (error.code === InternalRpcError.code) return true;\n    return false;\n  }\n  if (error instanceof BlockNotFoundError) return true;\n  if (error instanceof HttpRequestError && error.status) {\n    // Forbidden\n    if (error.status === 403) return true;\n    // Request Timeout\n    if (error.status === 408) return true;\n    // Request Entity Too Large\n    if (error.status === 413) return true;\n    // Too Many Requests\n    if (error.status === 429) return true;\n    // Internal Server Error\n    if (error.status === 500) return true;\n    // Bad Gateway\n    if (error.status === 502) return true;\n    // Service Unavailable\n    if (error.status === 503) return true;\n    // Gateway Timeout\n    if (error.status === 504) return true;\n    return false;\n  }\n  return true;\n}\n","import type { RealtimeEvent } from \"@/bin/utils/run.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { EventSource } from \"@/config/sources.js\";\nimport { HistoricalSyncService } from \"@/sync-historical/service.js\";\nimport {\n  type RealtimeSyncEvent,\n  type RealtimeSyncService,\n  createRealtimeSyncService,\n} from \"@/sync-realtime/index.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type Checkpoint,\n  checkpointMin,\n  isCheckpointGreaterThan,\n  maxCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type RequestQueue, createRequestQueue } from \"@/utils/requestQueue.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { type Transport, hexToBigInt, hexToNumber } from \"viem\";\nimport { type SyncBlock, _eth_getBlockByNumber } from \"./index.js\";\nimport { cachedTransport } from \"./transport.js\";\n\nexport type Service = {\n  // static\n  common: Common;\n  syncStore: SyncStore;\n  sources: EventSource[];\n\n  // state\n  checkpoint: Checkpoint;\n  finalizedCheckpoint: Checkpoint;\n  isKilled: boolean;\n\n  // network specific services\n  networkServices: {\n    network: Network;\n    sources: EventSource[];\n    requestQueue: RequestQueue;\n    cachedTransport: Transport;\n\n    initialFinalizedCheckpoint: Checkpoint;\n\n    realtime:\n      | {\n          realtimeSync: RealtimeSyncService;\n          checkpoint: Checkpoint;\n          finalizedCheckpoint: Checkpoint;\n          finalizedBlock: SyncBlock;\n        }\n      | undefined;\n\n    historical: {\n      historicalSync: HistoricalSyncService;\n      checkpoint: Checkpoint | undefined;\n      isHistoricalSyncComplete: boolean;\n    };\n  }[];\n\n  // cache\n  sourceById: { [sourceId: EventSource[\"id\"]]: EventSource };\n};\n\nconst HISTORICAL_CHECKPOINT_INTERVAL = 500;\n\nexport const create = async ({\n  common,\n  syncStore,\n  networks,\n  sources,\n  onRealtimeEvent,\n  onFatalError,\n  initialCheckpoint,\n}: {\n  common: Common;\n  syncStore: SyncStore;\n  networks: Network[];\n  sources: EventSource[];\n  onRealtimeEvent: (realtimeEvent: RealtimeEvent) => void;\n  onFatalError: (error: Error) => void;\n  initialCheckpoint: Checkpoint;\n}): Promise<Service> => {\n  const sourceById = sources.reduce<Service[\"sourceById\"]>((acc, cur) => {\n    acc[cur.id] = cur;\n    return acc;\n  }, {});\n\n  const onRealtimeSyncEvent = (realtimeSyncEvent: RealtimeSyncEvent) => {\n    switch (realtimeSyncEvent.type) {\n      case \"checkpoint\": {\n        syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!.realtime!.checkpoint = realtimeSyncEvent.checkpoint;\n\n        // `realtime` can be undefined if no contracts for that network require a realtime\n        // service. Those networks can be left out of the checkpoint calculation.\n        const newCheckpoint = checkpointMin(\n          ...syncService.networkServices\n            .filter((ns) => ns.realtime !== undefined)\n            .map((ns) => ns.realtime!.checkpoint),\n        );\n\n        // Do nothing if the checkpoint hasn't advanced. This also protects against\n        // edged cases in the caching logic with un-trustworthy finalized checkpoints.\n        if (!isCheckpointGreaterThan(newCheckpoint, syncService.checkpoint))\n          return;\n\n        // Must be cautious to deep copy checkpoints.\n\n        const fromCheckpoint = { ...syncService.checkpoint };\n        const toCheckpoint = { ...newCheckpoint };\n\n        syncService.checkpoint = newCheckpoint;\n\n        onRealtimeEvent({\n          type: \"newEvents\",\n          fromCheckpoint,\n          toCheckpoint,\n        });\n\n        break;\n      }\n\n      case \"reorg\": {\n        syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!.realtime!.checkpoint = realtimeSyncEvent.safeCheckpoint;\n\n        if (\n          isCheckpointGreaterThan(\n            syncService.checkpoint,\n            realtimeSyncEvent.safeCheckpoint,\n          )\n        ) {\n          syncService.checkpoint = realtimeSyncEvent.safeCheckpoint;\n        }\n\n        onRealtimeEvent(realtimeSyncEvent);\n\n        break;\n      }\n\n      case \"finalize\": {\n        syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!.realtime!.finalizedCheckpoint = realtimeSyncEvent.checkpoint;\n\n        const newFinalizedCheckpoint = checkpointMin(\n          ...syncService.networkServices\n            .filter((ns) => ns.realtime !== undefined)\n            .map((ns) => ns.realtime!.finalizedCheckpoint),\n        );\n\n        if (\n          isCheckpointGreaterThan(\n            newFinalizedCheckpoint,\n            syncService.finalizedCheckpoint,\n          )\n        ) {\n          onRealtimeEvent({\n            type: \"finalize\",\n            checkpoint: newFinalizedCheckpoint,\n          });\n          syncService.finalizedCheckpoint = newFinalizedCheckpoint;\n        }\n\n        break;\n      }\n\n      default:\n        never(realtimeSyncEvent);\n    }\n  };\n\n  const networkServices: Service[\"networkServices\"] = await Promise.all(\n    networks.map(async (network) => {\n      const networkSources = sources.filter(\n        (source) => source.networkName === network.name,\n      );\n\n      const requestQueue = createRequestQueue({\n        network,\n        common,\n      });\n\n      const [{ latestBlock, finalizedBlock }, remoteChainId] =\n        await Promise.all([\n          getLatestAndFinalizedBlocks({\n            network,\n            requestQueue,\n          }),\n          requestQueue.request({ method: \"eth_chainId\" }).then(hexToNumber),\n        ]);\n\n      if (network.chainId !== remoteChainId) {\n        common.logger.warn({\n          service: \"sync\",\n          msg: `Remote chain ID (${remoteChainId}) does not match configured chain ID (${network.chainId}) for network \"${network.name}\"`,\n        });\n      }\n\n      const historicalSync = new HistoricalSyncService({\n        common,\n        syncStore,\n        network,\n        requestQueue,\n        sources: networkSources,\n      });\n\n      await historicalSync.setup({\n        latestBlockNumber: hexToNumber(latestBlock.number),\n        finalizedBlockNumber: hexToNumber(finalizedBlock.number),\n      });\n\n      const initialFinalizedCheckpoint: Checkpoint = {\n        ...maxCheckpoint,\n        blockTimestamp: hexToNumber(finalizedBlock.timestamp),\n        chainId: BigInt(network.chainId),\n        blockNumber: hexToBigInt(finalizedBlock.number),\n      };\n\n      const canSkipRealtime = getCanSkipRealtime({\n        sources: networkSources,\n        finalizedBlock,\n      });\n\n      if (canSkipRealtime) {\n        return {\n          network,\n          sources: networkSources,\n          requestQueue,\n          cachedTransport: cachedTransport({ requestQueue, syncStore }),\n          initialFinalizedCheckpoint,\n          realtime: undefined,\n          historical: {\n            historicalSync,\n            checkpoint: undefined,\n            isHistoricalSyncComplete: false,\n          },\n        } satisfies Service[\"networkServices\"][number];\n      } else {\n        const realtimeSync = createRealtimeSyncService({\n          common,\n          syncStore,\n          network,\n          requestQueue,\n          sources: networkSources,\n          finalizedBlock,\n          onEvent: onRealtimeSyncEvent,\n          onFatalError,\n        });\n\n        return {\n          network,\n          sources: networkSources,\n          requestQueue,\n          cachedTransport: cachedTransport({ requestQueue, syncStore }),\n          initialFinalizedCheckpoint,\n          realtime: {\n            realtimeSync,\n            checkpoint: initialFinalizedCheckpoint,\n            finalizedCheckpoint: initialFinalizedCheckpoint,\n            finalizedBlock,\n          },\n          historical: {\n            historicalSync,\n            checkpoint: undefined,\n            isHistoricalSyncComplete: false,\n          },\n        } satisfies Service[\"networkServices\"][number];\n      }\n    }),\n  );\n\n  // Register historical sync event listeners\n  for (const networkService of networkServices) {\n    networkService.historical.historicalSync.on(\n      \"historicalCheckpoint\",\n      (checkpoint: Checkpoint) => {\n        networkService.historical.checkpoint = checkpoint;\n\n        common.logger.trace({\n          service: \"sync\",\n          msg: `New historical checkpoint (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} blockNumber=${checkpoint.blockNumber})`,\n        });\n      },\n    );\n    networkService.historical.historicalSync.on(\"syncComplete\", () => {\n      networkService.historical.isHistoricalSyncComplete = true;\n\n      if (\n        networkServices.every(\n          ({ historical }) => historical.isHistoricalSyncComplete,\n        )\n      ) {\n        common.logger.info({\n          service: \"sync\",\n          msg: \"Completed historical sync across all networks\",\n        });\n      }\n    });\n  }\n\n  const syncService: Service = {\n    common,\n    syncStore,\n    sources,\n    networkServices,\n    isKilled: false,\n    checkpoint: initialCheckpoint,\n    finalizedCheckpoint: checkpointMin(\n      ...networkServices.map((ns) => ns.initialFinalizedCheckpoint),\n    ),\n    sourceById,\n  };\n\n  return syncService;\n};\n\n/**\n * Start the historical sync service for all networks.\n */\nexport const startHistorical = (syncService: Service) => {\n  for (const { historical } of syncService.networkServices) {\n    historical.historicalSync.start();\n  }\n};\n\n/**\n * Returns an async generator of checkpoints that resolves\n * when historical sync is complete.\n */\nexport const getHistoricalCheckpoint = async function* (\n  syncService: Service,\n): AsyncGenerator<{ fromCheckpoint: Checkpoint; toCheckpoint: Checkpoint }> {\n  while (true) {\n    if (syncService.isKilled) return;\n\n    const isComplete = syncService.networkServices.every(\n      (ns) => ns.historical.isHistoricalSyncComplete,\n    );\n\n    if (isComplete) {\n      const finalityCheckpoint = checkpointMin(\n        ...syncService.networkServices.map(\n          ({ initialFinalizedCheckpoint }) => initialFinalizedCheckpoint,\n        ),\n      );\n\n      // Do nothing if the checkpoint hasn't advanced. This also protects against\n      // edged cases in the caching logic with un-trustworthy finalized checkpoints.\n      if (!isCheckpointGreaterThan(finalityCheckpoint, syncService.checkpoint))\n        break;\n\n      yield {\n        fromCheckpoint: syncService.checkpoint,\n        toCheckpoint: finalityCheckpoint,\n      };\n\n      syncService.checkpoint = finalityCheckpoint;\n\n      break;\n    } else {\n      await wait(HISTORICAL_CHECKPOINT_INTERVAL);\n\n      const networkCheckpoints = syncService.networkServices.map(\n        (ns) => ns.historical.checkpoint,\n      );\n\n      // If a network hasn't yet found any checkpoint, it is\n      // impossible to determine a checkpoint amongst all networks.\n      if (networkCheckpoints.some((nc) => nc === undefined)) {\n        continue;\n      }\n\n      const newCheckpoint = checkpointMin(\n        ...(networkCheckpoints as Checkpoint[]),\n      );\n\n      // Do nothing if the checkpoint hasn't advanced.\n      if (!isCheckpointGreaterThan(newCheckpoint, syncService.checkpoint)) {\n        continue;\n      }\n\n      yield {\n        fromCheckpoint: syncService.checkpoint,\n        toCheckpoint: newCheckpoint,\n      };\n\n      syncService.checkpoint = newCheckpoint;\n    }\n  }\n};\n\n/**\n * Start the realtime sync service for all networks.\n */\nexport const startRealtime = (syncService: Service) => {\n  for (const { realtime, network } of syncService.networkServices) {\n    if (realtime === undefined) {\n      syncService.common.logger.debug({\n        service: \"realtime\",\n        msg: `No realtime contracts (network=${network.name})`,\n      });\n      syncService.common.metrics.ponder_realtime_is_connected.set(\n        { network: network.name },\n        0,\n      );\n    } else {\n      realtime.realtimeSync.start();\n      syncService.common.metrics.ponder_realtime_is_connected.set(\n        { network: network.name },\n        1,\n      );\n    }\n  }\n};\n\nexport const kill = async (syncService: Service) => {\n  syncService.isKilled = true;\n\n  const killPromise: Promise<void>[] = [];\n\n  for (const { historical, realtime } of syncService.networkServices) {\n    historical.historicalSync.kill();\n    if (realtime !== undefined) killPromise.push(realtime.realtimeSync.kill());\n  }\n\n  await Promise.all(killPromise);\n};\n\nexport const getCachedTransport = (syncService: Service, network: Network) => {\n  const { requestQueue } = syncService.networkServices.find(\n    (ns) => ns.network.chainId === network.chainId,\n  )!;\n  return cachedTransport({ requestQueue, syncStore: syncService.syncStore });\n};\n\nconst getLatestAndFinalizedBlocks = async ({\n  network,\n  requestQueue,\n}: { network: Network; requestQueue: RequestQueue }) => {\n  const latestBlock = await _eth_getBlockByNumber(\n    { requestQueue },\n    { blockTag: \"latest\" },\n  );\n\n  const finalizedBlockNumber = Math.max(\n    0,\n    hexToNumber(latestBlock.number) - network.finalityBlockCount,\n  );\n\n  const finalizedBlock = await _eth_getBlockByNumber(\n    { requestQueue },\n    {\n      blockNumber: finalizedBlockNumber,\n    },\n  );\n\n  return { latestBlock, finalizedBlock };\n};\n\nconst getCanSkipRealtime = ({\n  sources,\n  finalizedBlock,\n}: {\n  sources: EventSource[];\n  finalizedBlock: SyncBlock;\n}) => {\n  // If an endBlock is specified for every event source on this network, and the\n  // latest end block is less than the finalized block number, we can stop here.\n  // The service won't poll for new blocks and won't emit any events.\n  const endBlocks = sources.map((f) => f.endBlock);\n  return endBlocks.every(\n    (b) => b !== undefined && b <= hexToNumber(finalizedBlock.number),\n  );\n};\n","import type { SyncStore } from \"@/sync-store/store.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport type { Address, Hex, Transport } from \"viem\";\nimport { custom, hexToBigInt, maxUint256 } from \"viem\";\n\nconst cachedMethods = [\n  \"eth_call\",\n  \"eth_getBalance\",\n  \"eth_getCode\",\n  \"eth_getStorageAt\",\n] as const;\n\nexport const cachedTransport = ({\n  requestQueue,\n  syncStore,\n}: {\n  requestQueue: RequestQueue;\n  syncStore: SyncStore;\n}): Transport => {\n  return ({ chain }) => {\n    const c = custom({\n      async request({ method, params }) {\n        const body = { method, params };\n\n        if (cachedMethods.includes(method)) {\n          let request: string = undefined!;\n          let blockNumber: Hex | \"latest\" = undefined!;\n\n          if (method === \"eth_call\") {\n            const [{ data, to }, _blockNumber] = params as [\n              { data: Hex; to: Hex },\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(to)}_${toLowerCase(\n              data,\n            )}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getBalance\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getCode\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getStorageAt\") {\n            const [address, slot, _blockNumber] = params as [\n              Address,\n              Hex,\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(\n              address,\n            )}_${toLowerCase(slot)}`;\n            blockNumber = _blockNumber;\n          }\n\n          const blockNumberBigInt =\n            blockNumber === \"latest\" ? maxUint256 : hexToBigInt(blockNumber);\n\n          const cachedResult = await syncStore.getRpcRequestResult({\n            blockNumber: blockNumberBigInt,\n            chainId: chain!.id,\n            request,\n          });\n\n          if (cachedResult?.result) return cachedResult.result;\n          else {\n            const response = await requestQueue.request(body);\n            await syncStore.insertRpcRequestResult({\n              blockNumber: blockNumberBigInt,\n              chainId: chain!.id,\n              request,\n              result: response as string,\n            });\n            return response;\n          }\n        } else {\n          return requestQueue.request(body);\n        }\n      },\n    });\n    return c({ chain, retryCount: 0 });\n  };\n};\n","import type { Build } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport type { Common } from \"@/common/common.js\";\nimport { PostgresDatabaseService } from \"@/database/postgres/service.js\";\nimport type { DatabaseService, NamespaceInfo } from \"@/database/service.js\";\nimport { SqliteDatabaseService } from \"@/database/sqlite/service.js\";\nimport { getHistoricalStore } from \"@/indexing-store/historical.js\";\nimport { getReadonlyStore } from \"@/indexing-store/readonly.js\";\nimport { getRealtimeStore } from \"@/indexing-store/realtime.js\";\nimport type { IndexingStore } from \"@/indexing-store/store.js\";\nimport { createIndexingService } from \"@/indexing/index.js\";\nimport { createServer } from \"@/server/service.js\";\nimport { PostgresSyncStore } from \"@/sync-store/postgres/store.js\";\nimport { SqliteSyncStore } from \"@/sync-store/sqlite/store.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport type { Event } from \"@/sync/events.js\";\nimport { decodeEvents } from \"@/sync/events.js\";\nimport { createSyncService } from \"@/sync/index.js\";\nimport {\n  type Checkpoint,\n  isCheckpointEqual,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { createQueue } from \"@ponder/common\";\n\nexport type RealtimeEvent =\n  | {\n      type: \"newEvents\";\n      fromCheckpoint: Checkpoint;\n      toCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"reorg\";\n      safeCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"finalize\";\n      checkpoint: Checkpoint;\n    };\n\n/**\n * Starts the server, sync, and indexing services for the specified build.\n */\nexport async function run({\n  common,\n  build,\n  onFatalError,\n  onReloadableError,\n}: {\n  common: Common;\n  build: Build;\n  onFatalError: (error: Error) => void;\n  onReloadableError: (error: Error) => void;\n}) {\n  const {\n    buildId,\n    databaseConfig,\n    optionsConfig,\n    networks,\n    sources,\n    schema,\n    graphqlSchema,\n    indexingFunctions,\n  } = build;\n\n  common.options = { ...common.options, ...optionsConfig };\n\n  let database: DatabaseService;\n  let syncStore: SyncStore;\n  let namespaceInfo: NamespaceInfo;\n  let initialCheckpoint: Checkpoint;\n\n  if (databaseConfig.kind === \"sqlite\") {\n    const { directory } = databaseConfig;\n    database = new SqliteDatabaseService({ common, directory });\n    [namespaceInfo, initialCheckpoint] = await database\n      .setup({ schema, buildId })\n      .then(({ namespaceInfo, checkpoint }) => [namespaceInfo, checkpoint]);\n\n    syncStore = new SqliteSyncStore({ db: database.syncDb });\n  } else {\n    const { poolConfig, schema: userNamespace, publishSchema } = databaseConfig;\n    database = new PostgresDatabaseService({\n      common,\n      poolConfig,\n      userNamespace,\n      publishSchema,\n    });\n    [namespaceInfo, initialCheckpoint] = await database\n      .setup({ schema, buildId })\n      .then(({ namespaceInfo, checkpoint }) => [namespaceInfo, checkpoint]);\n\n    syncStore = new PostgresSyncStore({ db: database.syncDb });\n  }\n\n  const readonlyStore = getReadonlyStore({\n    kind: database.kind,\n    schema,\n    namespaceInfo,\n    db: database.readonlyDb,\n  });\n\n  const server = await createServer({ common, graphqlSchema, readonlyStore });\n\n  // This can be a long-running operation, so it's best to do it after\n  // starting the server so the app can become responsive more quickly.\n  await database.migrateSyncStore();\n\n  runCodegen({ common, graphqlSchema });\n\n  // Note: can throw\n  const syncService = await createSyncService({\n    common,\n    syncStore,\n    networks,\n    sources,\n    // Note: this is not great because it references the\n    // `realtimeQueue` which isn't defined yet\n    onRealtimeEvent: (realtimeEvent) => {\n      realtimeQueue.add(realtimeEvent);\n    },\n    onFatalError,\n    initialCheckpoint,\n  });\n\n  const handleEvents = async (\n    events: Event[],\n    lastEventCheckpoint: Checkpoint | undefined,\n  ) => {\n    if (lastEventCheckpoint !== undefined) {\n      indexingService.updateLastEventCheckpoint(lastEventCheckpoint);\n    }\n\n    if (events.length === 0) return { status: \"success\" } as const;\n\n    return await indexingService.processEvents({ events });\n  };\n\n  const handleReorg = async (safeCheckpoint: Checkpoint) => {\n    await database.revert({\n      checkpoint: safeCheckpoint,\n      namespaceInfo,\n    });\n  };\n\n  const handleFinalize = async (checkpoint: Checkpoint) => {\n    await database.updateFinalizedCheckpoint({ checkpoint });\n  };\n\n  const realtimeQueue = createQueue({\n    initialStart: true,\n    browser: false,\n    concurrency: 1,\n    worker: async (event: RealtimeEvent) => {\n      switch (event.type) {\n        case \"newEvents\": {\n          const lastEventCheckpoint = await syncStore.getLastEventCheckpoint({\n            sources: sources,\n            fromCheckpoint: event.fromCheckpoint,\n            toCheckpoint: event.toCheckpoint,\n          });\n          for await (const rawEvents of syncStore.getEvents({\n            sources,\n            fromCheckpoint: event.fromCheckpoint,\n            toCheckpoint: event.toCheckpoint,\n            limit: 1_000,\n          })) {\n            const result = await handleEvents(\n              decodeEvents(syncService, rawEvents),\n              lastEventCheckpoint,\n            );\n            if (result.status === \"error\") onReloadableError(result.error);\n          }\n\n          break;\n        }\n        case \"reorg\":\n          await handleReorg(event.safeCheckpoint);\n          break;\n\n        case \"finalize\":\n          await handleFinalize(event.checkpoint);\n          break;\n\n        default:\n          never(event);\n      }\n    },\n  });\n\n  let indexingStore: IndexingStore = {\n    ...getReadonlyStore({\n      kind: database.kind,\n      schema,\n      namespaceInfo,\n      db: database.indexingDb,\n    }),\n    ...getHistoricalStore({\n      kind: database.kind,\n      schema,\n      namespaceInfo,\n      db: database.indexingDb,\n    }),\n  };\n\n  const indexingService = createIndexingService({\n    indexingFunctions,\n    common,\n    indexingStore,\n    sources,\n    networks,\n    syncService,\n    schema,\n  });\n\n  const start = async () => {\n    syncService.startHistorical();\n\n    // If the initial checkpoint is zero, we need to run setup events.\n    if (isCheckpointEqual(initialCheckpoint, zeroCheckpoint)) {\n      const result = await indexingService.processSetupEvents({\n        sources,\n        networks,\n      });\n      if (result.status === \"killed\") {\n        return;\n      } else if (result.status === \"error\") {\n        onReloadableError(result.error);\n        return;\n      }\n    }\n\n    // Run historical indexing until complete.\n    for await (const {\n      fromCheckpoint,\n      toCheckpoint,\n    } of syncService.getHistoricalCheckpoint()) {\n      const lastEventCheckpoint = await syncStore.getLastEventCheckpoint({\n        sources: sources,\n        fromCheckpoint,\n        toCheckpoint,\n      });\n\n      for await (const rawEvents of syncStore.getEvents({\n        sources: sources,\n        fromCheckpoint,\n        toCheckpoint,\n        limit: 1_000,\n      })) {\n        const result = await handleEvents(\n          decodeEvents(syncService, rawEvents),\n          lastEventCheckpoint,\n        );\n\n        if (result.status === \"killed\") {\n          return;\n        } else if (result.status === \"error\") {\n          onReloadableError(result.error);\n          return;\n        }\n      }\n    }\n\n    // Become healthy\n    common.logger.info({\n      service: \"indexing\",\n      msg: \"Completed historical indexing\",\n    });\n\n    if (database.kind === \"postgres\") {\n      await database.publish();\n    }\n    await handleFinalize(syncService.finalizedCheckpoint);\n\n    await database.createIndexes({ schema });\n\n    server.setHealthy();\n    common.logger.info({\n      service: \"server\",\n      msg: \"Started responding as healthy\",\n    });\n\n    indexingStore = {\n      ...getReadonlyStore({\n        kind: database.kind,\n        schema,\n        namespaceInfo,\n        db: database.indexingDb,\n      }),\n      ...getRealtimeStore({\n        kind: database.kind,\n        schema,\n        namespaceInfo,\n        db: database.indexingDb,\n      }),\n    };\n\n    indexingService.updateIndexingStore({ indexingStore, schema });\n\n    syncService.startRealtime();\n  };\n\n  const startPromise = start();\n\n  return async () => {\n    const serverPromise = server.kill();\n    indexingService.kill();\n    await syncService.kill();\n    realtimeQueue.pause();\n    realtimeQueue.clear();\n    await realtimeQueue.onIdle();\n    await startPromise;\n    await serverPromise;\n    await database.kill();\n  };\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { PostgresDatabaseService } from \"@/database/postgres/service.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport { getReadonlyStore } from \"@/indexing-store/readonly.js\";\nimport { createServer } from \"@/server/service.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function serve({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({ level: options.logLevel });\n\n  const [major, minor, _patch] = process.versions.node.split(\".\").map(Number);\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const initialResult = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (initialResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"serve\", ...buildPayload(initialResult.build) },\n  });\n\n  const { databaseConfig, optionsConfig, schema, graphqlSchema } =\n    initialResult.build;\n\n  common.options = { ...common.options, ...optionsConfig };\n\n  if (databaseConfig.kind === \"sqlite\") {\n    await shutdown({\n      reason: \"The 'ponder serve' command does not support SQLite\",\n      code: 1,\n    });\n    return cleanup;\n  }\n\n  if (databaseConfig.publishSchema === undefined) {\n    await shutdown({\n      reason: \"The 'ponder serve' command requires 'publishSchema' to be set\",\n      code: 1,\n    });\n    return cleanup;\n  }\n\n  const { poolConfig, schema: userNamespace } = databaseConfig;\n  const database = new PostgresDatabaseService({\n    common,\n    poolConfig,\n    userNamespace,\n    // Ensures that the `readonly` connection pool gets\n    // allocated the maximum number of connections.\n    isReadonly: true,\n  });\n\n  const readonlyStore = getReadonlyStore({\n    kind: \"postgres\",\n    schema,\n    // Note: `ponder serve` serves data from the `publishSchema`. Also, it does\n    // not need the other fields in NamespaceInfo because it only uses findUnique\n    // and findMany. We should ultimately add a PublicStore interface for this.\n    namespaceInfo: {\n      userNamespace: databaseConfig.publishSchema,\n    } as unknown as NamespaceInfo,\n    db: database.readonlyDb,\n  });\n\n  const server = await createServer({ graphqlSchema, common, readonlyStore });\n  server.setHealthy();\n\n  cleanupReloadable = async () => {\n    await server.kill();\n    await database.kill();\n  };\n\n  return cleanup;\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function start({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({ level: options.logLevel });\n\n  const [major, minor, _patch] = process.versions.node.split(\".\").map(Number);\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const initialResult = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (initialResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"start\", ...buildPayload(initialResult.build) },\n  });\n\n  cleanupReloadable = await run({\n    common,\n    build: initialResult.build,\n    onFatalError: () => {\n      shutdown({ reason: \"Received fatal error\", code: 1 });\n    },\n    onReloadableError: () => {\n      shutdown({ reason: \"Encountered indexing error\", code: 1 });\n    },\n  });\n\n  return cleanup;\n}\n"],"mappings":";;;AACA,SAAS,gBAAAA,qBAAoB;AAC7B,SAAS,SAAS,eAAe;AACjC,SAAS,qBAAqB;AAE9B,SAAS,eAAe;AACxB,OAAO,YAAY;;;ACJZ,IAAM,SAAS,CAIpBC,SACA,aAK4C;AAC5C,SAAO,IAAI,WAAgC;AACzC,UAAM,UAAUA,QAAO,GAAG,MAAM;AAEhC,QAAI,mBAAmB,SAAS;AAC9B,aAAO,QAAQ,KAAK,CAAC,MAAM;AACzB,cAAMC,WAAe,CAAC;AACtB,mBAAW,CAAC,YAAY,MAAM,KAAK,OAAO,QAAQ,QAAQ,GAAG;AAC3D,UAAAA,SAAQ,UAAU,IAAI,IAAIC,YAAgB,OAAO,GAAG,GAAGA,OAAM;AAAA,QAC/D;AAEA,eAAO;AAAA,UACL,GAAG;AAAA,UACH,GAAGD;AAAA,QACL;AAAA,MACF,CAAC;AAAA,IACH,OAAO;AACL,YAAMA,WAAe,CAAC;AACtB,iBAAW,CAAC,YAAY,MAAM,KAAK,OAAO,QAAQ,QAAQ,GAAG;AAC3D,QAAAA,SAAQ,UAAU,IAAI,IAAIC,YAAgB,OAAO,SAAS,GAAGA,OAAM;AAAA,MACrE;AAEA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAGD;AAAA,MACL;AAAA,IACF;AAAA,EACF;AACF;;;ACxCA,SAAS,kBAAkB;AAC3B,SAAS,gBAAAE,qBAAoB;AAC7B,OAAOC,WAAU;;;ACYV,IAAM,iBAAiB,CAAC,WAC7B,OAAO,OAAO,MAAM;AAEf,IAAM,oBAAoB,CAAC,WAChC,OAAO,OAAO,MAAM;AAEf,IAAM,cAAc,CAAC,WAC1B,OAAO,OAAO,MAAM;AAEf,IAAM,eAAe,CAAC,WAC3B,OAAO,OAAO,MAAM;AAEf,IAAM,eAAe,CAAC,WAC3B,OAAO,OAAO,MAAM;AAEf,IAAM,eAAe,CAAC,WAC3B,OAAO,OAAO,MAAM;AAEf,IAAM,mBAAmB,CAAC,WAA4B;AAC3D,MAAI,aAAa,MAAM,KAAK,YAAY,MAAM;AAAG,WAAO;AACxD,SAAO,OAAO,WAAW;AAC3B;AAEO,IAAM,eAAe,CAAC,WAA4B;AACvD,MACE,aAAa,MAAM,KACnB,YAAY,MAAM,KAClB,kBAAkB,MAAM,KACxB,aAAa,MAAM;AAEnB,WAAO;AACT,SAAO,OAAO,OAAO;AACvB;AAEO,IAAM,UAAU,CACrB,gBAEA,CAAC,MAAM,QAAQ,WAAW;AAErB,IAAM,SAAS,CAAC,gBACrB,MAAM,QAAQ,WAAW;AAEpB,IAAM,YAAY,CACvB,WACwE;AACxE,QAAM,SAEF,CAAC;AAEL,aAAW,CAAC,MAAM,WAAW,KAAK,OAAO,QAAQ,MAAM,GAAG;AACxD,QAAI,QAAQ,WAAW,GAAG;AACxB,aAAO,IAAI,IAAI;AAAA,IACjB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,WAAW,CAAC,WAAiD;AACxE,QAAM,QAAsC,CAAC;AAE7C,aAAW,CAAC,MAAM,WAAW,KAAK,OAAO,QAAQ,MAAM,GAAG;AACxD,QAAI,OAAO,WAAW,GAAG;AACvB,YAAM,IAAI,IAAI;AAAA,IAChB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,wBAAwB,CAAC,QAAiC;AACrE,SAAO,IAAI,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AACvC;AAEO,IAAM,eAAe,CAAC,WAAmB;AAC9C,SAAO,KAAK,UAAU;AAAA,IACpB,QAAQ,UAAU,MAAM;AAAA,IACxB,OAAO,SAAS,MAAM;AAAA,EACxB,CAAC;AACH;;;AC1FA;AAAA,EAEE,qBAAAC;AAAA,EACA;AAAA,OACK;;;ACIP;AAAA,EACE,kBAAAC;AAAA,OAGK;AACP;AAAA,EAGE,cAAAC;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,iBAAAC;AAAA,OACK;AACP,SAAS,mBAAmB;;;ACd5B;AAAA,EAGE;AAAA,OACK;AACP,SAAS,mBAAmB;;;ACf5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,IAAM,gBAAgB,IAAI,kBAAkB;AAAA,EAC1C,MAAM;AAAA,EACN,WAAW,CAAC,UAAU,OAAO,KAAK;AAAA,EAClC,YAAY,CAAC,UAAU,OAAO,KAAY;AAAA,EAC1C,cAAc,CAAC,UAAU;AACvB,QAAI,MAAM,SAAS,eAAe;AAChC,aAAO,OAAO,MAAM,KAAK;AAAA,IAC3B,OAAO;AACL,YAAM,IAAI;AAAA,QACR,yDAAyD,MAAM,IAAI;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AACF,CAAC;AAEM,IAAM,UAAmD;AAAA,EAC9D,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,KAAK;AACP;;;ADZA,IAAM,kBAAkB;AAAA,EACtB,WAAW,CAAC,IAAI,MAAM;AAAA,EACtB,UAAU,CAAC,OAAO,SAAS;AAAA,EAC3B,QAAQ,CAAC,QAAQ,UAAU;AAAA,EAC3B,SAAS,CAAC,OAAO,OAAO,QAAQ,MAAM;AAAA,EACtC,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,CAAC;AAAA,EACrC;AAAA,EACA;AACF,MAAsE;AACpE,QAAM,oBAA4D,CAAC;AAEnE,aAAW,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,OAAO,QAAQ,UAAU,MAAM,CAAC,GAAG;AACtE,UAAM,aAAa,IAAI,uBAAuB;AAAA,MAC5C,MAAM,GAAG,SAAS;AAAA,MAClB,QAAQ,MAAM;AACZ,cAAM,eAA2C;AAAA;AAAA,UAE/C,KAAK,EAAE,MAAM,IAAI,YAAY,UAAU,EAAE;AAAA,UACzC,IAAI,EAAE,MAAM,IAAI,YAAY,UAAU,EAAE;AAAA,QAC1C;AAEA,eAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AAEtD,cAAI,YAAY,MAAM;AAAG;AACzB,cAAI,aAAa,MAAM;AAAG;AAC1B,cAAI,aAAa,MAAM;AAAG;AAE1B,gBAAM,OAAO,aAAa,MAAM,IAC5B,UAAU,OAAO,OAAO,CAAC,IACzB,QAAQ,OAAO,SAAS,CAAC;AAE7B,cAAI,aAAa,MAAM,GAAG;AAExB,4BAAgB,UAAU,QAAQ,CAAC,WAAW;AAC5C,2BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,gBACvC,MAAM,IAAI,YAAY,IAAI;AAAA,cAC5B;AAAA,YACF,CAAC;AAED,4BAAgB,OAAO,QAAQ,CAAC,WAAW;AACzC,2BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,gBACvC;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AAGL,4BAAgB,UAAU,QAAQ,CAAC,WAAW;AAC5C,2BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,gBACvC;AAAA,cACF;AAAA,YACF,CAAC;AAED,4BAAgB,SAAS,QAAQ,CAAC,WAAW;AAC3C,2BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,gBACvC,MAAM,IAAI,YAAY,IAAI;AAAA,cAC5B;AAAA,YACF,CAAC;AAED,iBACG,eAAe,MAAM,KAAK,kBAAkB,MAAM,MACnD,CAAC,OAAO,UAAU,SAAS,KAAK,EAAE,SAAS,OAAO,SAAS,CAAC,GAC5D;AACA,8BAAgB,QAAQ,QAAQ,CAAC,WAAW;AAC1C,6BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,kBACvC;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,YACH;AAEA,iBACG,eAAe,MAAM,KAAK,kBAAkB,MAAM,MACnD,aAAa,OAAO,SAAS,GAC7B;AACA,8BAAgB,OAAO,QAAQ,CAAC,WAAW;AACzC,6BAAa,GAAG,UAAU,GAAG,MAAM,EAAE,IAAI;AAAA,kBACvC;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF,CAAC;AAED,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,sBAAkB,SAAS,IAAI;AAAA,EACjC;AAEA,SAAO,EAAE,kBAAkB;AAC7B;AAEA,IAAM,gCAAgC;AAAA,EACpC,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,SAAS;AAAA,EACT,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,UAAU;AAAA,EACV,cAAc;AAAA,EACd,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,eAAe;AACjB;AAEO,SAAS,iBAAiB,OAA4B;AAC3D,QAAM,cAAmC,CAAC;AAE1C,aAAW,CAAC,UAAU,QAAQ,KAAK,OAAO,QAAQ,KAAK,GAAG;AAExD,QAAI,aAAa,SAAS,aAAa,MAAM;AAC3C,UAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC5B,cAAM,IAAI;AAAA,UACR,4CAA4C,QAAQ,mBAAmB,QAAQ;AAAA,QACjF;AAAA,MACF;AAEA,kBAAY,QAAQ,IAAI,SAAS,IAAI,gBAAgB;AACrD;AAAA,IACF;AAEA,UAAM,CAAC,WAAW,UAAU,IAAI,SAAS,MAAM,QAAQ;AAEvD,UAAM,YACJ,eAAe,SAAY,KAAK;AAGlC,UAAM,iBAAiB,8BAA8B,SAAS;AAC9D,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI;AAAA,QACR,2CAA2C,SAAS,IAAI,SAAS;AAAA,MACnE;AAAA,IACF;AAEA,gBAAY,SAAS,MAAM,CAAC;AAC5B,gBAAY,SAAS,EAAE,cAAc,IAAI;AAAA,EAC3C;AAEA,SAAO;AACT;;;ADhJA,IAAM,kBAAkB,IAAI,kBAAkB;AAAA,EAC5C,MAAM;AAAA,EACN,QAAQ;AAAA,IACN,aAAa,EAAE,MAAM,IAAI,eAAeC,eAAc,EAAE;AAAA,IACxD,iBAAiB,EAAE,MAAM,IAAI,eAAeA,eAAc,EAAE;AAAA,IAC5D,aAAa,EAAE,MAAMC,eAAc;AAAA,IACnC,WAAW,EAAE,MAAMA,eAAc;AAAA,EACnC;AACF,CAAC;AAEM,IAAM,mBAAmB,CAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF,MAIM;AACJ,QAAM,cAAkE,CAAC;AACzE,QAAM,kBAAqD,CAAC;AAE5D,aAAW,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,OAAO,QAAQ,UAAU,MAAM,CAAC,GAAG;AACtE,gBAAY,SAAS,IAAI,IAAI,kBAAkB;AAAA,MAC7C,MAAM;AAAA,MACN,QAAQ,MAAM;AACZ,cAAM,iBAAyD,CAAC;AAEhE,eAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,cAAI,YAAY,MAAM,GAAG;AAGvB,kBAAM,kBAAkB,MACtB,OAAO,YAAY,CACrB;AACA,kBAAM,kBAAkB,sBAAsB,eAAe;AAE7D,kBAAM,WAAkD,OACtD,QACA,OACA,YACG;AAEH,oBAAM,kBAAkB,OAAO,OAAO,YAAY,CAAC;AAEnD,kBAAI,oBAAoB,QAAQ,oBAAoB;AAClD,uBAAO;AAET,oBAAM,SAAS,QAAQ,UAAU;AAAA,gBAC/B,WAAW;AAAA,cACb,CAAC;AAED,qBAAO,MAAM,OAAO,KAAK,eAAe;AAAA,YAC1C;AAEA,2BAAe,UAAU,IAAI;AAAA,cAC3B,MAAM,iBAAiB,eAAe,IAClC,YAAY,eAAe,IAC3B,IAAI,eAAe,YAAY,eAAe,CAAC;AAAA,cACnD,SAAS;AAAA,YACX;AAAA,UACF,WAAW,aAAa,MAAM,GAAG;AAC/B,kBAAM,WAA2B,OAAO,QAAQ,MAAM,YAAY;AAChE,oBAAM,EAAE,OAAO,SAAS,gBAAgB,OAAO,OAAO,OAAO,IAC3D;AAEF,oBAAM,cAAc,QAAQ,iBAAiB,KAAK,IAAI,CAAC;AAGvD,eAAC,YAAY,OAAO,kBAAkB,CAAC,MAAM,CAAC,GAAG,SAC/C,OAAO;AAET,oBAAM,gBAAgB,UAClB,EAAE,CAAC,OAAO,GAAG,kBAAkB,MAAM,IACrC;AAIJ,oBAAM,SAAS,MAAM,QAAQ,MAAM,SAAS;AAAA,gBAC1C,WAAW,OAAO,iBAAiB;AAAA,gBACnC,OAAO;AAAA,gBACP,SAAS;AAAA,gBACT;AAAA,gBACA;AAAA,gBACA;AAAA,cACF,CAAC;AAGD,oBAAM,SAAS,QAAQ,UAAU;AAAA,gBAC/B,WAAW,OAAO,iBAAiB;AAAA,cACrC,CAAC;AAED,oBAAM,MAAM,OAAO,MAAM,IAAI,CAAC,SAAS,KAAK,EAAE;AAC9C,oBAAM,QAAQ,MAAM,OAAO,SAAS,GAAG;AAEvC,qBAAO,EAAE,OAAO,UAAU,OAAO,SAAS;AAAA,YAC5C;AAEA,2BAAe,UAAU,IAAI;AAAA,cAC3B,MAAM,gBAAgB,OAAO,iBAAiB,CAAC;AAAA,cAC/C,MAAM;AAAA,gBACJ,OAAO,EAAE,MAAM,kBAAkB,OAAO,iBAAiB,CAAC,EAAE;AAAA,gBAC5D,SAAS,EAAE,MAAMA,eAAc;AAAA,gBAC/B,gBAAgB,EAAE,MAAMA,eAAc;AAAA,gBACtC,QAAQ,EAAE,MAAMA,eAAc;AAAA,gBAC9B,OAAO,EAAE,MAAMA,eAAc;AAAA,gBAC7B,OAAO,EAAE,MAAMC,YAAW;AAAA,cAC5B;AAAA,cACA,SAAS;AAAA,YACX;AAAA,UACF,WAAW,aAAa,MAAM,GAAG;AAC/B,2BAAe,UAAU,IAAI;AAAA,cAC3B,MAAM,iBAAiB,MAAM,IACzB,cACA,IAAI,eAAe,WAAW;AAAA,YACpC;AAAA,UACF,OAAO;AACL,kBAAM,OAAO,aAAa,MAAM,IAC5B,UAAU,OAAO,OAAO,CAAC,IACzB,QAAQ,OAAO,SAAS,CAAC;AAC7B,gBAAI,aAAa,MAAM,GAAG;AACxB,oBAAM,WAAW,IAAIC,aAAY,IAAI,eAAe,IAAI,CAAC;AACzD,6BAAe,UAAU,IAAI;AAAA,gBAC3B,MAAM,iBAAiB,MAAM,IACzB,WACA,IAAI,eAAe,QAAQ;AAAA,cACjC;AAAA,YACF,OAAO;AACL,6BAAe,UAAU,IAAI;AAAA,gBAC3B,MAAM,iBAAiB,MAAM,IACzB,OACA,IAAI,eAAe,IAAI;AAAA,cAC7B;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAED,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,oBAAgB,SAAS,IAAI,IAAI,kBAAkB;AAAA,MACjD,MAAM,GAAG,SAAS;AAAA,MAClB,QAAQ,OAAO;AAAA,QACb,OAAO;AAAA,UACL,MAAM,IAAI;AAAA,YACR,IAAIA,aAAY,IAAI,eAAe,YAAY,SAAS,CAAC,CAAC;AAAA,UAC5D;AAAA,QACF;AAAA,QACA,UAAU,EAAE,MAAM,IAAI,eAAe,eAAe,EAAE;AAAA,MACxD;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,EAAE,aAAa,gBAAgB;AACxC;;;AGxLA,SAAS,mBAAAC,wBAAuB;AAEzB,SAAS,eAAe,EAAE,OAAO,GAAuB;AAC7D,QAAM,YAA6C,CAAC;AAEpD,aAAW,CAAC,UAAU,KAAK,KAAK,OAAO,QAAQ,SAAS,MAAM,CAAC,GAAG;AAChE,cAAU,QAAQ,IAAI,IAAIA,iBAAgB;AAAA,MACxC,MAAM;AAAA,MACN,QAAQ,MAAM;AAAA,QACZ,CAAC,KAAyB,SAAS,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE;AAAA,QACvD,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,EAAE,UAAU;AACrB;;;AClBA;AAAA,EAIE,cAAAC;AAAA,EACA,kBAAAC;AAAA,EAEA,iBAAAC;AAAA,OACK;AAeA,IAAM,mBAAmB,CAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF,MAI2C;AACzC,QAAM,WAA2B,OAAO,GAAG,MAAM,YAAY;AAC3D,UAAM,EAAE,OAAO,SAAS,gBAAgB,QAAQ,OAAO,MAAM,IAAI;AAEjE,UAAM,cAAc,QAAQ,iBAAiB,KAAK,IAAI,CAAC;AAEvD,UAAM,gBAAgB,UAClB,EAAE,CAAC,OAAO,GAAG,kBAAkB,MAAM,IACrC;AAEJ,WAAO,MAAM,QAAQ,MAAM,SAAS;AAAA,MAClC;AAAA,MACA,OAAO;AAAA,MACP,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,MAAM,IAAIC,gBAAe,cAAc;AAAA,IACvC,MAAM;AAAA,MACJ,OAAO,EAAE,MAAM,iBAAiB;AAAA,MAChC,SAAS,EAAE,MAAMC,eAAc;AAAA,MAC/B,gBAAgB,EAAE,MAAMA,eAAc;AAAA,MACtC,QAAQ,EAAE,MAAMA,eAAc;AAAA,MAC9B,OAAO,EAAE,MAAMA,eAAc;AAAA,MAC7B,OAAO,EAAE,MAAMC,YAAW;AAAA,IAC5B;AAAA,IACA,SAAS;AAAA,EACX;AACF;;;AC7DA;AAAA,EAGE,kBAAAC;AAAA,OACK;AASA,IAAM,qBAAqB,CAAC;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,MAI2C;AACzC,QAAM,WAA6B,OAAO,GAAG,MAAM,YAAY;AAC7D,UAAM,EAAE,GAAG,IAAI;AAEf,QAAI,OAAO;AAAW,aAAO;AAE7B,UAAM,iBAAiB,MAAM,QAAQ,MAAM,WAAW,EAAE,WAAW,GAAG,CAAC;AAEvE,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,MACJ,IAAI,EAAE,MAAM,IAAIC,gBAAe,QAAQ,MAAM,GAAG,SAAS,CAAC,CAAC,EAAE;AAAA,IAC/D;AAAA,IACA,SAAS;AAAA,EACX;AACF;;;ANtBO,IAAM,qBAAqB,CAAC,WAAkC;AACnE,QAAM,cAAmE,CAAC;AAE1E,QAAM,EAAE,UAAU,IAAI,eAAe,EAAE,OAAO,CAAC;AAC/C,QAAM,EAAE,kBAAkB,IAAI,uBAAuB,EAAE,QAAQ,UAAU,CAAC;AAC1E,QAAM,EAAE,aAAa,gBAAgB,IAAI,iBAAiB;AAAA,IACxD;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,aAAW,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,OAAO,QAAQ,UAAU,MAAM,CAAC,GAAG;AACtE,UAAM,aAAa,YAAY,SAAS;AACxC,UAAM,iBAAiB,gBAAgB,SAAS;AAChD,UAAM,mBAAmB,kBAAkB,SAAS;AAEpD,UAAM,oBACJ,UAAU,OAAO,CAAC,EAAE,YAAY,IAAI,UAAU,MAAM,CAAC;AACvD,gBAAY,iBAAiB,IAAI,mBAAmB;AAAA,MAClD;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,kBAAkB,GAAG,iBAAiB;AAC5C,gBAAY,eAAe,IAAI,iBAAiB;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,IAAI,cAAc;AAAA,IACvB,OAAO,IAAIC,mBAAkB;AAAA,MAC3B,MAAM;AAAA,MACN,QAAQ;AAAA,IACV,CAAC;AAAA,EACH,CAAC;AACH;;;AF/CA,SAAS,YAAY;AAErB,SAA6B,oBAAoB;AACjD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,gCAAgC;AACzC,SAAS,mBAAmB,kBAAkB;AAC9C,OAAO,6BAA6B;;;ASjBpC,OAAO,UAAU;;;ACKV,SAAS,qBAAqB,KAA4B;AAC/D,QAAM,iBAAiB,oBAAI,IAAY;AACvC,QAAM,aAAa,oBAAI,IAAY;AAEnC,MAAI,QAAQ,CAAC,YAAoB;AAC/B,QAAI,eAAe,IAAI,OAAO,GAAG;AAC/B,iBAAW,IAAI,OAAO;AAAA,IACxB,OAAO;AACL,qBAAe,IAAI,OAAO;AAAA,IAC5B;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;ACjBA;AAAA,EAIE;AAAA,OACK;AACP;AAAA,EAIE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AA+CA,IAAM,iBAAiB,CAAC,EAAE,IAAI,MAAoB;AACvD,QAAM,YAAY,IACf,OAAO,CAAC,SAA2B,KAAK,SAAS,OAAO,EACxD,OAAO,CAAC,SAAS,KAAK,cAAc,UAAa,KAAK,cAAc,KAAK;AAE5E,QAAM,uBAAuB;AAAA,IAC3B,UAAU,IAAI,CAAC,SAAS,KAAK,IAAI;AAAA,EACnC;AAEA,SAAO,UAAU;AAAA,IACf,CAAC,KAAK,SAAS;AACb,YAAM,YAAY,cAAc,IAAI;AACpC,YAAM,WAAW,qBAAqB,IAAI,KAAK,IAAI,IAC/C,UAAU,MAAM,QAAQ,EAAE,CAAC,IAC3B,KAAK;AACT,YAAM,WAAW,iBAAiB,IAAI;AAEtC,YAAM,eAAe,EAAE,UAAU,WAAW,UAAU,KAAK;AAE3D,UAAI,WAAW,QAAQ,IAAI;AAC3B,UAAI,WAAW,QAAQ,IAAI;AAE3B,aAAO;AAAA,IACT;AAAA,IACA,EAAE,YAAY,CAAC,GAAG,YAAY,CAAC,EAAE;AAAA,EACnC;AACF;AAEO,SAAS,YACd,KACA,QACY;AACZ,MAAI,MAAM,QAAQ,OAAO,KAAK,GAAG;AAE/B,WAAO;AAAA,MACL,OAAO,MAAM,IAAI,CAAC,UAAU,iBAAiB,aAAa,KAAK,KAAK,CAAC,CAAC;AAAA,IACxE;AAAA,EACF,OAAO;AAEL,WAAO,kBAAkB;AAAA,MACvB,KAAK,CAAC,aAAa,KAAK,OAAO,KAAK,CAAC;AAAA,MACrC,MAAM,OAAO;AAAA,IACf,CAAC;AAAA,EACH;AACF;AAOA,IAAM,eAAe,CAAC,KAAU,cAAgC;AAC9D,MAAI,UAAU,SAAS,GAAG,GAAG;AAE3B,WAAO,aAAa,SAAS,SAAS,EAAE;AAAA,EAC1C,OAAO;AACL,WAAO,WAAW,EAAE,KAAK,MAAM,UAAU,CAAC;AAAA,EAC5C;AACF;AAEO,IAAM,oBAAoB,CAAC,EAAE,IAAI,MAAoB;AAC1D,QAAM,eAAe,IAAI;AAAA,IACvB,CAAC,SAA8B,KAAK,SAAS;AAAA,EAC/C;AAEA,QAAM,0BAA0B;AAAA,IAC9B,aAAa,IAAI,CAAC,SAAS,KAAK,IAAI;AAAA,EACtC;AAEA,SAAO,aAAa;AAAA,IAClB,CAAC,KAAK,SAAS;AACb,YAAM,YAAY,cAAc,IAAI;AACpC,YAAM,WAAW,wBAAwB,IAAI,KAAK,IAAI,IAClD,UAAU,MAAM,WAAW,EAAE,CAAC,IAC9B,GAAG,KAAK,IAAI;AAChB,YAAM,WAAW,oBAAoB,IAAI;AAEzC,YAAM,eAAe,EAAE,UAAU,WAAW,UAAU,KAAK;AAE3D,UAAI,WAAW,QAAQ,IAAI;AAC3B,UAAI,WAAW,QAAQ,IAAI;AAE3B,aAAO;AAAA,IACT;AAAA,IACA,EAAE,YAAY,CAAC,GAAG,YAAY,CAAC,EAAE;AAAA,EACnC;AACF;;;AClJO,SAAS,YAA8B,OAAU;AACtD,SAAO,MAAM,YAAY;AAC3B;;;ACJA,SAAS,mCAAmC;AAKrC,SAAS,wBAAwB,OAA6B;AACnE,QAAM,kBAAkB,mBAAmB,MAAM,IAAI;AACrD,MAAI,iBAAiB;AACnB,UAAM,CAAC,QAAQ,SAAS,IAAI;AAI5B,QAAI,CAAC,UAAU,gBAAgB,KAAK,GAAG;AACrC,aAAO;AAAA,IACT;AAKA,UAAM,2BAA2B,wBAAwB;AAAA,MACvD,GAAG;AAAA,MACH,MAAM;AAAA,IACR,CAAC;AACD,WAAO,SAAS;AAAA,EAClB;AAEA,MAAI,MAAM,SAAS,SAAS;AAG1B,QAAI,gBAAgB,KAAK,GAAG;AAC1B,aAAO;AAAA,IACT;AAIA,QAAI,WAAW;AACf,eAAW,aAAc,MAAc,cAAc,CAAC,GAAG;AACvD,kBAAY,wBAAwB,SAAS;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAIA,MACE,MAAM,SAAS,YACf,MAAM,KAAK,WAAW,OAAO,KAC7B,MAAM,KAAK,WAAW,MAAM,KAC5B,MAAM,KAAK,WAAW,KAAK,KAC3B,MAAM,SAAS,aACf,MAAM,SAAS,QACf;AACA,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,4BAA4B,MAAM,MAAM;AAAA,IAChD,UAAU;AAAA,EACZ,CAAC;AACH;AAEA,SAAS,gBAAgB,OAAqB;AAC5C,QAAM,EAAE,KAAK,IAAI;AACjB,MAAI,SAAS;AAAU,WAAO;AAC9B,MAAI,SAAS;AAAS,WAAO;AAC7B,MAAI,KAAK,SAAS,IAAI;AAAG,WAAO;AAEhC,MAAI,SAAS;AAAS,WAAQ,MAAc,YAAY,KAAK,eAAe;AAE5E,QAAM,kBAAkB,mBAAmB,MAAM,IAAI;AACrD,MACE,mBACA,gBAAgB,EAAE,GAAG,OAAO,MAAM,gBAAgB,CAAC,EAAE,CAAiB;AAEtE,WAAO;AAET,SAAO;AACT;AAEA,SAAS,mBACP,MACwD;AACxD,QAAM,UAAU,KAAK,MAAM,kBAAkB;AAC7C,SAAO;AAAA;AAAA,IAEH,CAAC,QAAQ,CAAC,IAAI,OAAO,QAAQ,CAAC,CAAC,IAAI,MAAM,QAAQ,CAAC,CAAC;AAAA,MACnD;AACN;;;ACpFA,SAAS,oBAAAC,yBAAwB;AAG1B,SAAS,0BAA0B;AAAA,EACxC,SAAS;AAAA,EACT;AAAA,EACA;AACF,GAIyB;AACvB,QAAM,UAAU,YAAY,QAAQ;AACpC,QAAM,gBAAgBA,kBAAiB,KAAK;AAG5C,QAAM,uBAAuB,MAAM,OAChC,OAAO,CAAC,MAAM,aAAa,KAAK,EAAE,OAAO,EACzC,UAAU,CAAC,UAAU,MAAM,SAAS,SAAS;AAEhD,MAAI,uBAAuB,IAAI;AAC7B,WAAO;AAAA,MACL;AAAA,MACA;AAAA;AAAA,MAEA,sBAAsB,QAAS,uBAAuB,CAAe;AAAA,IACvE;AAAA,EACF;AAEA,QAAM,mBAAmB,MAAM,OAAO;AAAA,IACpC,CAAC,MAAM,EAAE,aAAa,KAAK,EAAE;AAAA,EAC/B;AACA,QAAM,0BAA0B,iBAAiB;AAAA,IAC/C,CAAC,UAAU,MAAM,SAAS;AAAA,EAC5B;AAEA,MAAI,4BAA4B,IAAI;AAClC,UAAM,IAAI;AAAA,MACR,sEAAsE,SAAS,uBAAuB,MAAM,OACzG,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,GAAG,EACxB,KAAK,IAAI,CAAC;AAAA,IACf;AAAA,EACF;AAEA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,yBAAyB,KAAK;AAChD,cAAU,wBAAwB,iBAAiB,CAAC,CAAC;AAAA,EACvD;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,sBAAsB,SAAS,MAAM;AAAA,EACvC;AACF;;;ACzDA,YAAY,aAAa;AAElB,IAAM,SAAS;;;ACaf,SAAS,wBAAwB;AAAA,EACtC;AAAA,EACA;AACF,GAGG;AACD,MAAI;AACJ,UAAQ,SAAS;AAAA,IAEf,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,sBAAgB;AAChB;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AACH,sBAAgB;AAChB;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AACH,sBAAgB;AAChB;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AACH,sBAAgB;AAChB;AAAA,IACF;AACE,sBAAgB;AAAA,EACpB;AAEA,QAAM,cAAc,QACjB,OAAO,CAAC,QAAuB,QAAQ,MAAS,EAChD,KAAK,CAAC,QAAQ,IAAI,SAAS,UAAU,CAAC;AAEzC,QAAM,eAAe,QAClB,OAAO,CAAC,QAAuB,QAAQ,MAAS,EAChD,KAAK,CAAC,QAAQ,IAAI,SAAS,gBAAgB,CAAC;AAE/C,MAAI,aAAa;AACf,oBAAgB,KAAK,IAAI,eAAe,GAAM;AAAA,EAChD,WAAW,cAAc;AACvB,oBAAgB,KAAK,IAAI,eAAe,GAAG;AAAA,EAC7C;AAEA,SAAO;AACT;AASO,SAAS,sBAAsB,EAAE,QAAQ,GAAwB;AACtE,MAAI;AACJ,UAAQ,SAAS;AAAA,IAEf,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,2BAAqB;AACrB;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AACH,2BAAqB;AACrB;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,2BAAqB;AACrB;AAAA,IACF;AAEE,2BAAqB;AAAA,EACzB;AAEA,SAAO;AACT;AAQA,eAAsB,oBAAoB,YAGvC;AAED,QAAM,EAAE,QAAQ,MAAM,IAAI,WAAW,UAAU;AAAA,IAC7C,OAAO,WAAW;AAAA,IAClB,iBAAiB;AAAA;AAAA,IACjB,YAAY;AAAA,EACd,CAAC;AACD,QAAM,YAAY,EAAE,GAAG,QAAQ,GAAG,MAAM;AAExC,iBAAe,uBAAuBC,YAAgC;AACpE,YAAQA,WAAU,MAAM;AAAA,MACtB,KAAK,QAAQ;AACX,eAAO,CAACA,WAAU,OAAO,WAAW,MAAM,QAAQ,QAAQ,KAAK,CAAC,CAAC;AAAA,MACnE;AAAA,MACA,KAAK,aAAa;AAChB,YAAI;AACF,gBAAM,SAAS,MAAMA,WAAU,UAAU;AACzC,iBAAO,CAAC,OAAO,GAAG;AAAA,QACpB,SAAS,GAAG;AACV,gBAAM,SAAS,OAAO,sBAAsB,CAAC,EAAE;AAAA,YAC7C,CAACC,YAAWA,QAAO,SAAS,MAAM;AAAA,UACpC;AACA,cAAI,CAAC;AAAQ,mBAAO,CAAC;AACrB,gBAAM,MAAO,EAAU,MAAM,GAAG;AAChC,cAAI,CAAC;AAAK,mBAAO,CAAC;AAClB,iBAAO,CAAC,IAAI,QAAQ,OAAO,EAAE,CAAC;AAAA,QAChC;AAAA,MACF;AAAA,MACA,KAAK,YAAY;AAEf,cAAM,qBAAqBD,WAAU,WAAW,IAAI,CAAC,OAAY;AAAA,UAC/D,GAAG,EAAE;AAAA,UACL,GAAG,EAAE;AAAA,QACP,EAAE;AAEF,cAAM,OAA+B,CAAC;AACtC,mBAAW,qBAAqB,oBAAoB;AAClD,eAAK,KAAK,GAAI,MAAM,uBAAuB,iBAAiB,CAAE;AAAA,QAChE;AAEA,eAAO;AAAA,MACT;AAAA,MACA,SAAS;AAGP,eAAO,CAAC;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAEA,SAAO,uBAAuB,SAAS;AACzC;AAEA,IAAI,gBAAyC;AAStC,SAAS,eAAe,QAA4B;AACzD,MAAI,WAAW;AAAW,WAAO;AAEjC,MAAI,CAAC,eAAe;AAElB,oBAAgB,OAAO,OAAO,MAAM,EAAE,OAAoB,CAAC,KAAK,UAAU;AACxE,YAAM,QAAQ,QAAQ,KAAK,QAAQ,CAAC,eAAe;AACjD,YAAI,IAAI,UAAU;AAAA,MACpB,CAAC;AAED,OACG,MAAM,QAAQ,QACZ,aAAa,CAAC,GACjB,QAAQ,CAAC,oBAAoB;AAC7B,YAAI,IAAI,eAAe;AAAA,MACzB,CAAC;AAED,aAAO;AAAA,IACT,GAAG,oBAAI,IAAY,CAAC;AAAA,EACtB;AAEA,SAAO,cAAc,IAAI,MAAM;AACjC;;;ACpFO,IAAM,cAAc,CACzB,WACwB,OAAO,SAAS;AAEnC,IAAM,qBAAqB,CAChC,WAC+B,OAAO,SAAS;AAE1C,IAAM,oBAAoB,CAC/B,WAC8B,OAAO,SAAS;AAEzC,IAAM,2BAA2B,CACtC,WACqC,OAAO,SAAS;AAEhD,IAAM,gBAAgB,CAC3B,WAC0B,OAAO,SAAS;;;AC9HrC,IAAM,uBAAuB,MAEG;AACrC,MAAIE;AACJ,MAAI;AACJ,QAAM,UAAU,IAAI,QAAkB,CAAC,UAAU,YAAY;AAC3D,IAAAA,WAAU;AACV,aAAS;AAAA,EACX,CAAC;AACD,SAAO,EAAE,SAASA,UAAU,QAAiB,QAAQ;AACvD;;;ACdO,SAAS,SACd,IACA,IACA;AACA,MAAI;AACJ,MAAI,aAAa;AACjB,MAAI;AAEJ,SAAO;AAAA,IACL,MAAM,IAAI,UAAiB;AACzB,aAAO;AAEP,UAAI,CAAC,YAAY;AACf,qBAAa;AACb,kBAAU,WAAW,MAAM;AACzB,uBAAa;AACb,aAAG,GAAG,IAAI;AAAA,QACZ,GAAG,EAAE;AAAA,MACP;AAAA,IACF;AAAA,IACA,QAAQ,MAAM;AACZ,mBAAa,OAAO;AAAA,IACtB;AAAA,EACF;AACF;;;ACXO,SAAS,OAAiB,KAAa,OAAiC;AAC7E,QAAM,OAAO,oBAAI,IAAe;AAEhC,SAAO,IAAI,OAAO,CAAC,MAAM;AACvB,QAAI,KAAK,IAAI,QAAQ,MAAM,CAAC,IAAI,CAAC;AAAG,aAAO;AAE3C,SAAK,IAAI,CAAC;AACV,WAAO;AAAA,EACT,CAAC;AACH;AAEA;AAAA,EACE;AAAA,IACE,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,IACb,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,IACb,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,EACf;AAAA,EACA,CAAC,MAAM,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;AACtB;;;ACMA,IAAM,qBAAqB,CAAC;AAAA,EAC1B;AAAA,EACA;AACF,MAGM;AACJ,MAAI,gBAAgB,UAAa,cAAc,QAAW;AACxD,UAAM;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAEA,MAAI,gBAAgB,UAAa,eAAe,GAAG;AACjD,UAAM;AAAA,MACJ,qDAAqD,WAAW;AAAA,IAClE;AAAA,EACF;AAEA,MAAI,cAAc,UAAa,aAAa,GAAG;AAC7C,UAAM;AAAA,MACJ,mDAAmD,SAAS;AAAA,IAC9D;AAAA,EACF;AACF;AAEO,IAAM,cAAc,CAA8B;AAAA,EACvD;AAAA,EACA,eAAe;AAAA,EACf,UAAU;AAAA,EACV,GAAG;AACL,MAGK;AACH,qBAAmB,WAAW;AAE9B,QAAM,aAGF;AACJ,MAAI,QAAQ,IAAI,MAAgD;AAChE,MAAI,UAAU;AACd,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,MAAI,YAAY;AAEhB,MAAI;AAEJ,MAAI,4BAEY;AAChB,MAAI,2BAEY;AAEhB,QAAM,OAAO,MAAM;AACjB,QAAI,CAAC;AAAW;AAEhB,UAAM,aAAa,KAAK,IAAI;AAE5B,QAAI,KAAK,MAAM,aAAa,GAAK,MAAM,WAAW;AAChD,iBAAW;AACX,kBAAY,KAAK,MAAM,aAAa,GAAK;AAAA,IAC3C;AAEA,QAAI;AAAO;AAEX,YACG,WAAW,cAAc,SACtB,WAAW,WAAW,YACtB,UACH,WAAW,gBAAgB,SACxB,UAAU,WAAW,cACrB,SACJ,MAAM,SAAS,GACf;AACA,YAAM,EAAE,MAAM,SAAAC,UAAS,OAAO,IAAI,MAAM,MAAM;AAE9C;AACA;AAEA,aAAO,IAAI,EACR,KAAKA,QAAO,EACZ,MAAM,MAAM,EACZ,QAAQ,MAAM;AACb;AAEA,YACE,6BAA6B,UAC7B,MAAM,WAAW,KACjB,YAAY,GACZ;AACA,mCAAyB,QAAQ;AACjC,mCAAyB,YAAY;AAAA,QACvC;AAEA,kBAAU,KAAK,IAAI,QAAQ,SAAS,IAAI;AAAA,MAC1C,CAAC;AAEH,UAAI,8BAA8B,UAAa,MAAM,WAAW,GAAG;AACjE,kCAA0B,QAAQ;AAClC,kCAA0B,YAAY;AAAA,MACxC;AAAA,IACF;AAEA,QACE,WAAW,cAAc,UACzB,YAAY,WAAW,WACvB;AACA,cAAQ;AAAA,QACN,MAAM;AACJ,kBAAQ;AACR,eAAK;AAAA,QACP;AAAA,QACA,MAAS,aAAa;AAAA,MACxB;AACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM,MAAM,MAAM;AAAA,IAClB,SAAS,MAAM;AACb,UAAI,SAAS;AACX,eAAO,IAAI;AAAA,UAAgB,CAACA,aAC1B,WAAW,MAAMA,SAAQ,OAAO,CAAC;AAAA,QACnC;AAAA,MACF,OAAO;AACL,eAAO,IAAI;AAAA,UAAgB,CAACA,aAC1B,aAAa,MAAMA,SAAQ,OAAO,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,IACA,KAAK,CAAC,SAAmB;AACvB,YAAM,EAAE,SAAS,SAAAA,UAAS,OAAO,IAAI,qBAAiC;AACtE,YAAM,KAAK,EAAE,MAAM,SAAAA,UAAS,OAAO,CAAC;AAEpC,WAAK;AAEL,aAAO;AAAA,IACT;AAAA,IACA,OAAO,MAAM;AACX,cAAQ,IAAI,MAAgD;AAC5D,mBAAa,KAAK;AAClB,cAAQ;AAAA,IACV;AAAA,IACA,WAAW,MAAM;AAAA,IACjB,OAAO,MAAM;AACX,UAAI,SAAS;AACX,eAAO,IAAI;AAAA,UAAgB,CAACA,aAC1B,WAAW,MAAMA,SAAQ,OAAO,CAAC;AAAA,QACnC,EAAE,KAAK,MAAM;AACX,sBAAY;AACZ,eAAK;AAAA,QACP,CAAC;AAAA,MACH,OAAO;AACL,eAAO,IAAI;AAAA,UAAgB,CAACA,aAC1B,QAAQ,SAAS,MAAMA,SAAQ,OAAO,CAAC;AAAA,QACzC,EAAE,KAAK,MAAM;AACX,sBAAY;AACZ,eAAK;AAAA,QACP,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,OAAO,MAAM;AACX,kBAAY;AAAA,IACd;AAAA,IACA,QAAQ,MAAM;AACZ,UACE,6BAA6B,UAC7B,yBAAyB,WACzB;AACA,YAAI,MAAM,WAAW,KAAK,YAAY;AAAG,iBAAO,QAAQ,QAAQ;AAEhE,mCAA2B;AAAA,UACzB,GAAG,qBAA2B;AAAA,UAC9B,WAAW;AAAA,QACb;AAAA,MACF;AACA,aAAO,yBAAyB;AAAA,IAClC;AAAA,IACA,SAAS,MAAM;AACb,UACE,8BAA8B,UAC9B,0BAA0B,WAC1B;AACA,YAAI,MAAM,WAAW;AAAG,iBAAO,QAAQ,QAAQ;AAE/C,oCAA4B;AAAA,UAC1B,GAAG,qBAA2B;AAAA,UAC9B,WAAW;AAAA,QACb;AAAA,MACF;AACA,aAAO,0BAA0B;AAAA,IACnC;AAAA,IACA,eAAe,CAACC,iBAAgB;AAC9B,yBAAmBA,YAAW;AAE9B,UAAI,eAAeA,cAAa;AAC9B,mBAAW,YAAYA,aAAY;AAAA,MACrC;AACA,UAAI,iBAAiBA,cAAa;AAChC,mBAAW,cAAcA,aAAY;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AACF;;;AZ5NA,OAAO,WAAW;AAYlB,eAAsB,gCAAgC;AAAA,EACpD;AAAA,EACA;AAAA,EACA,SAAS,EAAE,SAAS,UAAU;AAChC,GAIG;AACD,QAAM,OAA4D,CAAC;AAGnE,MAAI;AAEJ,QAAM,YAAY,KAAK,KAAK,WAAW,QAAQ;AAC/C,QAAM,kBAAkB,KAAK,SAAS,SAAS,SAAS;AAExD,MAAI,OAAO,UAAU,MAAM;AACzB,QAAI,OAAO,SAAS,SAAS,YAAY;AACvC,UAAI,mBAAuC;AAC3C,UAAI,SAA6B;AAEjC,UAAI,OAAO,SAAS,kBAAkB;AACpC,2BAAmB,OAAO,SAAS;AACnC,iBAAS;AAAA,MACX,WAAW,QAAQ,IAAI,sBAAsB;AAC3C,2BAAmB,QAAQ,IAAI;AAC/B,iBAAS;AAAA,MACX,WAAW,QAAQ,IAAI,cAAc;AACnC,2BAAmB,QAAQ,IAAI;AAC/B,iBAAS;AAAA,MACX,OAAO;AACL,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,4BAA4B;AAAA,UAC/B;AAAA,QACF,CAAC,MAAM,MAAM;AAAA,MACf,CAAC;AAED,UAAI,SAA6B;AACjC,UAAI,OAAO,SAAS,QAAQ;AAC1B,iBAAS,OAAO,SAAS;AACzB,iBAAS;AAAA,MACX,WAAW,QAAQ,IAAI,uBAAuB;AAC5C,YAAI,QAAQ,IAAI,yBAAyB,QAAW;AAClD,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AAAA,QACF;AACA,iBAAS,GACP,QAAQ,IAAI,oBACd,IAAI,QAAQ,IAAI,sBAAsB,MAAM,GAAG,CAAC,CAAC;AACjD,iBAAS;AAAA,MACX,OAAO;AACL,iBAAS;AACT,iBAAS;AAAA,MACX;AACA,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,UAAU,MAAM,yCAAyC,MAAM;AAAA,MACtE,CAAC;AAED,UAAI,gBAAoC;AACxC,UAAI,OAAO,SAAS,kBAAkB,QAAW;AAC/C,wBAAgB,OAAO,SAAS;AAChC,iBAAS;AAAA,MACX,WAAW,QAAQ,IAAI,0BAA0B,QAAW;AAC1D,wBAAgB;AAChB,iBAAS;AAAA,MACX;AACA,UAAI,kBAAkB,QAAW;AAC/B,aAAK,KAAK;AAAA,UACR,OAAO;AAAA,UACP,KAAK,UAAU,aAAa,0CAA0C,MAAM;AAAA,QAC9E,CAAC;AAAA,MACH,OAAO;AACL,aAAK,KAAK;AAAA,UACR,OAAO;AAAA,UACP,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AAEA,UAAI,WAAW,UAAa,WAAW,eAAe;AACpD,cAAM,IAAI;AAAA,UACR,oFAAoF,MAAM;AAAA,QAC5F;AAAA,MACF;AAEA,YAAM,aAAa;AAAA,QACjB,KAAK,OAAO,SAAS,YAAY,OAAO;AAAA,QACxC;AAAA,MACF;AAEA,uBAAiB;AAAA,QACf,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,OAAO;AACL,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,6BAA6B,eAAe;AAAA,MACnD,CAAC;AAED,uBAAiB,EAAE,MAAM,UAAU,WAAW,UAAU;AAAA,IAC1D;AAAA,EACF,OAAO;AACL,QAAI,mBAAuC;AAC3C,QAAI,SAA6B;AACjC,QAAI,QAAQ,IAAI,sBAAsB;AACpC,yBAAmB,QAAQ,IAAI;AAC/B,eAAS;AAAA,IACX,WAAW,QAAQ,IAAI,cAAc;AACnC,yBAAmB,QAAQ,IAAI;AAC/B,eAAS;AAAA,IACX;AAGA,QAAI,qBAAqB,QAAW;AAClC,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,2BAA2B;AAAA,UAC9B;AAAA,QACF,CAAC,KAAK,MAAM;AAAA,MACd,CAAC;AAED,UAAI,SAA6B;AACjC,UAAI,QAAQ,IAAI,0BAA0B,QAAW;AACnD,iBAAS,QAAQ,IAAI;AACrB,YAAI,QAAQ,IAAI,yBAAyB,QAAW;AAClD,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AAAA,QACF;AACA,iBAAS,GACP,QAAQ,IAAI,oBACd,IAAI,QAAQ,IAAI,sBAAsB,MAAM,GAAG,CAAC,CAAC;AACjD,iBAAS;AAAA,MACX,OAAO;AACL,iBAAS;AACT,iBAAS;AAAA,MACX;AACA,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,UAAU,MAAM,yCAAyC,MAAM;AAAA,MACtE,CAAC;AAED,UAAI,gBAAoC;AACxC,UAAI,QAAQ,IAAI,0BAA0B,QAAW;AACnD,wBAAgB;AAChB,iBAAS;AAAA,MACX;AACA,UAAI,kBAAkB,QAAW;AAC/B,aAAK,KAAK;AAAA,UACR,OAAO;AAAA,UACP,KAAK,UAAU,aAAa,0CAA0C,MAAM;AAAA,QAC9E,CAAC;AAAA,MACH,OAAO;AACL,aAAK,KAAK;AAAA,UACR,OAAO;AAAA,UACP,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AAEA,UAAI,WAAW,UAAa,WAAW,eAAe;AACpD,cAAM,IAAI;AAAA,UACR,oFAAoF,MAAM;AAAA,QAC5F;AAAA,MACF;AAEA,YAAM,aAAa,EAAE,KAAK,IAAI,iBAAiB;AAE/C,uBAAiB;AAAA,QACf,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,OAAO;AAEL,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,4BAA4B,eAAe;AAAA,MAClD,CAAC;AAED,uBAAiB,EAAE,MAAM,UAAU,WAAW,UAAU;AAAA,IAC1D;AAAA,EACF;AAEA,QAAM,WAAsB,MAAM,QAAQ;AAAA,IACxC,OAAO,QAAQ,OAAO,QAAQ,EAAE,IAAI,OAAO,CAAC,aAAa,OAAO,MAAM;AACpE,YAAM,EAAE,SAAS,UAAU,IAAI;AAE/B,YAAM,eACJ,OAAO,OAAO,MAAM,EAAE;AAAA,QAAK,CAAC,MAC1B,QAAQ,IAAI,EAAE,OAAO,UAAU;AAAA,MACjC,KAAK,OAAO;AACd,YAAM,QAAQ,EAAE,GAAG,cAAc,MAAM,aAAa,IAAI,QAAQ;AAGhE,YAAM,UAAU,MAAM,oBAAoB,EAAE,WAAW,MAAM,CAAC;AAC9D,cAAQ,QAAQ,CAAC,WAAW;AAC1B,YAAI,eAAe,MAAM,GAAG;AAC1B,eAAK,KAAK;AAAA,YACR,OAAO;AAAA,YACP,KAAK,YAAY,WAAW,gCAAgC,MAAM;AAAA,UACpE,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAED,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,WAAW,QAAQ,UAAU,EAAE,MAAM,CAAC;AAAA,QACtC,sBAAsB,QAAQ,wBAAwB;AAAA,QACtD,iBAAiB,QAAQ,mBAAmB;AAAA,QAC5C,sBAAsB,wBAAwB,EAAE,SAAS,QAAQ,CAAC;AAAA,QAClE,oBAAoB,sBAAsB,EAAE,QAAQ,CAAC;AAAA,QACrD,8BACE,QAAQ,gCAAgC;AAAA,MAC5C;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,wBAAwB;AAC5B,QAAM,oBAAuC,CAAC;AAE9C,aAAW,EAAE,MAAM,WAAW,GAAG,KAAK,sBAAsB;AAC1D,UAAM,sBAAsB,UAAU,SAAS,GAAG,IAC9C,UAAU,MAAM,GAAG,IACnB,UAAU,MAAM,GAAG;AACvB,UAAM,CAAC,YAAY,eAAe,IAAI;AACtC,QAAI,oBAAoB,WAAW,KAAK,CAAC,cAAc,CAAC,iBAAiB;AACvE,YAAM,IAAI;AAAA,QACR,qCAAqC,SAAS;AAAA,MAChD;AAAA,IACF;AAEA,QAAI,aAAa,mBAAmB;AAClC,YAAM,IAAI;AAAA,QACR,wEAAwE,SAAS;AAAA,MACnF;AAAA,IACF;AAGA,UAAM,oBAAoB,OAAO,KAAK;AAAA,MACpC,GAAI,OAAO,aAAa,CAAC;AAAA,MACzB,GAAI,OAAO,UAAU,CAAC;AAAA,IACxB,CAAC,EAAE,KAAK,CAAC,gBAAgB,gBAAgB,UAAU;AAEnD,QAAI,CAAC,mBAAmB;AAEtB,YAAM,oBAAoB;AAAA,QACxB,OAAO,KAAK,EAAE,GAAI,OAAO,aAAa,CAAC,GAAI,GAAI,OAAO,UAAU,CAAC,EAAG,CAAC;AAAA,MACvE;AACA,YAAM,IAAI;AAAA,QACR,2CAA2C,UAAU,WAAW,UAAU,uBAAuB,kBAC9F,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,MACf;AAAA,IACF;AAEA,sBAAkB,SAAS,IAAI;AAC/B,6BAAyB;AAAA,EAC3B;AAEA,MAAI,0BAA0B,GAAG;AAC/B,SAAK,KAAK,EAAE,OAAO,QAAQ,KAAK,yCAAyC,CAAC;AAAA,EAC5E;AAEA,QAAM,kBAKA,OAAO,QAAQ,OAAO,aAAa,CAAC,CAAC,EAExC,QAAQ,CAAC,CAAC,cAAc,QAAQ,MAAM;AACrC,QAAI,SAAS,YAAY,QAAQ,SAAS,YAAY,QAAW;AAC/D,YAAM,IAAI;AAAA,QACR,4CAA4C,YAAY,4CAA4C,SACjG,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,GAAG,EACxB,KAAK,IAAI,CAAC;AAAA,MACf;AAAA,IACF;AAEA,UAAM,qBAAqB,SAAS,cAAc;AAClD,UAAM,aAAa,OAAO,MAAM,kBAAkB,IAC9C,IACA;AACJ,UAAM,mBAAmB,SAAS;AAClC,UAAM,WAAW,OAAO,MAAM,gBAAgB,IAC1C,SACA;AAGJ,QAAI,OAAO,SAAS,YAAY,UAAU;AACxC,aAAO;AAAA,QACL,IAAI,OAAO,YAAY,IAAI,SAAS,OAAO;AAAA,QAC3C;AAAA,QACA,aAAa,SAAS;AAAA,QACtB,KAAK,SAAS;AAAA,QAEd,SAAS,aAAa,WAAW,SAAS,UAAU;AAAA,QACpD,SAAS,aAAa,WAAW,SAAS,UAAU;AAAA,QACpD,QAAQ,SAAS;AAAA,QAEjB,4BACE,SAAS,8BAA8B;AAAA,QACzC,mBAAmB,SAAS,qBAAqB;AAAA,QAEjD;AAAA,QACA;AAAA,QACA,eAAe,SAAS;AAAA,MAC1B;AAAA,IACF;AAOA,WAAO,OAAO,QAAQ,SAAS,OAAO,EACnC,OAAO,CAAC,MAA6C,CAAC,CAAC,EAAE,CAAC,CAAC,EAC3D,IAAI,CAAC,CAAC,aAAa,SAAS,MAAM;AACjC,YAAMC,sBACJ,UAAU,cAAc,SAAS,cAAc;AACjD,YAAMC,cAAa,OAAO,MAAMD,mBAAkB,IAC9C,IACAA;AACJ,YAAME,oBAAmB,UAAU,YAAY,SAAS;AACxD,YAAMC,YAAW,OAAO,MAAMD,iBAAgB,IAC1C,SACAA;AAEJ,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,KAAK,SAAS;AAAA,QAEd,UACG,aAAa,YAAY,WAAW,UAAU,YAC9C,aAAa,WAAW,SAAS,UAAU;AAAA,QAC9C,UACG,aAAa,YAAY,UAAU,UAAU,YAC7C,aAAa,WAAW,SAAS,UAAU;AAAA,QAC9C,QAAQ,UAAU,UAAU,SAAS;AAAA,QAErC,4BACE,UAAU,8BACV,SAAS,8BACT;AAAA,QACF,mBACE,UAAU,qBACV,SAAS,qBACT;AAAA,QAEF,YAAAD;AAAA,QACA,UAAAE;AAAA,QACA,eAAe,UAAU,iBAAiB,SAAS;AAAA,MACrD;AAAA,IACF,CAAC;AAAA,EACL,CAAC,EAEA;AAAA,IACC,CACE,gBAMK;AACL,YAAM,UAAU,SAAS;AAAA,QACvB,CAAC,MAAM,EAAE,SAAS,YAAY;AAAA,MAChC;AACA,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI;AAAA,UACR,oDACE,YAAY,YACd,WAAW,YAAY,WAAW,uBAAuB,SACtD,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,GAAG,EACxB,KAAK,IAAI,CAAC;AAAA,QACf;AAAA,MACF;AAGA,YAAM,sBAAgC,CAAC;AACvC,YAAM,4BAAsC,CAAC;AAC7C,iBAAW,aAAa,OAAO,KAAK,iBAAiB,GAAG;AAEtD,YAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,gBAAM,CAAC,iBAAiB,YAAY,IAAI,UAAU,MAAM,GAAG;AAC3D,cACE,oBAAoB,YAAY,gBAChC,iBAAiB,SACjB;AACA,gCAAoB,KAAK,YAAY;AAAA,UACvC;AAAA,QACF;AAGA,YAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,gBAAM,CAAC,sBAAsB,YAAY,IAAI,UAAU,MAAM,GAAG;AAChE,cAAI,yBAAyB,YAAY,cAAc;AACrD,sCAA0B,KAAK,YAAY;AAAA,UAC7C;AAAA,QACF;AAAA,MACF;AAGA,YAAM,YAAY,eAAe,EAAE,KAAK,YAAY,IAAI,CAAC;AACzD,YAAM,eAAe,kBAAkB,EAAE,KAAK,YAAY,IAAI,CAAC;AAE/D,YAAM,2BAAkC,CAAC;AAEzC,iBAAW,YAAY,qBAAqB;AAC1C,cAAM,WAAW,UAAU,WAAW,QAAQ;AAC9C,YAAI,aAAa,QAAW;AAC1B,gBAAM,IAAI;AAAA,YACR,4CAA4C,QAAQ,yCAAyC,QAAQ,uBAAuB,OAAO;AAAA,cACjI,UAAU;AAAA,YACZ,EACG,IAAI,CAAC,cAAc,IAAI,SAAS,GAAG,EACnC,KAAK,IAAI,CAAC;AAAA,UACf;AAAA,QACF;AAEA,iCAAyB,KAAK,SAAS,QAAQ;AAAA,MACjD;AAEA,YAAM,8BAAqC,CAAC;AAC5C,iBAAW,aAAa,2BAA2B;AACjD,cAAM,cAAc,aAAa,WAAW,SAAS;AACrD,YAAI,gBAAgB,QAAW;AAC7B,gBAAM,IAAI;AAAA,YACR,kDAAkD,SAAS,yCAAyC,SAAS,uBAAuB,OAAO;AAAA,cACzI,aAAa;AAAA,YACf,EACG,IAAI,CAAC,cAAc,IAAI,SAAS,GAAG,EACnC,KAAK,IAAI,CAAC;AAAA,UACf;AAAA,QACF;AAEA,oCAA4B,KAAK,YAAY,QAAQ;AAAA,MACvD;AAEA,UAAI,SAAqB,CAAC,wBAAwB;AAElD,UAAI,YAAY,WAAW,QAAW;AACpC,YACE,MAAM,QAAQ,YAAY,OAAO,KAAK,KACtC,YAAY,OAAO,SAAS,QAC5B;AACA,gBAAM,IAAI;AAAA,YACR,iDAAiD,YAAY,YAAY;AAAA,UAC3E;AAAA,QACF;AAEA,cAAM,uBAAuB,MAAM,QAAQ,YAAY,OAAO,KAAK,IAC/D,YAAY,OAAO,QACnB,CAAC,YAAY,OAAO,KAAK;AAE7B,mBAAW,uBAAuB,sBAAsB;AACtD,gBAAM,WAAW,UAAU,WAAW,mBAAmB;AACzD,cAAI,CAAC,UAAU;AACb,kBAAM,IAAI;AAAA,cACR,mDACE,YAAY,YACd,sBAAsB,mBAAmB,uBAAuB,OAAO;AAAA,gBACrE,UAAU;AAAA,cACZ,EACG,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAMA,cAAM,CAAC,kBAAkB,GAAG,gBAAgB,IAAI;AAAA,UAC9C,YAAY;AAAA,UACZ,YAAY;AAAA,QACd;AAEA,cAAM,yBAAyB,MAAM,QAAQ,gBAAgB,IACzD,mBACA,CAAC,gBAAgB;AAKrB,mBAAW,2BAA2B,0BAA0B;AAC9D,cAAI,CAAC,uBAAuB,SAAS,uBAAuB,GAAG;AAC7D,kBAAM,eACJ,UAAU,WAAW,uBAAuB,EAAG;AAEjD,kBAAM,IAAI;AAAA,cACR,6BAA6B,YAAY,8DACvC,YAAY,YACd,WAAW,YAAY,uBAAuB,uBAC3C,IAAI,CAAC,MAAM,UAAU,WAAW,CAAC,EAAG,QAAQ,EAC5C,IAAI,CAAC,cAAc,IAAI,SAAS,GAAG,EACnC,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAEA,iBAAS,CAAC,0BAA0B,GAAG,gBAAgB;AAAA,MACzD;AAEA,YAAM,eAAe;AAAA,QACnB,cAAc,YAAY;AAAA,QAC1B,aAAa,YAAY;AAAA,QACzB,SAAS,QAAQ;AAAA,QACjB,KAAK,YAAY;AAAA,QACjB,YAAY,YAAY;AAAA,QACxB,UAAU,YAAY;AAAA,QACtB,eAAe,YAAY;AAAA,MAC7B;AAEA,YAAM,kBAAkB,aAAa;AACrC,YAAM,kBAAkB,aAAa;AAErC,UAAI,oBAAoB,UAAa,oBAAoB,QAAW;AAClE,cAAM,IAAI;AAAA,UACR,gCAAgC,aAAa,YAAY;AAAA,QAC3D;AAAA,MACF;AAEA,UAAI,iBAAiB;AAEnB,cAAM,uBAAuB,0BAA0B,eAAe;AAEtE,cAAM,mBAAmB;AAAA,UACvB,GAAG;AAAA,UACH,IAAI,OAAO,YAAY,YAAY,IAAI,YAAY,WAAW;AAAA,UAC9D,MAAM;AAAA,UACN;AAAA,UACA,UAAU;AAAA,YACR,GAAG;AAAA,YACH,4BAA4B,YAAY;AAAA,YACxC;AAAA,UACF;AAAA,QACF;AAEA,YAAI,YAAY,mBAAmB;AACjC,iBAAO;AAAA,YACL;AAAA,YACA;AAAA,cACE,GAAG;AAAA,cACH,IAAI,aAAa,YAAY,YAAY,IAAI,YAAY,WAAW;AAAA,cACpE,MAAM;AAAA,cACN;AAAA,cACA,UAAU;AAAA,gBACR,GAAG;AAAA,gBACH,mBAAmB;AAAA,gBACnB,4BACE,YAAY;AAAA,cAChB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,eAAO,CAAC,gBAAgB;AAAA,MAC1B;AAEA,YAAM,mBAAmB,MAAM,QAAQ,eAAe,IAClD,gBAAgB,IAAI,CAAC,MAAM,YAAY,CAAC,CAAC,IACzC,kBACE,YAAY,eAAe,IAC3B;AAEN,UAAI,qBAAqB,QAAW;AAClC,mBAAW,WAAW,MAAM,QAAQ,gBAAgB,IAChD,mBACA,CAAC,gBAAgB,GAAG;AACtB,cAAI,CAAC,QAAQ,WAAW,IAAI;AAC1B,kBAAM,IAAI;AAAA,cACR,kDAAkD,OAAO,WAAW,QAAQ;AAAA,gBAC1E;AAAA,gBACA;AAAA,cACF,CAAC;AAAA,YACH;AACF,cAAI,QAAQ,WAAW;AACrB,kBAAM,IAAI;AAAA,cACR,kDAAkD,OAAO,UAAU,QAAQ,MAAM;AAAA,YACnF;AAAA,QACJ;AAAA,MACF;AAEA,YAAM,YAAY;AAAA,QAChB,GAAG;AAAA,QACH,IAAI,OAAO,YAAY,YAAY,IAAI,YAAY,WAAW;AAAA,QAC9D,MAAM;AAAA,QACN;AAAA,QACA,UAAU;AAAA,UACR,SAAS;AAAA,UACT;AAAA,UACA,4BAA4B,YAAY;AAAA,QAC1C;AAAA,MACF;AAEA,UAAI,YAAY,mBAAmB;AACjC,eAAO;AAAA,UACL;AAAA,UACA;AAAA,YACE,GAAG;AAAA,YACH,IAAI,aAAa,YAAY,YAAY,IAAI,YAAY,WAAW;AAAA,YACpE,MAAM;AAAA,YACN;AAAA,YACA,UAAU;AAAA,cACR,WAAW,MAAM,QAAQ,gBAAgB,IACrC,mBACA,qBAAqB,SACnB,SACA,CAAC,gBAAgB;AAAA,cACvB,mBAAmB;AAAA,cACnB,4BACE,YAAY;AAAA,YAChB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAO,eAAO,CAAC,SAAS;AAAA,IAC1B;AAAA,EACF,EAEC,OAAO,CAAC,WAAW;AAClB,UAAM,iCACJ,kBAAkB,MAAM,KAAK,yBAAyB,MAAM,IACxD,OAAO,SAAS,kBAAkB,WAAW,IAC7C,OAAO,SAAS,OAAO,CAAC,GAAG,WAAW;AAC5C,QAAI,CAAC,gCAAgC;AACnC,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,8CACH,OAAO,YACT,KAAK,kBAAkB,MAAM,IAAI,gBAAgB,MAAM;AAAA,MACzD,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT,CAAC;AAEH,QAAM,eAA8B,OAAO,QAAQ,OAAO,UAAU,CAAC,CAAC,EACnE,QAAQ,CAAC,CAAC,YAAY,iBAAiB,MAAM;AAC5C,UAAM,qBAAqB,kBAAkB,cAAc;AAC3D,UAAM,aAAa,OAAO,MAAM,kBAAkB,IAC9C,IACA;AACJ,UAAM,mBAAmB,kBAAkB;AAC3C,UAAM,WAAW,OAAO,MAAM,gBAAgB,IAC1C,SACA;AAEJ,UAAM,mBAAmB,kBAAkB;AAC3C,UAAM,WAAW,OAAO,MAAM,gBAAgB,IAAI,IAAI;AAEtD,QAAI,CAAC,OAAO,UAAU,QAAQ,KAAK,aAAa,GAAG;AACjD,YAAM;AAAA,QACJ,yDAAyD,UAAU,UAAU,QAAQ;AAAA,MACvF;AAAA,IACF;AAEA,QAAI,OAAO,kBAAkB,YAAY,UAAU;AACjD,YAAM,UAAU,SAAS;AAAA,QACvB,CAAC,MAAM,EAAE,SAAS,kBAAkB;AAAA,MACtC;AACA,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI;AAAA,UACR,wDAAwD,UAAU,WAChE,kBAAkB,OACpB,uBAAuB,SACpB,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,GAAG,EACxB,KAAK,IAAI,CAAC;AAAA,QACf;AAAA,MACF;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,IAAI,SAAS,UAAU,IAAI,kBAAkB,OAAO;AAAA,QACpD;AAAA,QACA,aAAa,kBAAkB;AAAA,QAC/B,SAAS,QAAQ;AAAA,QACjB;AAAA,QACA;AAAA,QACA,UAAU;AAAA,UACR;AAAA,UACA,QAAQ,aAAa;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAMA,WAAO,OAAO,QAAQ,kBAAkB,OAAO,EAC5C,OAAO,CAAC,MAA6C,CAAC,CAAC,EAAE,CAAC,CAAC,EAC3D,IAAI,CAAC,CAAC,aAAa,SAAS,MAAM;AACjC,YAAM,UAAU,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,WAAW;AAC3D,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI;AAAA,UACR,wDAAwD,UAAU,WAAW,WAAW,uBAAuB,SAC5G,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,GAAG,EACxB,KAAK,IAAI,CAAC;AAAA,QACf;AAAA,MACF;AAEA,YAAMH,sBACJ,UAAU,cAAc,kBAAkB,cAAc;AAC1D,YAAMC,cAAa,OAAO,MAAMD,mBAAkB,IAC9C,IACAA;AACJ,YAAME,oBACJ,UAAU,YAAY,kBAAkB;AAC1C,YAAMC,YAAW,OAAO,MAAMD,iBAAgB,IAC1C,SACAA;AAEJ,YAAME,oBACJ,UAAU,YAAY,kBAAkB;AAC1C,YAAMC,YAAW,OAAO,MAAMD,iBAAgB,IAC1C,IACAA;AAEJ,UAAI,CAAC,OAAO,UAAUC,SAAQ,KAAKA,cAAa,GAAG;AACjD,cAAM;AAAA,UACJ,yDAAyD,UAAU,UAAUA,SAAQ;AAAA,QACvF;AAAA,MACF;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,IAAI,SAAS,UAAU,IAAI,WAAW;AAAA,QACtC;AAAA,QACA;AAAA,QACA,SAAS,QAAQ;AAAA,QACjB,YAAAJ;AAAA,QACA,UAAAE;AAAA,QACA,UAAU;AAAA,UACR,UAAUE;AAAA,UACV,QAAQJ,cAAaI;AAAA,QACvB;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACL,CAAC,EACA,OAAO,CAAC,gBAAgB;AACvB,UAAM,gCACJ,kBAAkB,GAAG,YAAY,UAAU,QAAQ,MAAM;AAC3D,QAAI,CAAC,+BAA+B;AAClC,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,8CAA8C,YAAY,UAAU;AAAA,MAC3E,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT,CAAC;AAEH,QAAM,UAAU,CAAC,GAAG,iBAAiB,GAAG,YAAY;AAGpD,QAAM,sBAAsB,SAAS,OAAO,CAAC,YAAY;AACvD,UAAM,aAAa,QAAQ;AAAA,MACzB,CAAC,WAAW,OAAO,gBAAgB,QAAQ;AAAA,IAC7C;AACA,QAAI,CAAC,YAAY;AACf,WAAK,KAAK;AAAA,QACR,OAAO;AAAA,QACP,KAAK,sCAAsC,QAAQ,IAAI;AAAA,MACzD,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT,CAAC;AAED,QAAM,gBAAkC,CAAC;AACzC,MAAI,OAAO,SAAS,2BAA2B,QAAW;AACxD,kBAAc,yBACZ,OAAO,QAAQ;AACjB,SAAK,KAAK;AAAA,MACR,OAAO;AAAA,MACP,KAAK,mCAAmC,cAAc,sBAAsB;AAAA,IAC9E,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,eAAsB,oCAAoC;AAAA,EACxD;AAAA,EACA;AAAA,EACA;AACF,GAIG;AACD,MAAI;AACF,UAAM,SAAS,MAAM,gCAAgC;AAAA,MACnD;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,mBAAmB,OAAO;AAAA,MAC1B,gBAAgB,OAAO;AAAA,MACvB,eAAe,OAAO;AAAA,MACtB,MAAM,OAAO;AAAA,IACf;AAAA,EACF,SAAS,QAAQ;AACf,UAAM,QAAQ;AACd,WAAO,EAAE,QAAQ,SAAS,MAAM;AAAA,EAClC;AACF;AAEA,SAAS,gBAAgB,kBAA0B;AACjD,QAAM,SAAU,MAAwC,gBAAgB;AACxE,SAAO,GAAG,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,OAAO,QAAQ;AACzD;;;Aa/2BA,OAAO,iBAAiB;AAGjB,IAAM,QACX;AAEK,IAAM,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQb,SAAS,iBAAiB,MAAc;AAC7C,QAAM,IAAI,IAAI,YAAY,IAAI;AAI9B,QAAM,YAAY;AAClB,IAAE,QAAQ,OAAO,IAAI;AACrB,SAAO;AACT;AAEO,IAAM,mBAAmB,MAAc;AAC5C,SAAO;AAAA,IACL,MAAM;AAAA,IACN,WAAW,CAAC,MAAM,OAAO;AACvB,UAAI,MAAM,KAAK,IAAI,GAAG;AACpB,cAAM,IAAI,iBAAiB,IAAI;AAC/B,cAAM,cAAc,EAAE,SAAS;AAC/B,cAAM,YAAY,EAAE,YAAY,EAAE,QAAQ,GAAG,CAAC;AAE9C,eAAO,EAAE,MAAM,aAAa,KAAK,UAAU;AAAA,MAC7C,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;;;ACxBO,IAAM,cAAc,CAAC,EAAE,OAAO,MAA0B;AAC7D,QAAM,OAA4D,CAAC;AAGnE,SAAO,QAAQ,SAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,MAAM,KAAK,MAAM;AAC1D,8BAA0B,MAAM,MAAM;AAEtC,UAAM,aAAa,oBAAI,IAAY;AACnC,eAAW,aAAa,OAAO;AAC7B,UAAI,WAAW,IAAI,SAAS,GAAG;AAC7B,cAAM,IAAI;AAAA,UACR,4BAA4B,IAAI,+BAA+B,SAAS;AAAA,QAC1E;AAAA,MACF;AACA,iBAAW,IAAI,SAAS;AAAA,IAC1B;AAAA,EACF,CAAC;AAGD,SAAO,QAAQ,UAAU,MAAM,CAAC,EAAE;AAAA,IAChC,CAAC,CAAC,WAAW,EAAE,OAAO,YAAY,CAAC,MAAM;AACvC,gCAA0B,WAAW,OAAO;AAG5C,UAAI,MAAM,OAAO;AACf,cAAM,IAAI;AAAA,UACR,6BAA6B,SAAS;AAAA,QACxC;AAEF,UAAI,aAAa,MAAM,EAAE;AACvB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AACF,UAAI,aAAa,MAAM,EAAE;AACvB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AACF,UAAI,YAAY,MAAM,EAAE;AACtB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AACF,UAAI,aAAa,MAAM,EAAE;AACvB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AACF,UAAI,kBAAkB,MAAM,EAAE;AAC5B,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AAEF,UACE,MAAM,GAAG,SAAS,MAAM,YACxB,MAAM,GAAG,SAAS,MAAM,YACxB,MAAM,GAAG,SAAS,MAAM,SACxB,MAAM,GAAG,SAAS,MAAM;AAExB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS,cAAc,MAAM,GAAG,SAAS,CAAC;AAAA,QAC9F;AAEF,UAAI,iBAAiB,MAAM,EAAE;AAC3B,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AACF,UAAI,aAAa,MAAM,EAAE;AACvB,cAAM,IAAI;AAAA,UACR,kDAAkD,SAAS;AAAA,QAC7D;AAGF,aAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,YAAI,eAAe;AAAM;AAEzB,kCAA0B,YAAY,QAAQ;AAE9C,YAAI,YAAY,MAAM,GAAG;AACvB,gBAAM,aAAa,OAAO,QAAQ,KAAK,EAAE;AAAA,YACvC,CAAC,CAAC,CAAC,MAAM,MAAM,OAAO,YAAY;AAAA,UACpC;AAEA,cAAI,eAAe,QAAW;AAC5B,kBAAM,eAAe,OAAO,KAAK,KAAK,EAAE;AAAA,cACtC,CAAC,MAAM,MAAM;AAAA,YACf;AACA,kBAAM,IAAI;AAAA,cACR,2CAA2C,SAAS,IAAI,UAAU,6CAChE,OAAO,YAAY,CACrB,uBAAuB,aACpB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAEA,cAAI,CAAC,kBAAkB,WAAW,CAAC,CAAC,GAAG;AACrC,kBAAM,oBAAoB,OAAO,KAAK,KAAK,EAAE;AAAA,cAC3C,CAAC,MAAM,MAAM,cAAc,kBAAkB,MAAM,CAAC,CAAC;AAAA,YACvD;AACA,kBAAM,IAAI;AAAA,cACR,2CAA2C,SAAS,IAAI,UAAU,wDAChE,OAAO,YAAY,CACrB,uBAAuB,kBACpB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAEA,YAAI,aAAa,MAAM,GAAG;AACxB,gBAAM,YAAY,OAAO,QAAQ,UAAU,MAAM,CAAC,EAAE;AAAA,YAClD,CAAC,CAAC,IAAI,MAAM,SAAS,OAAO,iBAAiB;AAAA,UAC/C;AAEA,cAAI,cAAc,QAAW;AAC3B,kBAAM,cAAc,OAAO,KAAK,UAAU,MAAM,CAAC,EAAE;AAAA,cACjD,CAAC,MAAM,MAAM;AAAA,YACf;AAEA,kBAAM,IAAI;AAAA,cACR,2CAA2C,SAAS,IAAI,UAAU,4CAChE,OAAO,iBAAiB,CAC1B,uBAAuB,YACpB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAEA,gBAAM,mBAAmB,OAAO,QAAQ,UAAU,CAAC,EAAE,KAAK;AAC1D,gBAAM,aAAa,iBAAiB;AAAA,YAClC,CAAC,CAACC,WAAU,MAAMA,gBAAe,OAAO,kBAAkB;AAAA,UAC5D;AAEA,cAAI,eAAe,QAAW;AAC5B,kBAAM,IAAI;AAAA,cACR,2CAA2C,SAAS,IAAI,UAAU,6CAChE,OAAO,iBAAiB,CAC1B,IACE,OAAO,iBAAiB,CAC1B,uBAAuB,iBACpB,IAAI,CAAC,MAAM,IAAI,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,EACnC,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAEA,cAAI,CAAC,kBAAkB,WAAW,CAAC,CAAC,GAAG;AACrC,kBAAM,wBAAwB,iBAAiB;AAAA,cAAO,CAAC,CAAC,EAAE,CAAC,MACzD,kBAAkB,CAAC;AAAA,YACrB;AACA,kBAAM,IAAI;AAAA,cACR,2CAA2C,SAAS,IAAI,UAAU,wDAChE,OAAO,iBAAiB,CAC1B,IACE,OAAO,iBAAiB,CAC1B,uBAAuB,sBACpB,IAAI,CAAC,MAAM,IAAI,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,EACnC,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAEA,YAAI,aAAa,MAAM,GAAG;AACxB,gBAAM,iBAAiB,OAAO,QAAQ,SAAS,MAAM,CAAC,EAAE;AAAA,YACtD,CAAC,CAAC,QAAQ,MAAM,aAAa,OAAO,OAAO;AAAA,UAC7C;AACA,cAAI,mBAAmB,QAAW;AAChC,kBAAM,IAAI;AAAA,cACR,mCAAmC,SAAS,IAAI,UAAU,0CACxD,OAAO,OAAO,CAChB,uBAAuB,OAAO,KAAK,SAAS,MAAM,CAAC,EAChD,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAEA,YAAI,kBAAkB,MAAM,GAAG;AAC7B,gBAAM,kBAAkB,OAAO,QAAQ,UAAU,MAAM,CAAC,EAAE;AAAA,YACxD,CAAC,CAACC,UAAS,MAAMA,eAAc,sBAAsB,MAAM;AAAA,UAC7D;AAEA,cAAI,oBAAoB,QAAW;AACjC,kBAAM,IAAI;AAAA,cACR,0CAA0C,SAAS,IAAI,UAAU,gDAAgD;AAAA,gBAC/G;AAAA,cACF,CAAC,uBAAuB,OAAO,KAAK,UAAU,MAAM,CAAC,EAClD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EACtB,KAAK,IAAI,CAAC;AAAA,YACf;AAAA,UACF;AAEA,cAAI,gBAAgB,CAAC,EAAE,MAAM,GAAG,SAAS,MAAM,OAAO,SAAS,GAAG;AAChE,kBAAM,IAAI;AAAA,cACR,0CAA0C,SAAS,IAAI,UAAU,qEAAqE,OAAO,SAAS,CAAC,gBAAgB,gBAAgB,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC;AAAA,YAC/M;AAAA,UACF;AAAA,QAQF;AAAA,MAiBF,CAAC;AAGD,UAAI,gBAAgB;AAAW;AAE/B,iBAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,WAAW,GAAG;AACvD,kCAA0B,MAAM,OAAO;AACvC,cAAM,SAAS,MAAM,SAAS;AAE9B,YAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,cAAI,OAAO,WAAW;AACpB,kBAAM,IAAI;AAAA,cACR,6BAA6B,IAAI;AAAA,YACnC;AAEF,cAAI,OAAO,WAAW,OAAO,MAAkB,EAAE;AAC/C,kBAAM,IAAI;AAAA,cACR,6BAA6B,IAAI;AAAA,YACnC;AAEF,qBAAW,KAAK,QAAQ;AACtB,gBAAI,MAAM,CAAC,MAAM;AACf,oBAAM,IAAI;AAAA,gBACR,6BAA6B,IAAI,6CAA6C,CAAC,uBAAuB,OAAO;AAAA,kBAC3G;AAAA,gBACF,EAAE,KAAK,IAAI,CAAC;AAAA,cACd;AAEF,gBAAI,aAAa,MAAM,CAAC,CAAC;AACvB,oBAAM,IAAI;AAAA,gBACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,cACrF;AAEF,gBAAI,YAAY,MAAM,CAAC,CAAC;AACtB,oBAAM,IAAI;AAAA,gBACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,cACrF;AAEF,gBAAI,aAAa,MAAM,CAAC,CAAC;AACvB,oBAAM,IAAI;AAAA,gBACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,cACrF;AAAA,UACJ;AAAA,QACF,OAAO;AACL,cAAI,WAAW,MAAM;AACnB,iBAAK,KAAK;AAAA,cACR,OAAO;AAAA,cACP,KAAK,mBAAmB,IAAI;AAAA,YAC9B,CAAC;AACD,mBAAO,YAAY,IAAI;AACvB;AAAA,UACF;AAEA,cAAI,MAAM,MAAM,MAAM;AACpB,kBAAM,IAAI;AAAA,cACR,6BAA6B,IAAI,6CAA6C,MAAM,uBAAuB,OAAO;AAAA,gBAChH;AAAA,cACF,EACG;AAAA,gBACC,CAAC,CAAC,GAAGC,OAAM,MACT,CAAC,YAAYA,OAAM,KAAK,CAAC,aAAaA,OAAM;AAAA,cAChD,EACC,IAAI,CAAC,CAAC,UAAU,MAAM,UAAU,EAChC,KAAK,IAAI,CAAC;AAAA,YACf;AAEF,cAAI,aAAa,MAAM,MAAM,CAAC;AAC5B,kBAAM,IAAI;AAAA,cACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,YACrF;AAEF,cAAI,YAAY,MAAM,MAAM,CAAC;AAC3B,kBAAM,IAAI;AAAA,cACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,YACrF;AAEF,cAAI,aAAa,MAAM,MAAM,CAAC;AAC5B,kBAAM,IAAI;AAAA,cACR,+CAA+C,MAAM,0BAA0B,IAAI;AAAA,YACrF;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,QAAQ,KAAK;AACxB;AAEA,IAAM,4BAA4B,CAAC,KAAa,SAAiB;AAC/D,MAAI,QAAQ;AACV,UAAM,IAAI;AAAA,MACR,sBAAsB,IAAI;AAAA,IAC5B;AAEF,MAAI,CAAC,mBAAmB,KAAK,GAAG;AAC9B,UAAM,IAAI;AAAA,MACR,sBAAsB,IAAI,UAAU,GAAG;AAAA,IACzC;AACJ;AAEO,SAAS,gBAAgB,EAAE,OAAO,GAAuB;AAC9D,MAAI;AACF,UAAM,SAAS,YAAY,EAAE,OAAO,CAAC;AACrC,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,QAAQ,OAAO;AAAA,MACf,MAAM,OAAO;AAAA,IACf;AAAA,EACF,SAAS,QAAQ;AACf,UAAM,QAAQ;AACd,WAAO,EAAE,QAAQ,SAAS,MAAM;AAAA,EAClC;AACF;;;ACzVA,SAAS,oBAAoB;AAC7B,SAAS,wBAAwB;AACjC,SAAS,SAAS,uBAAuB;AAEzC,IAAM,wBAAN,cAAoC,MAAM;AAAA,EAC/B,OAAO;AAClB;AAEA,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAC3B,OAAO;AAClB;AAEA,IAAM,sBAAN,cAAkC,MAAM;AAAA,EAC7B,OAAO;AAClB;AAQO,SAAS,mBAAmB,MAAc,OAA6B;AAC5E,MAAI;AAEJ,MAAI,kDAAkD,KAAK,MAAM,OAAO,GAAG;AAGzE,UAAM,YAAY,MAAM,QAAQ,MAAM,QAAQ,EAAE,CAAC;AAIjD,UAAM,aAAa,MAAM,QACtB,MAAM,IAAI,EACV,MAAM,CAAC,EACP,IAAI,CAAC,YAAY;AAChB,UAAI,WAA+B;AACnC,UAAI,SAA6B;AACjC,UAAI,QAAQ,SAAS,WAAW,GAAG;AAEjC,cAAM,IAAI,QAAQ,MAAM,WAAW;AACnC,mBAAW,EAAE,CAAC;AACd,iBAAS,EAAE,CAAC;AAAA,MACd,OAAO;AAEL,iBAAS,QAAQ,MAAM,CAAC;AAAA,MAC1B;AACA,aAAO,EAAE,UAAU,OAAO;AAAA,IAC5B,CAAC,EAAE,CAAC;AAGN,QAAI,CAAC;AAAY,aAAO;AAExB,oBACE,cAAc,qBACV,IAAI,sBAAsB,WAAW,MAAM,IAC3C,cAAc,iBACZ,IAAI,kBAAkB,WAAW,MAAM,IACvC,IAAI,oBAAoB,WAAW,MAAM;AACjD,QAAI,WAAW;AACb,oBAAc,QAAQ,UAAU,WAAW,QAAQ;AAAA,EACvD,WAGS,MAAM,OAAO;AACpB,UAAM,cAAc,gBAAgB,MAAM,KAAK;AAE/C,UAAM,kBAAkB,CAAC;AACzB,eAAW,iBAAiB,aAAa;AACvC,UAAI,cAAc,WAAW,SAAS,0BAA0B;AAAG;AACnE,sBAAgB,KAAK,aAAa;AAAA,IACpC;AAEA,UAAM,YAAY,gBACf,IAAI,CAAC,EAAE,MAAAC,OAAM,YAAY,QAAQ,WAAW,MAAM;AACjD,YAAM,SAAS;AACf,YAAMC,SAAO,GAAGD,KAAI,GAAG,eAAe,OAAO,IAAI,UAAU,KAAK,EAAE,GAChE,WAAW,OAAO,IAAI,MAAM,KAAK,EACnC;AACA,UAAI,eAAe,QAAQ,eAAe,aAAa;AACrD,eAAO,GAAG,MAAM,IAAIC,MAAI;AAAA,MAC1B,OAAO;AACL,eAAO,GAAG,MAAM,IAAI,UAAU,KAAKA,MAAI;AAAA,MACzC;AAAA,IACF,CAAC,EACA,KAAK,IAAI;AAEZ,oBAAgB;AAChB,kBAAc,QAAQ;AAAA,EACxB,OAEK;AACH,oBAAgB;AAAA,EAClB;AAIA,MAAI,cAAc,OAAO;AACvB,UAAM,kBAAkB,gBAAgB,cAAc,KAAK;AAE3D,QAAI,YAAgC;AACpC,eAAW,EAAE,MAAAD,OAAM,YAAY,OAAO,KAAK,iBAAiB;AAC1D,UAAIA,UAAS,QAAQ,eAAe,MAAM;AACxC,YAAI;AACF,gBAAM,qBAAqB,aAAaA,OAAM,EAAE,UAAU,QAAQ,CAAC;AACnE,sBAAY;AAAA,YACV;AAAA,YACA,EAAE,OAAO,EAAE,MAAM,YAAY,QAAQ,UAAU,OAAU,EAAE;AAAA,YAC3D,EAAE,eAAe,KAAK;AAAA,UACxB;AACA;AAAA,QACF,SAAS,KAAK;AAAA,QAEd;AAAA,MACF;AAAA,IACF;AAEA,kBAAc,QAAQ,GAAG,cAAc,IAAI,KAAK,cAAc,OAAO;AAAA,EAAK,cAAc,KAAK;AAC7F,QAAI;AAAW,oBAAc,SAAS;AAAA,EAAK,SAAS;AAAA,EACtD;AAGA,QAAM,OACJ,cAAc,SAAS,0BACnB,iBACA,cAAc,SAAS,uBACrB,cAAc,SAAS,wBACvB,aACA;AACR,gBAAc,UAAU,eAAe,IAAI,IAAI,IAAI,KAAK,cAAc,OAAO;AAE7E,SAAO;AACT;;;AxBzGA,IAAM,mBAAmB;AAyClB,IAAM,SAAS,OAAO;AAAA,EAC3B;AACF,MAEwB;AACtB,QAAM,cAAc;AACpB,QAAM,gBAAgB,OAAO,QAAQ,OAElC,QAAQ,OAAO,GAAG,EAElB,QAAQ,aAAa,MAAM;AAC9B,QAAM,WAAW,IAAI,OAAO,IAAI,aAAa,gBAAgB;AAE7D,QAAM,aAAa;AAAA,IACjB,gBAAgB,oBAAI,IAAY;AAAA,IAChC,cAAc,oBAAI,QAAe;AAAA,IACjC,WAAW;AAAA,IACX,cAAc;AAAA,IAAC;AAAA,IACf,gBAAgB,CAAC,UAAiB,WAAW,aAAa,IAAI,KAAK;AAAA,IACnE,MAAM,CAAC,QAAgB;AACrB,aAAO,OAAO,MAAM,EAAE,SAAS,eAAe,IAAI,CAAC;AAAA,IACrD;AAAA,IACA,MAAM,CAAC,QAAgB;AACrB,iBAAW,YAAY;AACvB,aAAO,OAAO,MAAM,EAAE,SAAS,eAAe,IAAI,CAAC;AAAA,IACrD;AAAA,IACA,UAAU,CAAC,QAAgB;AACzB,UAAI,WAAW,eAAe,IAAI,GAAG;AAAG;AACxC,iBAAW,YAAY;AACvB,aAAO,OAAO,MAAM,EAAE,SAAS,eAAe,IAAI,CAAC;AACnD,iBAAW,eAAe,IAAI,GAAG;AAAA,IACnC;AAAA,IACA,OAAO,CAAC,QAAgB;AACtB,iBAAW,YAAY;AACvB,aAAO,OAAO,MAAM,EAAE,SAAS,eAAe,IAAI,CAAC;AAAA,IACrD;AAAA,EACF;AAEA,QAAM,gBAAgB,MAAM,aAAa;AAAA,IACvC,MAAM,OAAO,QAAQ;AAAA,IACrB,UAAUE,MAAK,KAAK,OAAO,QAAQ,WAAW,MAAM;AAAA,IACpD,WAAW;AAAA,IACX,cAAc;AAAA,IACd,QAAQ,EAAE,KAAK,MAAM;AAAA,IACrB,SAAS,CAAC,wBAAwB,GAAG,iBAAiB,CAAC;AAAA,EACzD,CAAC;AAGD,QAAM,cAAc,gBAAgB,WAAW,CAAC,CAAC;AAEjD,QAAM,iBAAiB,IAAI,eAAe,aAAa;AACvD,2BAAyB;AAAA,IACvB,cAAc,CAAC,WAAW,eAAe,aAAa,MAAM;AAAA,EAC9D,CAAC;AAED,QAAM,iBAAiB,IAAI,eAAe;AAAA,IACxC,MAAM,cAAc,OAAO;AAAA,IAC3B,aAAa,CAAC,OAAO,eAAe,YAAY,IAAI,KAAK;AAAA,IACzD,WAAW,CAAC,IAAI,aAAa,eAAe,UAAU,IAAI,UAAU,KAAK;AAAA,EAC3E,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAQO,IAAM,QAAQ,OACnB,cACA;AAAA,EACE;AAAA,EACA;AACF,MAGyB;AACzB,QAAM,EAAE,OAAO,IAAI;AAEnB,QAAM,CAAC,cAAc,cAAc,uBAAuB,IACxD,MAAM,QAAQ,IAAI;AAAA,IAChB,cAAc,YAAY;AAAA,IAC1B,cAAc,YAAY;AAAA,IAC1B,yBAAyB,YAAY;AAAA,EACvC,CAAC;AAEH,MAAI,aAAa,WAAW,SAAS;AACnC,WAAO,EAAE,QAAQ,SAAS,OAAO,aAAa,MAAM;AAAA,EACtD;AACA,MAAI,aAAa,WAAW,SAAS;AACnC,WAAO,EAAE,QAAQ,SAAS,OAAO,aAAa,MAAM;AAAA,EACtD;AACA,MAAI,wBAAwB,WAAW,SAAS;AAC9C,WAAO,EAAE,QAAQ,SAAS,OAAO,wBAAwB,MAAM;AAAA,EACjE;AAEA,QAAM,WAAqB;AAAA,IACzB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,mBAAmB;AAAA,EACrB;AAEA,QAAM,cAAc,MAAM,iBAAiB,cAAc,QAAQ;AAIjE,MAAI,OAAO;AAET,UAAM,cAAc,CAAC,OAAO,QAAQ,cAAc,OAAO,QAAQ,SAAS;AAC1E,UAAM,eAAe;AAAA,MACnBA,MAAK,KAAK,OAAO,QAAQ,SAAS,iBAAiB;AAAA,MACnDA,MAAK,KAAK,OAAO,QAAQ,SAAS,YAAY;AAAA,IAChD;AAEA,UAAM,gBAAgB,CAAC,aAAqB;AAC1C,YAAM,iBAAiB,YAAY,KAAK,CAAC,QAAQ;AAC/C,cAAM,MAAMA,MAAK,SAAS,KAAK,QAAQ;AACvC,eAAO,CAAC,IAAI,WAAW,IAAI,KAAK,CAACA,MAAK,WAAW,GAAG;AAAA,MACtD,CAAC;AAED,YAAM,gBAAgB,aAAa,SAAS,QAAQ;AACpD,aAAO,kBAAkB;AAAA,IAC3B;AAEA,UAAM,eAAe,OAAO,UAAkB;AAC5C,UAAI,cAAc,KAAK;AAAG;AAG1B,YAAM,OAAO;AAAA,QACX,kBAAkB,KAAK;AAAA,QACvB,OAAO,QAAQ;AAAA,MACjB,EAAE;AAIF,YAAM,cAAc;AAAA,QAClB,GAAG,aAAa,eAAe,YAAY,kBAAkB,CAAC,IAAI,CAAC;AAAA,MACrE;AAGA,UAAI,YAAY,WAAW;AAAG;AAK9B,YAAM,kBAAkB,YAAY;AAAA,QAClC,OAAO,QAAQ,WAAW,QAAQ,OAAO,GAAG;AAAA,MAC9C;AACA,YAAM,kBAAkB,YAAY;AAAA,QAClC,OAAO,QAAQ,WAAW,QAAQ,OAAO,GAAG;AAAA,MAC9C;AACA,YAAM,4BAA4B,YAAY;AAAA,QAAK,CAACC,UAClD,aAAa,SAAS,KAAKA,KAAI;AAAA,MACjC;AAIA,UAAI,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,2BAA2B;AACtE;AAAA,MACF;AAEA,aAAO,OAAO,KAAK;AAAA,QACjB,SAAS;AAAA,QACT,KAAK,cAAc,YAChB,IAAI,CAAC,MAAM,IAAID,MAAK,SAAS,OAAO,QAAQ,SAAS,CAAC,CAAC,GAAG,EAC1D,KAAK,IAAI,CAAC;AAAA,MACf,CAAC;AAED,UAAI,iBAAiB;AACnB,cAAM,SAAS,MAAM,cAAc,YAAY;AAC/C,YAAI,OAAO,WAAW,SAAS;AAC7B,kBAAQ,EAAE,QAAQ,SAAS,OAAO,OAAO,MAAM,CAAC;AAChD;AAAA,QACF;AACA,iBAAS,SAAS;AAAA,MACpB;AAEA,UAAI,iBAAiB;AACnB,cAAM,SAAS,MAAM,cAAc,YAAY;AAC/C,YAAI,OAAO,WAAW,SAAS;AAC7B,kBAAQ,EAAE,QAAQ,SAAS,OAAO,OAAO,MAAM,CAAC;AAChD;AAAA,QACF;AACA,iBAAS,SAAS;AAAA,MACpB;AAEA,UAAI,2BAA2B;AAC7B,cAAM,SAAS,MAAM,yBAAyB,YAAY;AAC1D,YAAI,OAAO,WAAW,SAAS;AAC7B,kBAAQ,EAAE,QAAQ,SAAS,OAAO,OAAO,MAAM,CAAC;AAChD;AAAA,QACF;AACA,iBAAS,oBAAoB;AAAA,MAC/B;AAEA,YAAME,eAAc,MAAM,iBAAiB,cAAc,QAAQ;AACjE,cAAQA,YAAW;AAAA,IACrB;AAEA,iBAAa,cAAc,QAAQ,GAAG,UAAU,YAAY;AAAA,EAC9D;AAEA,SAAO;AACT;AAEO,IAAM,OAAO,OAAO,iBAAyC;AAClE,QAAM,aAAa,eAAe,MAAM;AACxC,eAAa,OAAO,OAAO,MAAM;AAAA,IAC/B,SAAS;AAAA,IACT,KAAK;AAAA,EACP,CAAC;AACH;AAEA,IAAM,gBAAgB,OACpB,iBAIG;AACH,QAAM,gBAAgB,MAAM,YAAY,cAAc;AAAA,IACpD,MAAM,aAAa,OAAO,QAAQ;AAAA,EACpC,CAAC;AAED,MAAI,cAAc,WAAW,SAAS;AACpC,iBAAa,OAAO,OAAO,MAAM;AAAA,MAC/B,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO,cAAc;AAAA,IACvB,CAAC;AAED,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,cAAc,QAAQ;AAErC,QAAM,cAAc,WAAW,QAAQ,EACpC,OAAO,KAAK,UAAU,MAAM,CAAC,EAC7B,OAAO,KAAK;AAEf,SAAO,EAAE,QAAQ,WAAW,QAAQ,YAAY;AAClD;AAEA,IAAM,gBAAgB,OACpB,iBAIG;AACH,QAAM,gBAAgB,MAAM,YAAY,cAAc;AAAA,IACpD,MAAM,aAAa,OAAO,QAAQ;AAAA,EACpC,CAAC;AAED,MAAI,cAAc,WAAW,SAAS;AACpC,iBAAa,OAAO,OAAO,MAAM;AAAA,MAC/B,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO,cAAc;AAAA,IACvB,CAAC;AAED,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,cAAc,QAAQ;AAErC,QAAM,cAAc,WAAW,QAAQ,EACpC,OAAO,KAAK,UAAU,MAAM,CAAC,EAC7B,OAAO,KAAK;AAEf,SAAO,EAAE,QAAQ,WAAW,QAAQ,YAAY;AAClD;AAEA,IAAM,2BAA2B,OAC/B,iBAQG;AACH,QAAM,UAAUF,MACb,KAAK,aAAa,OAAO,QAAQ,QAAQ,sBAAsB,EAC/D,QAAQ,OAAO,GAAG;AACrB,QAAM,QAAQ,KAAK,KAAK,OAAO;AAE/B,QAAM,iBAAiB,MAAM,QAAQ;AAAA,IACnC,MAAM,IAAI,OAAO,UAAU;AAAA,MACzB,GAAI,MAAM,YAAY,cAAc,EAAE,KAAK,CAAC;AAAA,MAC5C;AAAA,IACF,EAAE;AAAA,EACJ;AAEA,QAAM,oBAA0C,CAAC;AAEjD,aAAW,iBAAiB,gBAAgB;AAC1C,QAAI,cAAc,WAAW,SAAS;AACpC,mBAAa,OAAO,OAAO,MAAM;AAAA,QAC/B,SAAS;AAAA,QACT,KAAK,0BAA0BA,MAAK;AAAA,UAClC,aAAa,OAAO,QAAQ;AAAA,UAC5B,cAAc;AAAA,QAChB,CAAC;AAAA,QACD,OAAO,cAAc;AAAA,MACvB,CAAC;AAED,aAAO;AAAA,IACT;AAEA,sBAAkB,KAAK,GAAI,cAAc,SAAS,QAAQ,OAAO,CAAC,CAAE;AAAA,EACtE;AAIA,QAAMG,QAAO,WAAW,QAAQ;AAChC,aAAW,QAAQ,OAAO;AACxB,QAAI;AACF,YAAM,WAAWC,cAAa,MAAM,OAAO;AAC3C,MAAAD,MAAK,OAAO,QAAQ;AAAA,IACtB,SAAS,GAAG;AACV,mBAAa,OAAO,OAAO,KAAK;AAAA,QAC9B,SAAS;AAAA,QACT,KAAK,oCAAoC,IAAI;AAAA,MAC/C,CAAC;AACD,MAAAA,MAAK,OAAO,IAAI;AAAA,IAClB;AAAA,EACF;AACA,QAAM,cAAcA,MAAK,OAAO,KAAK;AAErC,SAAO,EAAE,QAAQ,WAAW,mBAAmB,YAAY;AAC7D;AAEA,IAAM,mBAAmB,OACvB,EAAE,OAAO,GACT,aACyB;AAEzB,QAAM,oBAAoB,gBAAgB;AAAA,IACxC,QAAQ,SAAS,OAAO;AAAA,EAC1B,CAAC;AACD,MAAI,kBAAkB,WAAW,SAAS;AACxC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO,kBAAkB;AAAA,IAC3B,CAAC;AAED,WAAO;AAAA,EACT;AAEA,aAAW,OAAO,kBAAkB,MAAM;AACxC,WAAO,OAAO,IAAI,KAAK,EAAE,EAAE,SAAS,SAAS,KAAK,IAAI,IAAI,CAAC;AAAA,EAC7D;AAEA,QAAM,gBAAgB,mBAAmB,kBAAkB,MAAM;AAGjE,QAAM,wCACJ,MAAM,oCAAoC;AAAA,IACxC,QAAQ,SAAS,OAAO;AAAA,IACxB,sBAAsB,SAAS,kBAAkB;AAAA,IACjD,SAAS,OAAO;AAAA,EAClB,CAAC;AACH,MAAI,sCAAsC,WAAW,SAAS;AAC5D,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO,sCAAsC;AAAA,IAC/C,CAAC;AAED,WAAO;AAAA,EACT;AAEA,aAAW,OAAO,sCAAsC,MAAM;AAC5D,WAAO,OAAO,IAAI,KAAK,EAAE,EAAE,SAAS,SAAS,KAAK,IAAI,IAAI,CAAC;AAAA,EAC7D;AAEA,QAAM,UAAU,WAAW,QAAQ,EAChC,OAAO,gBAAgB,EACvB,OAAO,SAAS,OAAO,WAAW,EAClC,OAAO,SAAS,OAAO,WAAW,EAClC,OAAO,SAAS,kBAAkB,WAAW,EAC7C,OAAO,KAAK,EACZ,MAAM,GAAG,EAAE;AAEd,SAAO,OAAO,MAAM;AAAA,IAClB,SAAS;AAAA,IACT,KAAK,4BAA4B,OAAO;AAAA,EAC1C,CAAC;AAED,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,MACL;AAAA,MACA,gBAAgB,sCAAsC;AAAA,MACtD,eAAe,sCAAsC;AAAA,MACrD,UAAU,sCAAsC;AAAA,MAChD,SAAS,sCAAsC;AAAA,MAC/C,QAAQ,kBAAkB;AAAA,MAC1B;AAAA,MACA,mBACE,sCAAsC;AAAA,IAC1C;AAAA,EACF;AACF;AAEA,IAAM,cAAc,OAClB,EAAE,QAAQ,eAAe,GACzB,EAAE,KAAK,MAGJ;AACH,MAAI;AACF,UAAM,UAAU,MAAM,eAAe,YAAY,IAAI;AACrD,WAAO,EAAE,QAAQ,WAAW,QAAQ;AAAA,EACtC,SAAS,QAAQ;AACf,UAAM,eAAeH,MAAK,SAAS,OAAO,QAAQ,SAAS,IAAI;AAC/D,UAAM,QAAQ,mBAAmB,cAAc,MAAe;AAC9D,WAAO,EAAE,QAAQ,SAAS,MAAM;AAAA,EAClC;AACF;;;AyB5eA,IAAM,UAAU;AAAA,EACd;AAAA,EACA;AACF;AAEO,IAAM,qBAAqB,OAAO,QAAQ,OAAO;;;ACTxD,SAAS,WAAW,qBAAqB;AACzC,OAAOK,WAAU;AAGjB,SAAS,mBAAmB;AAErB,IAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BlB,SAAS,WAAW;AAAA,EACzB;AAAA,EACA;AACF,GAGG;AACD;AAAA,IACEA,MAAK,KAAK,OAAO,QAAQ,SAAS,iBAAiB;AAAA,IACnD;AAAA,IACA;AAAA,EACF;AAEA,SAAO,OAAO,MAAM;AAAA,IAClB,SAAS;AAAA,IACT,KAAK;AAAA,EACP,CAAC;AAED,YAAU,OAAO,QAAQ,cAAc,EAAE,WAAW,KAAK,CAAC;AAC1D;AAAA,IACEA,MAAK,KAAK,OAAO,QAAQ,cAAc,gBAAgB;AAAA,IACvD,YAAY,aAAa;AAAA,IACzB;AAAA,EACF;AAEA,SAAO,OAAO,MAAM;AAAA,IAClB,SAAS;AAAA,IACT,KAAK;AAAA,EACP,CAAC;AACH;;;AC/DA,OAAO,QAAQ;AACf,SAAuD,YAAY;AAQ5D,SAAS,aAAa;AAAA,EAC3B;AAAA,EACA,OAAO;AACT,GAAwC;AACtC,QAAM,SAA4B;AAAA,IAChC,MAAM,WAAmB;AACvB,UAAI,SAAS,cAAc;AAEzB,gBAAQ,IAAI,UAAU,QAAQ,CAAC;AAC/B;AAAA,MACF;AAEA,YAAM,MAAM,KAAK,MAAM,SAAS;AAChC,YAAM,YAAY,OAAO,GAAG;AAC5B,cAAQ,IAAI,SAAS;AAGrB,UAAI,IAAI,OAAO;AACb,cAAM,UAAU,IAAI,MAAM,SAAS,IAAI,MAAM,WAAW,IAAI;AAC5D,gBAAQ,IAAI,OAAO;AACnB,YAAI,OAAO,IAAI,OAAO,SAAS;AAAU,kBAAQ,IAAI,IAAI,MAAM,IAAI;AACnE,YAAI,MAAM,QAAQ,IAAI,OAAO,IAAI;AAC/B,kBAAQ,IAAI,IAAI,MAAM,KAAK,KAAK,IAAI,CAAC;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS;AAAA,IACb;AAAA,MACE;AAAA,MACA,aAAa,EAAE,OAAO,KAAK,eAAe,aAAa;AAAA;AAAA,MAEvD,MAAM;AAAA,IACR;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM,SAAqB;AACzB,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,IACA,MAAM,SAAwC;AAC5C,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,IACA,KAAK,SAAqB;AACxB,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,IACA,KAAK,SAAqB;AACxB,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,IACA,MAAM,SAAqB;AACzB,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,IACA,MAAM,SAAqB;AACzB,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,IACA,MAAM,OAAO;AAAA,IAWb;AAAA,EACF;AACF;AAEA,IAAM,SAAS;AAAA,EACb,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,MAAM,OAAO,EAAE;AAAA,EACpD,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,IAAI,OAAO,EAAE;AAAA,EAClD,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,OAAO,OAAO,EAAE;AAAA,EACrD,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,MAAM,OAAO,EAAE;AAAA,EACpD,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,KAAK,OAAO,EAAE;AAAA,EACnD,IAAI,EAAE,OAAO,SAAS,YAAY,GAAG,KAAK,OAAO,EAAE;AACrD;AAEA,IAAM,gBAAgB,IAAI,KAAK,eAAe,QAAW;AAAA,EACvD,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AACV,CAAC;AAED,IAAM,SAAS,CAAC,QAAoB;AAClC,QAAM,OAAO,cAAc,OAAO,IAAI,KAAK,IAAI,IAAI,CAAC;AACpD,QAAM,UAAU,IAAI,OAAO,IAAI,OAAO;AAEtC,QAAM,cACJ,OAAQ,IAAI,SAAiC,EAAE,KAAK,OAAO,EAAE;AAE/D,MAAI,GAAG,kBAAkB;AACvB,UAAM,QAAQ,YAAY;AAC1B,UAAM,UAAU,IAAI,UAAU,GAAG,KAAK,IAAI,QAAQ,OAAO,IAAI,GAAG,CAAC,IAAI;AACrE,UAAM,cAAc,GAAG,MAAM,OAAO;AACpC,WAAO,GAAG,GAAG,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,OAAO,IAAI,WAAW;AAAA,EAC5D,OAAO;AACL,UAAM,QAAQ,YAAY;AAC1B,UAAM,UAAU,IAAI,UAAU,IAAI,QAAQ,OAAO,IAAI,GAAG,IAAI;AAC5D,WAAO,GAAG,IAAI,IAAI,KAAK,IAAI,OAAO,IAAI,OAAO;AAAA,EAC/C;AACF;;;ACjHA,OAAO,gBAAgB;AAEvB,IAAM,0BAA0B;AAAA,EAC9B;AAAA,EAAM;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAO;AAAA,EAAO;AAAA,EACnE;AAAA,EAAO;AAAA,EAAQ;AACjB;AAEA,IAAM,wBAAwB;AAAA,EAC5B;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACnE;AACF;AAEA,IAAM,uBAAuB;AAAA,EAC3B;AAAA,EAAI;AAAA,EAAK;AAAA,EAAO;AAAA,EAAO;AAAA,EAAQ;AAAA,EAAQ;AAAA,EAAS;AAAA,EAAS;AAAA,EAAW;AAAA,EACpE;AACF;AAEO,IAAM,iBAAN,MAAqB;AAAA,EAC1B;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAGA;AAAA,EAGA;AAAA,EAIA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EAGA;AAAA,EAGA;AAAA,EAIA;AAAA,EACA;AAAA,EAEA,mCAAsE;AAAA,EACtE,mCAA6D;AAAA,EAC7D,8BAA0D;AAAA,EAE1D,4BAA4D;AAAA,EAE5D,cAAc;AACZ,SAAK,WAAW,IAAI,WAAW,SAAS;AAExC,SAAK,gCAAgC,IAAI,WAAW,MAAM;AAAA,MACxD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,oCAAoC,IAAI,WAAW,MAAM;AAAA,MAC5D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,mCAAmC,IAAI,WAAW,MAAM;AAAA,MAC3D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,OAAO;AAAA,MAC/B,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,sCAAsC,IAAI,WAAW,MAAM;AAAA,MAC9D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,4BAA4B,IAAI,WAAW,MAAM;AAAA,MACpD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,oCAAoC,IAAI,WAAW,UAAU;AAAA,MAChE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,OAAO;AAAA,MAC/B,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,uCAAuC,IAAI,WAAW,QAAQ;AAAA,MACjE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,OAAO;AAAA,MAC/B,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,SAAK,oCAAoC,IAAI,WAAW,MAAM;AAAA,MAC5D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,SAAS;AAAA,MACtB,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,iCAAiC,IAAI,WAAW,MAAM;AAAA,MACzD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,UAAU,MAAM;AAAA,MACxC,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,kCAAkC,IAAI,WAAW,MAAM;AAAA,MAC1D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,UAAU,MAAM;AAAA,MACxC,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,qCAAqC,IAAI,WAAW,MAAM;AAAA,MAC7D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,UAAU,MAAM;AAAA,MACxC,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,SAAK,+BAA+B,IAAI,WAAW,MAAM;AAAA,MACvD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,SAAS;AAAA,MACtB,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,sCAAsC,IAAI,WAAW,MAAM;AAAA,MAC9D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,SAAS;AAAA,MACtB,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,yCAAyC,IAAI,WAAW,MAAM;AAAA,MACjE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,SAAS;AAAA,MACtB,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,8BAA8B,IAAI,WAAW,QAAQ;AAAA,MACxD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,SAAS;AAAA,MACtB,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,SAAK,kCAAkC,IAAI,WAAW,UAAU;AAAA,MAC9D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,QAAQ;AAAA,MAChC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,qCAAqC,IAAI,WAAW,QAAQ;AAAA,MAC/D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,QAAQ;AAAA,MAChC,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,SAAK,0BAA0B,IAAI,WAAW,MAAM;AAAA,MAClD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,qCAAqC,IAAI,WAAW,MAAM;AAAA,MAC7D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,UAAU,MAAM;AAAA,MAC7B,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,yCAAyC,IAAI,WAAW,UAAU;AAAA,MACrE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,UAAU,QAAQ,QAAQ;AAAA,MACvC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,wCAAwC,IAAI,WAAW,UAAU;AAAA,MACpE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,UAAU,QAAQ,QAAQ;AAAA,MACvC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,yCAAyC,IAAI,WAAW,UAAU;AAAA,MACrE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,UAAU,QAAQ,QAAQ;AAAA,MACvC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,SAAK,8BAA8B,IAAI,WAAW,UAAU;AAAA,MAC1D,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,QAAQ;AAAA,MAChC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AACD,SAAK,yBAAyB,IAAI,WAAW,UAAU;AAAA,MACrD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,WAAW,QAAQ;AAAA,MAChC,SAAS;AAAA,MACT,WAAW,CAAC,KAAK,QAAQ;AAAA,IAC3B,CAAC;AAED,eAAW,sBAAsB,EAAE,UAAU,KAAK,SAAS,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,aAAa;AACjB,WAAO,MAAM,KAAK,SAAS,QAAQ;AAAA,EACrC;AAAA,EAEA,eAAe;AACb,SAAK,SAAS,aAAa;AAAA,EAC7B;AACF;AAEA,eAAsB,0BAA0B,SAAyB;AAEvE,QAAM,wBACH,MAAM,QAAQ,kCAAkC,IAAI,GAAG,SAAS,CAAC,GAC9D,SAAS,KAAK,IAAI;AAGxB,QAAM,qBAAqB,CACzB,WAEA,OAAO,OAKJ,CAAC,KAAK,QAAQ;AACf,UAAM,KAAK,GAAG,IAAI,OAAO,MAAM,IAAI,IAAI,OAAO,OAAO,IACnD,IAAI,OAAO,SAAS,UAAU,UAAU,UAC1C;AAEA,QAAI,IAAI,EAAE,MAAM,QAAW;AACzB,UAAI,EAAE,IAAI;AAAA,QACR,QAAQ;AAAA,UACN,QAAQ,IAAI,OAAO;AAAA,UACnB,SAAS,IAAI,OAAO;AAAA,QACtB;AAAA,QACA,OAAO,IAAI;AAAA,MACb;AAAA,IACF,OAAO;AAIL,UAAI,EAAE,EAAE,QAAQ,KAAK,IAAI,IAAI,EAAE,EAAE,OAAO,IAAI,KAAK;AAAA,IACnD;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAEP,QAAM,qBAAqB,MAAM,QAAQ,gCACtC,IAAI,EACJ,KAAK,CAAC,EAAE,OAAO,MAAM,mBAAmB,MAAM,CAAC;AAClD,QAAM,oBAAoB,MAAM,QAAQ,+BACrC,IAAI,EACJ,KAAK,CAAC,EAAE,OAAO,MAAM,mBAAmB,MAAM,CAAC;AAClD,QAAM,wBAAwB,MAAM,QAAQ,mCACzC,IAAI,EACJ,KAAK,CAAC,EAAE,OAAO,MAAM,mBAAmB,MAAM,CAAC;AAElD,QAAM,UAAU,OAAO,QAAQ,iBAAiB,EAAE;AAAA,IAChD,CAAC;AAAA,MACC;AAAA,MACA;AAAA,QACE,QAAQ,EAAE,QAAQ,QAAQ;AAAA,QAC1B,OAAOC;AAAA,MACT;AAAA,IACF,MAAM;AACJ,YAAMC,gBAAe,mBAAmB,EAAE,GAAG;AAC7C,YAAMC,mBAAkB,sBAAsB,EAAE,GAAG,SAAS;AAG5D,UAAID,kBAAiB,QAAW;AAC9B,eAAO;AAAA,UACL,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,aAAAD;AAAA,UACA,iBAAAE;AAAA,QACF;AAAA,MACF;AAEA,YAAMC,aAAYD,mBAAkBD,iBAAgBD;AAEpD,YAAM,UAAU,KAAK,IAAI,IAAI;AAC7B,YAAM,QAAQ,WAAWE,oBAAmBF,eAAcC;AAE1D,YAAM,MAAMC,oBAAmB,IAAI,QAAQ,UAAU;AAErD,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,aAAAF;AAAA,QACA,cAAAC;AAAA,QACA,iBAAAC;AAAA,QACA,UAAAC;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,aAAa,CAAC;AACjE,QAAM,eAAe,QAAQ,OAAO,CAAC,GAAG,MAAM,KAAK,EAAE,gBAAgB,IAAI,CAAC;AAC1E,QAAM,kBAAkB,QAAQ;AAAA,IAC9B,CAAC,GAAG,MAAM,KAAK,EAAE,mBAAmB;AAAA,IACpC;AAAA,EACF;AACA,QAAM,WACJ,gBAAgB,IAAI,KAAK,kBAAkB,gBAAgB;AAE7D,SAAO;AAAA,IACL,SAAS,EAAE,aAAa,cAAc,iBAAiB,SAAS;AAAA,IAChE;AAAA,EACF;AACF;AAEA,eAAsB,oBAAoB,SAAyB;AACjE,QAAM,kBAAkB,MAAM,QAAQ,0BAA0B,IAAI,GACjE,OAAO,CAAC,GAAG;AACd,QAAM,WAAW,mBAAmB;AAEpC,QAAM,gBACH,MAAM,QAAQ,8BAA8B,IAAI,GAAG,OAAO,CAAC,GAAG,SAAS;AAC1E,QAAM,oBACH,MAAM,QAAQ,kCAAkC,IAAI,GAAG,OAAO,CAAC,GAAG,SACnE;AACF,QAAM,wBACH,MAAM,QAAQ,oCAAoC,IAAI,GAAG,OAAO,CAAC,EAAE,SACpE;AAEF,QAAM,WAAW,iBAAiB,IAAI,IAAI,mBAAmB;AAE7D,QAAM,iCACJ,MAAM,QAAQ,iCAAiC,IAAI,GACnD;AACF,QAAM,+BACJ,MAAM,QAAQ,qCAAqC,IAAI,GACvD;AACF,QAAM,kCACJ,MAAM,QAAQ,kCAAkC,IAAI,GACpD;AAEF,QAAM,sBAA8D,CAAC;AACrE,QAAM,wBAAgE,CAAC;AACvE,aAAW,KAAK,gCAAgC;AAC9C,QAAI,EAAE,eAAe;AACnB,OAAC,oBAAoB,EAAE,OAAO,KAAM,MAAM,CAAC,GAAG,EAAE,OAAO,OAAQ,IAC7D,EAAE;AACN,QAAI,EAAE,eAAe;AACnB,OAAC,sBAAsB,EAAE,OAAO,KAAM,MAAM,CAAC,GAAG,EAAE,OAAO,OAAQ,IAC/D,EAAE;AAAA,EACR;AAEA,QAAM,SAAS,8BAA8B,IAAI,CAAC,MAAM;AACtD,UAAM,YAAY,EAAE,OAAO;AAC3B,UAAM,cAAc,EAAE,OAAO;AAC7B,UAAM,QAAQ,EAAE;AAEhB,UAAM,cAAc,oBAAoB,SAAS,IAAI,WAAW,KAAK;AACrE,UAAM,gBAAgB,sBAAsB,SAAS,IAAI,WAAW,KAAK;AACzE,UAAM,kBACJ,kBAAkB,IAAI,IAAI,cAAc;AAE1C,UAAM,aACJ,4BAA4B;AAAA,MAC1B,CAAC,MAAM,EAAE,OAAO,UAAU,aAAa,EAAE,OAAO,YAAY;AAAA,IAC9D,GAAG,SAAS;AAEd,WAAO,EAAE,WAAW,aAAa,OAAO,iBAAiB,WAAW;AAAA,EACtE,CAAC;AAED,QAAM,cAAc,OAAO,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,OAAO,CAAC;AAE1D,SAAO;AAAA,IACL;AAAA,IACA,SAAS;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;;;AC5ZA,OAAOC,WAAU;AAiCV,IAAM,eAAe,CAAC,EAAE,WAAW,MAAkC;AAC1E,MAAI;AACJ,MAAI,WAAW,SAAS,QAAW;AACjC,cAAUA,MAAK,QAAQ,WAAW,IAAI;AAAA,EACxC,OAAO;AACL,cAAUA,MAAK,QAAQ,GAAG;AAAA,EAC5B;AAEA,MAAI;AACJ,MAAI,WAAW,UAAU,MAAM;AAC7B,eAAW;AAAA,EACb,WAAW,WAAW,UAAU,MAAM;AACpC,eAAW;AAAA,EACb,WACE,QAAQ,IAAI,qBAAqB,UACjC,CAAC,UAAU,SAAS,SAAS,QAAQ,QAAQ,SAAS,OAAO,EAAE;AAAA,IAC7D,QAAQ,IAAI;AAAA,EACd,GACA;AACA,eAAW,QAAQ,IAAI;AAAA,EACzB,OAAO;AACL,eAAW;AAAA,EACb;AAEA,QAAM,OACJ,QAAQ,IAAI,SAAS,SACjB,OAAO,QAAQ,IAAI,IAAI,IACvB,WAAW,SAAS,SAClB,WAAW,OACX;AAER,QAAM,WAAW,WAAW;AAE5B,SAAO;AAAA,IACL,SAAS,WAAW;AAAA,IAEpB;AAAA,IACA,YAAYA,MAAK,KAAK,SAAS,WAAW,MAAM;AAAA,IAChD,YAAYA,MAAK,KAAK,SAAS,kBAAkB;AAAA,IACjD,QAAQA,MAAK,KAAK,SAAS,KAAK;AAAA,IAChC,cAAcA,MAAK,KAAK,SAAS,WAAW;AAAA,IAC5C,WAAWA,MAAK,KAAK,SAAS,SAAS;AAAA,IACvC,QAAQA,MAAK,KAAK,SAAS,WAAW,MAAM;AAAA,IAE5C;AAAA,IACA;AAAA,IACA,wBAAwB;AAAA;AAAA;AAAA;AAAA,IAIxB,2BAA2B;AAAA,IAC3B,0BAA0B;AAAA,IAC1B,4BAA4B;AAAA,IAE5B,cAAc;AAAA,IACd,mBAAmB,QAAQ,QAAQ,IAAI,yBAAyB;AAAA,IAChE,oBAAoB;AAAA,IAEpB;AAAA,IAEA,2BAA2B,KAAK;AAAA,IAChC,0BAA0B,KAAK;AAAA,EACjC;AACF;;;AChGA,SAAS,YAAY;AACrB,SAAS,cAAAC,aAAY,mBAAmB;AACxC,SAAS,YAAY,gBAAAC,qBAAoB;AACzC,OAAO,QAAQ;AACf,OAAOC,WAAU;AACjB,SAAS,iBAAiB;;;ACDnB,SAAS,aAAa;AAC3B,QAAMC,SAAQ,QAAQ,OAAO;AAC7B,SAAO,MAAM,WAAW,QAAQ,OAAOA,MAAK,CAAC;AAC/C;AAMO,SAAS,WAAW,MAAwB;AACjD,SAAO,KAAK,MAAM,KAAK,CAAC,IAAI,MAAO,KAAK,CAAC,IAAI,GAAK,IAAI;AACxD;;;ACXA,eAAsB,KAAK,cAAsB;AAC/C,SAAO,IAAI,QAAc,CAAC,QAAQ,WAAW,KAAK,YAAY,CAAC;AACjE;;;AFMA,OAAO,UAAU;AACjB,SAAkB,QAAQ,qBAAqB;AAG/C,IAAM,wBAAwB;AAgDvB,SAAS,gBAAgB;AAAA,EAC9B;AAAA,EACA;AACF,GAAyC;AACvC,MAAI,QAAQ,mBAAmB;AAC7B,WAAO,EAAE,QAAQ,CAAC,WAA2B;AAAA,IAAC,GAAG,MAAM,YAAY;AAAA,IAAC,EAAE;AAAA,EACxE;AAEA,QAAM,OAAO,IAAI,KAAiB;AAAA,IAChC,aAAa;AAAA,IACb,KAAK,QAAQ;AAAA,EACf,CAAC;AAED,MAAI,KAAK,IAAI,YAAY,MAAM,QAAW;AACxC,SAAK,IAAI,cAAc,KAAK,IAAI,EAAE,SAAS,CAAC;AAC5C,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAAA,EACH;AAEA,QAAM,YAAY,YAAY,CAAC,EAAE,SAAS,KAAK;AAE/C,MAAI,cAAc,KAAK,IAAI,aAAa;AACxC,MAAI,gBAAgB,QAAW;AAC7B,kBAAc,YAAY,CAAC,EAAE,SAAS,KAAK;AAC3C,SAAK,IAAI,eAAe,WAAW;AAAA,EACrC;AAGA,MAAI,YAAY,SAAS;AAAI,kBAAc,YAAY,MAAM,GAAG,EAAE;AAElE,MAAI,OAAO,KAAK,IAAI,MAAM;AAC1B,MAAI,SAAS,QAAW;AACtB,WAAO,YAAY,CAAC,EAAE,SAAS,KAAK;AACpC,SAAK,IAAI,QAAQ,IAAI;AAAA,EACvB;AAGA,QAAM,aAAa,CAAC,UAAkB;AACpC,UAAMC,QAAOC,YAAW,QAAQ;AAChC,IAAAD,MAAK,OAAO,IAAI;AAChB,IAAAA,MAAK,OAAO,KAAK;AACjB,WAAOA,MAAK,OAAO,KAAK,EAAE,MAAM,GAAG,EAAE;AAAA,EACvC;AAEA,QAAM,eAAe,YAAY;AAE/B,UAAM,eAAe,MAAM,gBAAgB;AAC3C,UAAM,eAAe,gBAAgB,QAAQ,IAAI;AACjD,UAAM,YAAY,WAAW,YAAY;AAEzC,UAAM,EAAE,gBAAgB,sBAAsB,IAAI,MAAM,kBAAkB;AAG1E,UAAME,eAAc,eAAe,QAAQ,OAAO;AAClD,UAAM,oBACJA,cAAa,eAAe,cAAc,KAAK;AACjD,UAAM,cAAcA,cAAa,cAAc,QAAQ;AAGvD,UAAM,aAAa,sBAAsB;AAEzC,UAAM,OAAO,GAAG,KAAK;AAErB,WAAO;AAAA,MACL,QAAQ;AAAA,QACN,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,aAAa;AAAA,MACf;AAAA,MACA,SAAS;AAAA,QACP,qBAAqB;AAAA,QACrB,cAAc;AAAA,QACd,iBAAiB;AAAA,QACjB,yBAAyB;AAAA,QACzB,cAAc,QAAQ,SAAS;AAAA,QAC/B,iBAAiB,GAAG,SAAS;AAAA,QAC7B,gBAAgB,GAAG,QAAQ;AAAA,QAC3B,qBAAqB,GAAG,KAAK;AAAA,QAC7B,WAAW,KAAK;AAAA,QAChB,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,EAAE,QAAQ;AAAA,QAC7C,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,EAAE,QAAQ;AAAA,QAC7C,oBAAoB,GAAG,SAAS;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,MAAI,UAAgE;AACpE,QAAM,iBAAiB,aAAa;AAEpC,QAAM,aAAa,IAAI,gBAAgB;AACvC,MAAI,WAAW;AAEf,QAAM,QAAQ,YAAY;AAAA,IACxB,cAAc;AAAA,IACd,aAAa;AAAA,IACb,QAAQ,OAAO,UAA0B;AACvC,YAAM,WAAW,WAAW;AAC5B,UAAI;AACF,YAAI,YAAY;AAAW,oBAAU,MAAM;AAE3C,cAAM,aACJ,MAAM,SAAS,4BACX,EAAE,GAAG,MAAM,YAAY,GAAG,QAAQ,QAAQ,GAAG,QAAQ,QAAQ,IAC7D,EAAE,GAAG,MAAM,YAAY,GAAG,QAAQ,OAAO;AAE/C,cAAM,OAAO,KAAK,UAAU;AAAA,UAC1B,YAAY;AAAA,UACZ,OAAO,MAAM;AAAA,UACb;AAAA,QACF,CAAC;AAED,cAAM,MAAM,QAAQ,cAAc;AAAA,UAChC,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,UAC9C;AAAA,UACA,QAAQ,WAAW;AAAA,QACrB,CAAC;AACD,eAAO,MAAM;AAAA,UACX,SAAS;AAAA,UACT,KAAK,SAAS,MAAM,IAAI,cAAc,SAAS,CAAC;AAAA,QAClD,CAAC;AAAA,MACH,SAAS,QAAQ;AACf,cAAM,QAAQ;AACd,eAAO,MAAM;AAAA,UACX,SAAS;AAAA,UACT,KAAK,mBACH,MAAM,IACR,iBAAiB,SAAS,CAAC,oBAAoB,MAAM,OAAO;AAAA,QAC9D,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,SAAS,CAAC,UAA0B;AACxC,QAAI;AAAU;AACd,UAAM,IAAI,KAAK;AAAA,EACjB;AAEA,QAAM,oBAAoB,YAAY,MAAM;AAC1C,WAAO;AAAA,MACL,MAAM;AAAA,MACN,YAAY,EAAE,kBAAkB,QAAQ,OAAO,EAAE;AAAA,IACnD,CAAC;AAAA,EACH,GAAG,qBAAqB;AAExB,QAAMC,QAAO,YAAY;AACvB,kBAAc,iBAAiB;AAC/B,eAAW;AAEX,UAAM,MAAM;AAEZ,UAAM,QAAQ,KAAK,CAAC,MAAM,OAAO,GAAG,KAAK,GAAK,CAAC,CAAC;AAAA,EAClD;AAEA,SAAO,EAAE,QAAQ,MAAAA,MAAK;AACxB;AAEA,eAAe,oBAAoB;AACjC,MAAI,iBAAqB;AACzB,MAAI,wBAAwB;AAC5B,MAAI;AACF,qBAAiB,MAAM,OAAO;AAC9B,4BAAwB,MAAM,cAAc,cAAc;AAAA,EAC5D,SAAS,GAAG;AAAA,EAAC;AACb,SAAO,EAAE,gBAAgB,sBAAsB;AACjD;AAEA,IAAM,QAAQ,UAAU,IAAI;AAE5B,eAAe,kBAAkB;AAC/B,QAAM,SAAS,MAAM,MAAM,8CAA8C;AAAA,IACvE,SAAS;AAAA,IACT,aAAa;AAAA,EACf,CAAC,EAAE,MAAM,MAAM,MAAS;AAExB,SAAO,QAAQ,OAAO,KAAK;AAC7B;AASA,SAAS,eAAe,SAAiB;AACvC,MAAI;AACF,UAAM,WAAWC,MAAK,KAAK,SAAS,cAAc;AAClD,UAAM,UAAUA,MAAK,KAAK,QAAQ,IAAI,GAAG,cAAc;AAEvD,UAAMC,mBAAkB,WAAW,QAAQ,IACvC,WACA,WAAW,OAAO,IAChB,UACA;AACN,QAAIA,qBAAoB;AAAW,aAAO;AAE1C,UAAM,oBAAoBC,cAAaD,kBAAiB,MAAM;AAC9D,UAAMH,eAAc,KAAK,MAAM,iBAAiB;AAEhD,WAAOA;AAAA,EACT,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEO,SAAS,aAAa,OAAc;AACzC,QAAM,cAAc,OAAO,KAAK,UAAU,MAAM,MAAM,CAAC,EAAE;AACzD,QAAM,0BAA0B,OAAO,OAAO,MAAM,iBAAiB,EAAE;AAAA,IACrE,CAAC,KAAK,MAAM,MAAM,OAAO,KAAK,CAAC,EAAE;AAAA,IACjC;AAAA,EACF;AAEA,SAAO;AAAA,IACL,eAAe,MAAM,eAAe;AAAA,IACpC,gBAAgB,MAAM,QAAQ;AAAA,IAC9B,eAAe,MAAM,SAAS;AAAA,IAC9B;AAAA,IACA;AAAA,EACF;AACF;;;AG9RA,OAAOK,SAAQ;AACf,OAAO,cAAc;;;ACDd,IAAM,YAAN,MAAM,mBAAkB,MAAM;AAAA,EAC1B,OAAO;AAAA,EAEhB,OAAiB,CAAC;AAAA,EAElB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,WAAU,SAAS;AAAA,EACjD;AACF;AAEO,SAAS,aAAa,KAAU;AACrC,MAAI,eAAe;AAAW,WAAO;AACrC,MAAI,eAAe;AAAO,WAAO,IAAI,UAAU,IAAI,OAAO;AAC1D,MAAI,OAAO,KAAK,YAAY;AAAU,WAAO,IAAI,UAAU,IAAI,OAAO;AACtE,MAAI,OAAO,QAAQ;AAAU,WAAO,IAAI,UAAU,GAAG;AACrD,SAAO,IAAI,UAAU,eAAe;AACtC;AAEO,IAAM,oBAAN,MAAM,2BAA0B,UAAU;AAAA,EACtC,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,mBAAkB,SAAS;AAAA,EACzD;AACF;AAEO,IAAM,iBAAN,MAAM,wBAAuB,UAAU;AAAA,EACnC,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,gBAAe,SAAS;AAAA,EACtD;AACF;AAEO,IAAM,aAAN,MAAM,oBAAmB,kBAAkB;AAAA,EACvC,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,YAAW,SAAS;AAAA,EAClD;AACF;AAEO,IAAM,wBAAN,MAAM,+BAA8B,kBAAkB;AAAA,EAClD,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,uBAAsB,SAAS;AAAA,EAC7D;AACF;AAEO,IAAM,yBAAN,MAAM,gCAA+B,kBAAkB;AAAA,EACnD,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,wBAAuB,SAAS;AAAA,EAC9D;AACF;AAEO,IAAM,sBAAN,MAAM,6BAA4B,kBAAkB;AAAA,EAChD,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,qBAAoB,SAAS;AAAA,EAC3D;AACF;AAEO,IAAM,uBAAN,MAAM,8BAA6B,kBAAkB;AAAA,EACjD,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,sBAAqB,SAAS;AAAA,EAC5D;AACF;AAEO,IAAM,2BAAN,MAAM,kCAAiC,kBAAkB;AAAA,EACrD,OAAO;AAAA,EAEhB,YAAY,SAA8B;AACxC,UAAM,OAAO;AACb,WAAO,eAAe,MAAM,0BAAyB,SAAS;AAAA,EAChE;AACF;;;ADpFA,IAAM,2BAA2B;AAK1B,SAAS,cAAc;AAAA,EAC5B;AAAA,EACA;AACF,GAGG;AACD,MAAI,iBAAiB;AAErB,QAAM,WAAW,OAAO;AAAA,IACtB;AAAA,IACA;AAAA,EACF,MAAuC;AACrC,QAAI;AAAgB;AACpB,qBAAiB;AACjB,eAAW,YAAY;AACrB,aAAO,OAAO,MAAM;AAAA,QAClB,SAAS;AAAA,QACT,KAAK;AAAA,MACP,CAAC;AACD,YAAM,OAAO,OAAO,KAAK;AACzB,cAAQ,KAAK,CAAC;AAAA,IAChB,GAAG,wBAAwB;AAE3B,QAAI,WAAW,QAAW;AACxB,aAAO,OAAO,KAAK;AAAA,QACjB,SAAS;AAAA,QACT,KAAK,GAAG,MAAM;AAAA,MAChB,CAAC;AAAA,IACH;AACA,WAAO,UAAU,OAAO;AAAA,MACtB,MAAM;AAAA,MACN,YAAY,EAAE,kBAAkB,QAAQ,OAAO,EAAE;AAAA,IACnD,CAAC;AAED,UAAM,QAAQ;AAEd,UAAM,QAAQ,SAAS,IAAI,SAAS;AACpC,WAAO,OAAO,KAAK,EAAE;AAAA,MACnB,SAAS;AAAA,MACT,KAAK,sDAAsD,IAAI;AAAA,IACjE,CAAC;AAED,UAAM,OAAO,OAAO,KAAK;AACzB,YAAQ,KAAK,IAAI;AAAA,EACnB;AAEA,MAAIC,IAAG,SAAS,MAAM,SAAS;AAC7B,UAAM,oBAAoB,SAAS,gBAAgB;AAAA,MACjD,OAAO,QAAQ;AAAA,MACf,QAAQ,QAAQ;AAAA,IAClB,CAAC;AACD,sBAAkB;AAAA,MAAG;AAAA,MAAU,MAC7B,SAAS,EAAE,QAAQ,mBAAmB,MAAM,EAAE,CAAC;AAAA,IACjD;AAAA,EACF;AAEA,UAAQ,GAAG,UAAU,MAAM,SAAS,EAAE,QAAQ,mBAAmB,MAAM,EAAE,CAAC,CAAC;AAC3E,UAAQ;AAAA,IAAG;AAAA,IAAW,MACpB,SAAS,EAAE,QAAQ,oBAAoB,MAAM,EAAE,CAAC;AAAA,EAClD;AACA,UAAQ;AAAA,IAAG;AAAA,IAAW,MACpB,SAAS,EAAE,QAAQ,oBAAoB,MAAM,EAAE,CAAC;AAAA,EAClD;AAEA,UAAQ,GAAG,qBAAqB,CAAC,UAAiB;AAChD,QAAI,iBAAiB;AAAgB;AACrC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK;AAAA,MACL;AAAA,IACF,CAAC;AACD,aAAS,EAAE,QAAQ,8BAA8B,MAAM,EAAE,CAAC;AAAA,EAC5D,CAAC;AACD,UAAQ,GAAG,sBAAsB,CAAC,UAAiB;AACjD,QAAI,iBAAiB;AAAgB;AACrC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK;AAAA,MACL;AAAA,IACF,CAAC;AACD,aAAS,EAAE,QAAQ,+BAA+B,MAAM,EAAE,CAAC;AAAA,EAC7D,CAAC;AAED,SAAO;AACT;;;AEtFA,eAAsB,QAAQ,EAAE,WAAW,GAA+B;AACxE,QAAM,UAAU,aAAa,EAAE,WAAW,CAAC;AAE3C,QAAM,SAAS,aAAa,EAAE,OAAO,QAAQ,SAAS,CAAC;AAEvD,QAAM,CAAC,OAAO,OAAO,MAAM,IAAI,QAAQ,SAAS,KAAK,MAAM,GAAG,EAAE,IAAI,MAAM;AAC1E,MAAI,QAAQ,MAAO,UAAU,MAAM,QAAQ,IAAK;AAC9C,WAAO,MAAM;AAAA,MACX,SAAS;AAAA,MACT,KAAK,uDAAuD,KAAK,IAAI,KAAK;AAAA,IAC5E,CAAC;AACD,UAAM,OAAO,KAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,UAAU,IAAI,eAAe;AACnC,QAAM,YAAY,gBAAgB,EAAE,SAAS,OAAO,CAAC;AACrD,QAAM,SAAS,EAAE,SAAS,QAAQ,SAAS,UAAU;AAErD,QAAM,eAAe,MAAM,mBAAmB,EAAE,OAAO,CAAC;AAExD,QAAM,UAAU,YAAY;AAC1B,UAAM,aAAa,KAAK;AACxB,UAAM,UAAU,KAAK;AAAA,EACvB;AAEA,QAAM,WAAW,cAAc,EAAE,QAAQ,QAAQ,CAAC;AAElD,QAAM,cAAc,MAAM,aAAa,MAAM,EAAE,OAAO,MAAM,CAAC;AAE7D,MAAI,YAAY,WAAW,SAAS;AAClC,WAAO,MAAM;AAAA,MACX,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO,YAAY;AAAA,IACrB,CAAC;AACD,UAAM,SAAS,EAAE,QAAQ,uBAAuB,MAAM,EAAE,CAAC;AACzD;AAAA,EACF;AAEA,YAAU,OAAO;AAAA,IACf,MAAM;AAAA,IACN,YAAY,EAAE,aAAa,UAAU;AAAA,EACvC,CAAC;AAED,aAAW,EAAE,QAAQ,eAAe,YAAY,MAAM,cAAc,CAAC;AAErE,SAAO,KAAK,EAAE,SAAS,WAAW,KAAK,wBAAwB,CAAC;AAChE,SAAO,KAAK,EAAE,SAAS,WAAW,KAAK,uBAAuB,CAAC;AAE/D,QAAM,SAAS,EAAE,QAAQ,WAAW,MAAM,EAAE,CAAC;AAC/C;;;AC5DA,SAAS,cAAAC,mBAAkB;AAC3B,OAAOC,WAAU;;;ACDV,IAAM,YAAY,CAAC,OAAe;AAEvC,MAAI,KAAK;AAAM,WAAO,GAAG,KAAK,MAAM,EAAE,CAAC;AACvC,QAAM,UAAU,KAAK,MAAM,KAAK,GAAI;AAEpC,QAAM,IAAI,KAAK,MAAM,UAAU,IAAI;AACnC,QAAM,IAAI,KAAK,OAAO,UAAU,IAAI,QAAQ,EAAE;AAC9C,QAAM,IAAI,UAAU,IAAI,OAAO,IAAI;AAEnC,QAAM,OAAO,IAAI,IAAI,GAAG,CAAC,OAAO;AAChC,QAAM,OAAO,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC,OAAO;AACzC,QAAM,OAAO,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC,MAAM;AAExC,SAAO,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;AAC9B;AAEO,IAAM,mBAAmB,CAAC,cAAsB;AACrD,QAAM,UAAU,KAAK,MAAM,YAAY,GAAI,IAAI;AAC/C,SAAO,OAAO,UAAU,OAAO,KAAK,UAAU,MAC1C,GAAG,OAAO,QACV,GAAG,OAAO;AAChB;;;ACpBA,SAAS,OAAAC,MAAK,QAAAC,OAAM,UAAU,iBAAiB;AAC/C,OAAOC,YAAW;;;ACFlB,SAAS,YAAY;AACrB,OAAO,WAAW;AAEX,IAAM,cAAc,CAAC,EAAE,UAAU,GAAG,MAAM,IAAI,QAAQ,GAAG,MAAM;AACpE,QAAM,WAAW,SAAS,QAAQ,OAAO,WAAW;AAEpD,QAAM,WAAW,UAAU;AAC3B,QAAM,QAAQ,KAAK,IAAI,KAAK,MAAM,WAAW,QAAQ,GAAG,QAAQ;AAEhE,SACE,oCAAC,YACC,oCAAC,YAAM,SAAI,OAAO,KAAK,CAAE,GACzB,oCAAC,YAAM,SAAI,OAAO,WAAW,KAAK,CAAE,CACtC;AAEJ;;;ACfA,SAAS,KAAK,QAAAC,aAAY;AAC1B,OAAOC,YAAW;AAElB,IAAM,mBAAmB;AAElB,SAAS,MAA2C,OAQxD;AACD,QAAM,EAAE,SAAS,KAAK,IAAI;AAE1B,QAAM,gBAAgB,KAAK;AAAA,IAAI,CAAC,QAC9B,QAAQ;AAAA,MACN,CAAC,KAAK,YAAY;AAAA,QAChB,GAAG;AAAA,QACH,CAAC,OAAO,IAAI,SAAS,CAAC,GAAG,OAAO,SAC5B,OAAO,OAAO,IAAI,OAAO,GAAG,GAAG,GAAG,IAClC,IAAI,OAAO,GAAG;AAAA,MACpB;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,eAAe,QAAQ,IAAI,CAAC,WAAW;AAC3C,QAAI,WAAW,KAAK;AAAA,MAClB,GAAG,cAAc;AAAA,QAAI,CAAC,QACpB,IAAI,OAAO,GAAG,MAAM,SAAY,IAAI,OAAO,GAAG,EAAE,SAAS,EAAE,SAAS;AAAA,MACtE;AAAA,MACA,OAAO,MAAM;AAAA,IACf;AACA,eAAW,KAAK,IAAI,UAAU,gBAAgB;AAC9C,WAAO;AAAA,EACT,CAAC;AAED,SACE,gBAAAA,OAAA,cAAC,OAAI,eAAc,YAEjB,gBAAAA,OAAA,cAAC,OAAI,eAAc,OAAM,KAAI,WAC1B,QAAQ,IAAI,CAAC,EAAE,OAAO,MAAM,GAAG,UAC9B,gBAAAA,OAAA,cAACA,OAAM,UAAN,EAAe,KAAK,SAAS,KAAK,MACjC,gBAAAA,OAAA,cAACD,OAAA,MAAK,QAAC,GACP,gBAAAC,OAAA;AAAA,IAAC;AAAA;AAAA,MACC,OAAO,aAAa,KAAK;AAAA,MACzB,gBAAgB,UAAU,SAAS,eAAe;AAAA,MAClD,SAAS;AAAA;AAAA,IAET,gBAAAA,OAAA,cAACD,OAAA,EAAK,MAAI,MAAC,MAAK,kBACb,KACH;AAAA,EACF,CACF,CACD,GACD,gBAAAC,OAAA,cAACD,OAAA,MAAK,QAAC,CACT,GAGA,gBAAAC,OAAA,cAAC,OAAI,eAAc,OAAM,KAAI,YAC3B,gBAAAA,OAAA,cAACD,OAAA,MAAK,QAAC,GACN,aAAa,IAAI,CAAC,OAAO,UACxB,gBAAAC,OAAA,cAACD,OAAA,EAAK,KAAK,aAAa,KAAK,MAC1B,SAAI,OAAO,QAAQ,CAAC,GACpB,QAAQ,QAAQ,SAAS,IAAI,WAAM,QACtC,CACD,CACH,GAGC,cAAc,IAAI,CAAC,KAAK,aACvB,gBAAAC,OAAA,cAAC,OAAI,eAAc,OAAM,KAAK,OAAO,QAAQ,MAC1C,QAAQ,IAAI,CAAC,EAAE,KAAK,MAAM,GAAG,UAC5B,gBAAAA,OAAA,cAACA,OAAM,UAAN,EAAe,KAAK,QAAQ,QAAQ,IAAI,KAAK,MAC5C,gBAAAA,OAAA,cAACD,OAAA,MAAK,QAAC,GACP,gBAAAC,OAAA;AAAA,IAAC;AAAA;AAAA,MACC,OAAO,aAAa,KAAK;AAAA,MACzB,gBAAgB,UAAU,SAAS,eAAe;AAAA,MAClD,SAAS;AAAA;AAAA,IAET,gBAAAA,OAAA,cAACD,OAAA,EAAK,MAAK,kBAAgB,IAAI,GAAG,CAAE;AAAA,EACtC,CACF,CACD,GACD,gBAAAC,OAAA,cAACD,OAAA,MAAK,QAAC,CACT,CACD,CACH;AAEJ;AAEA,IAAO,gBAAQ;;;AF1CR,IAAM,eAAe,MAAM;AAChC,QAAM,KAAc;AAAA,IAClB,YAAY;AAAA,MACV,SAAS;AAAA,QACP,aAAa;AAAA,QACb,cAAc;AAAA,QACd,iBAAiB;AAAA,QACjB,UAAU;AAAA,MACZ;AAAA,MACA,SAAS,CAAC;AAAA,IACZ;AAAA,IAEA,sBAAsB,CAAC;AAAA,IAEvB,UAAU;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,QACP,kBAAkB;AAAA,QAClB,cAAc;AAAA,QACd,UAAU;AAAA,QACV,sBAAsB;AAAA,QACtB,aAAa;AAAA,MACf;AAAA,MACA,QAAQ,CAAC;AAAA,IACX;AAAA,IAEA,MAAM;AAAA,EACR;AAEA,SAAO;AACT;AAEA,IAAM,MAAM,CAAC,OAAgB;AAC3B,QAAM,EAAE,YAAY,UAAU,KAAK,IAAI;AAEvC,MAAI,SAAS,UAAU;AACrB,WACE,gBAAAE,OAAA,cAACC,MAAA,EAAI,eAAc,YACjB,gBAAAD,OAAA,cAACE,OAAA,MAAK,GAAC,GAEP,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,UAAO,+DAEnB,CACF;AAAA,EAEJ;AAEA,MAAI;AACJ,MAAI,WAAW,QAAQ,aAAa,GAAG;AACrC,wBACE,gBAAAF,OAAA,cAAAA,OAAA,gBACE,gBAAAA,OAAA,cAACE,OAAA,EAAK,MAAM,QAAM,iBAAe,GACjC,gBAAAF,OAAA,cAACE,OAAA,MAAK,qBAAmB,GACzB,gBAAAF,OAAA,cAACE,OAAA,MAAK,GAAC,CACT;AAAA,EAEJ,WAAW,WAAW,QAAQ,aAAa,GAAG;AAC5C,wBACE,gBAAAF,OAAA,cAAAA,OAAA,gBACE,gBAAAA,OAAA,cAACE,OAAA,MACC,gBAAAF,OAAA,cAACE,OAAA,EAAK,MAAM,QAAM,kBAAgB,GAAO,KACzC,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,iBAAc,MAAI,GAAO,GACvC,GACA,gBAAAF,OAAA,cAACE,OAAA,MAAK,GAAC,CACT;AAAA,EAEJ,OAAO;AACL,wBACE,gBAAAF,OAAA,cAAAA,OAAA,gBACE,gBAAAA,OAAA,cAACE,OAAA,MACC,gBAAAF,OAAA,cAACE,OAAA,EAAK,MAAM,QAAM,kBAAgB,GAAO,KACzC,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,kBAAe,aAAW,GAAO,GAC/C,GACA,gBAAAF,OAAA,cAACC,MAAA,EAAI,eAAc,SACjB,gBAAAD,OAAA;AAAA,MAAC;AAAA;AAAA,QACC,SAAS,WAAW,QAAQ;AAAA,QAC5B,KAAK;AAAA,QACL,OAAO;AAAA;AAAA,IACT,GACA,gBAAAA,OAAA,cAACE,OAAA,MACE,KACA,WAAW,QAAQ,aAAa,IAC/B,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,iBAAc,MAAI,IAE9B,iBAAiB,WAAW,QAAQ,QAAQ,GAC3C,KAAI,KAEN,WAAW,QAAQ,eAClB,WAAW,QAAQ,iBAAiB,KAAI,SAE5C,CACF,GACA,gBAAAF,OAAA,cAACE,OAAA,MAAK,GAAC,GAEP,gBAAAF,OAAA;AAAA,MAAC;AAAA;AAAA,QACC,MAAM,WAAW;AAAA,QACjB,SAAS;AAAA,UACP,EAAE,OAAO,UAAU,KAAK,cAAc,OAAO,OAAO;AAAA,UACpD,EAAE,OAAO,WAAW,KAAK,eAAe,OAAO,OAAO;AAAA,UACtD;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,YACP,QAAQ,CAAC,GAAG,QACV,IAAI,iBAAiB,SAAY,IAAI,eAAe;AAAA,UACxD;AAAA,UACA;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,UACT;AAAA,UACA,EAAE,OAAO,SAAS,KAAK,eAAe,OAAO,QAAQ;AAAA,UACrD;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,YACP,QAAQ,CAAC,MAAO,IAAI,iBAAiB,CAAC,IAAI;AAAA,UAC5C;AAAA,UACA;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,YACP,QAAQ,CAAC,MAAO,IAAI,UAAU,CAAC,IAAI;AAAA,UACrC;AAAA,QACF;AAAA;AAAA,IACF,GACA,gBAAAA,OAAA,cAACE,OAAA,MAAK,GAAC,CACT;AAAA,EAEJ;AAEA,MAAI;AACJ,MAAI,SAAS,QAAQ,aAAa,GAAG;AACnC,sBACE,gBAAAF,OAAA,cAAAA,OAAA,gBACE,gBAAAA,OAAA,cAACE,OAAA,EAAK,MAAM,QAAM,WAAS,GAC3B,gBAAAF,OAAA,cAACE,OAAA,MAAK,qBAAmB,GACzB,gBAAAF,OAAA,cAACE,OAAA,MAAK,GAAC,CACT;AAAA,EAEJ,OAAO;AACL,UAAM,oBACJ,SAAS,QAAQ,WAAW,WAAW,QAAQ;AAEjD,sBACE,gBAAAF,OAAA,cAAAA,OAAA,gBACE,gBAAAA,OAAA,cAACE,OAAA,MACC,gBAAAF,OAAA,cAACE,OAAA,EAAK,MAAM,QAAM,WAAS,GAAO,KACjC,sBAAsB,IACrB,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,iBAAc,MAAI,IAE9B,gBAAAF,OAAA,cAACE,OAAA,EAAK,OAAM,kBAAe,aAAW,GACtC,GAEJ,GACA,gBAAAF,OAAA,cAACC,MAAA,EAAI,eAAc,SACjB,gBAAAD,OAAA,cAAC,eAAY,SAAS,mBAAmB,KAAK,GAAG,OAAO,IAAI,GAC5D,gBAAAA,OAAA,cAACE,OAAA,MAAK,MAAG,SAAS,QAAQ,aAAY,UAAQ,CAChD,GACA,gBAAAF,OAAA,cAACE,OAAA,MAAK,GAAC,GAEP,gBAAAF,OAAA;AAAA,MAAC;AAAA;AAAA,QACC,MAAM,SAAS;AAAA,QACf,SAAS;AAAA,UACP,EAAE,OAAO,SAAS,KAAK,aAAa,OAAO,OAAO;AAAA,UAClD,EAAE,OAAO,WAAW,KAAK,eAAe,OAAO,OAAO;AAAA,UACtD,EAAE,OAAO,SAAS,KAAK,SAAS,OAAO,QAAQ;AAAA,UAC/C;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,YACP,QAAQ,CAAC,GAAG,QAAS,IAAI,QAAQ,IAAI,IAAI;AAAA,UAC3C;AAAA,UACA;AAAA,YACE,OAAO;AAAA,YACP,KAAK;AAAA,YACL,OAAO;AAAA,YACP,QAAQ,CAAC,MAAO,IAAI,IAAI,GAAG,EAAE,QAAQ,CAAC,CAAC,OAAO;AAAA,UAChD;AAAA,QACF;AAAA;AAAA,IACF,GACA,gBAAAA,OAAA,cAACE,OAAA,MAAK,GAAC,CACT;AAAA,EAEJ;AAEA,SACE,gBAAAF,OAAA,cAACC,MAAA,EAAI,eAAc,YACjB,gBAAAD,OAAA,cAACE,OAAA,MAAK,GAAC,GAEN,mBAEA,iBAuHD,gBAAAF,OAAA,cAACC,MAAA,EAAI,eAAc,YACjB,gBAAAD,OAAA,cAACE,OAAA,EAAK,MAAI,QAAC,UAAQ,GACnB,gBAAAF,OAAA,cAACC,MAAA,EAAI,eAAc,SACjB,gBAAAD,OAAA,cAACE,OAAA,MAAK,oCAAiC,IAAK,CAC9C,CACF,CACF;AAEJ;AAEO,IAAM,cAAc,CAAC,OAAgB;AAC1C,QAAM,EAAE,UAAU,SAAS,YAAY,MAAM,IAAI,UAAU,gBAAAF,OAAA,cAAC,OAAK,GAAG,IAAI,CAAE;AAE1E,QAAM,SAAS,CAACG,QAAgB;AAC9B,aAAS,gBAAAH,OAAA,cAAC,OAAK,GAAGG,KAAI,CAAE;AAAA,EAC1B;AAEA,QAAM,UAAU,MAAM;AACpB,UAAM;AACN,eAAW;AAAA,EACb;AACA,SAAO,EAAE,QAAQ,QAAQ;AAC3B;;;AGzXO,IAAM,YAAN,MAAgB;AAAA,EACb;AAAA,EAEA,KAAK,aAAa;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EAEnB,YAAY,EAAE,OAAO,GAAuB;AAC1C,SAAK,SAAS;AAEd,UAAM,EAAE,QAAQ,QAAQ,IAAI,YAAY,KAAK,EAAE;AAC/C,SAAK,SAAS,MAAM,OAAO,KAAK,EAAE;AAClC,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,QAAQ;AACN,SAAK,KAAK,aAAa;AACvB,UAAM,UAAU,KAAK,OAAO;AAE5B,SAAK,iBAAiB,YAAY,YAAY;AAE5C,WAAK,GAAG,aAAa,MAAM,0BAA0B,OAAO;AAsB5D,WAAK,GAAG,WAAW,MAAM,oBAAoB,OAAO;AAGpD,YAAM,QAAQ,MAAM,QAAQ,wBAAwB,IAAI,GAAG,OAAO,CAAC,EAChE;AACH,WAAK,GAAG,OAAO;AAEf,UAAI,KAAK;AAAU;AACnB,WAAK,SAAS;AAAA,IAChB,GAAG,EAAE;AAAA,EACP;AAAA,EAEA,qBAAqB;AACnB,SAAK,GAAG,SAAS,WAAW;AAC5B,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,OAAO;AACL,SAAK,WAAW;AAChB,kBAAc,KAAK,cAAc;AACjC,SAAK,UAAU;AAAA,EACjB;AACF;;;ACxEA,SAAS,WAAW;AAEpB,IAAM,aAAwC;AAAA,EAC5C,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,QAAQ,EACpB,UAAU,iBAAiB,UAAU,EACrC,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,YAAY,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,WAAW,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,UAAU,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,gBAAgB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,aAAa,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,mBAAmB,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,oBAAoB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,cAAc,MAAM,EAC9B,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,eAAe,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,OAAO,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,YAAY,UAAU,EAChC,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,gBAAgB,UAAU,EACpC,UAAU,wBAAwB,UAAU,EAC5C,UAAU,SAAS,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7C,UAAU,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7C,UAAU,MAAM,MAAM,EACtB,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,SAAS,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,KAAK,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,MAAM,EAClB,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,eAAe,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,mBAAmB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,eAAe,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,gCAAgC;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,UAAU,YAAY,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,qBAAqB,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAGrD,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,cAAc,YAAY,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,MAAM,EACT,QAAQ,CAAC,WAAW,WAAW,WAAW,CAAC,EAC3C,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,GAAG,QAAQ,EACX,QAAQ,CAAC,aAAa,QAAQ,CAAC,EAC/B,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,6BAA6B,EACzC,GAAG,uBAAuB,EAC1B,QAAQ,CAAC,WAAW,CAAC,EACrB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,MAAM,GAAG,IAAiB;AAExB,YAAM,GAAG,OAAO,UAAU,kBAAkB,EAAE,QAAQ;AACtD,YAAM,GAAG,OAAO,UAAU,cAAc,EAAE,QAAQ;AAGlD,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,MAAM,EACT,OAAO,WAAW,EAClB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,MAAM,EACT,OAAO,QAAQ,EACf,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,GAAG,QAAQ,EACX,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,WAAW,QAAQ,EAAE,WAAW,WAAW,EAAE,QAAQ;AACrE,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,WAAW,WAAW,EACtB,QAAQ;AACX,YAAM,GAAG,OAAO,WAAW,MAAM,EAAE,WAAW,WAAW,EAAE,QAAQ;AACnE,YAAM,GAAG,OACN,WAAW,qBAAqB,EAChC,WAAW,WAAW,EACtB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,gCAAgC;AAAA,IAC9B,MAAM,GAAG,IAAiB;AAExB,YAAM,GAAG,OAAO,UAAU,uBAAuB,EAAE,QAAQ;AAG3D,YAAM,GAAG,OAAO,UAAU,QAAQ,EAAE,QAAQ;AAC5C,YAAM,GAAG,OACN,YAAY,QAAQ,EACpB,UAAU,iBAAiB,gBAAgB,EAC3C,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACpE,UAAU,aAAa,gBAAgB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,UAAU,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,gBAAgB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,QAAQ,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,aAAa,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,mBAAmB,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrE,UAAU,oBAAoB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnE,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,QAAQ,EACX,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,cAAc,EAAE,QAAQ;AAClD,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,cAAc,MAAM,EAC9B,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,OAAO,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,YAAY,gBAAgB,EACtC,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACpE,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,gBAAgB,gBAAgB,EAC1C,UAAU,wBAAwB,gBAAgB,EAClD,UAAU,SAAS,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,MAAM,aAAa,EAC7B,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,SAAS,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,KAAK,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,MAAM,EAAE,QAAQ;AAC1C,YAAM,GAAG,OACN,YAAY,MAAM,EAClB,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,MAAM,EACT,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,iBAAiB,EAC7B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,iBAAiB,EAC7B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,gBAAgB,EAC5B,GAAG,MAAM,EACT,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,QAAQ;AACzD,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,gCAAgC;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,YAAY,EACxB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,aAAa,EAClC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D;AAAA,QAAU;AAAA,QAAe;AAAA,QAAQ,CAAC,QACjC,IAAI,QAAQ,EAAE,WAAW,eAAe;AAAA,MAC1C,EACC,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,+BAA+B,EAC3C,GAAG,oBAAoB,EACvB,OAAO,aAAa,EACpB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,WAAW,EACvB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,iBAAiB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,wBAAwB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,2BAA2B,EACvC,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D;AAAA,QAAU;AAAA,QAAa;AAAA,QAAQ,CAAC,QAC/B,IAAI,QAAQ,EAAE,WAAW,cAAc;AAAA,MACzC,EACC,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oCAAoC,EAChD,GAAG,2BAA2B,EAC9B,OAAO,WAAW,EAClB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,qCAAqC;AAAA,IACnC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,QAAQ;AAUzD,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,8BAA8B;AAAA,QACrD;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,qCAAqC;AAAA,IACnC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,MAAM,EACjB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,YAAY,EACvB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,mBAAmB,EAC9B,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,MAAM,CAAC,EACvD,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,sCAAsC;AAAA,IACpC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,WAAW,CAAC,QAAQ,IAAI,YAAY,CAAC,EACjD,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,SAAS,CAAC,QAAQ,IAAI,YAAY,CAAC,EAC/C,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,2CAA2C;AAAA,IACzC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,4BAA4B,EACxC,GAAG,MAAM,EACT,OAAO,iBAAiB,EACxB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,kDAAkD;AAAA,IAChD,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,cAAc,CAAC,QAAQ,IAAI,YAAY,CAAC,EACpD,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,YAAY,KAAK,CAAC,QAAQ,IAAI,YAAY,CAAC,EAC3C,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,YAAY,KAAK,CAAC,QAAQ,IAAI,YAAY,CAAC,EAC3C,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,YAAY,KAAK,CAAC,QAAQ,IAAI,YAAY,CAAC,EAC3C,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,KAAkB;AAEzB;AAAA,IACF;AAAA,EACF;AAAA,EACA,mCAAmC;AAAA,IACjC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,UAAU,kBAAkB,EAAE,SAAS,EAAE,QAAQ;AACjE,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,SAAS,EAAE,QAAQ;AAEpE,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,MAAM,EACT,OAAO,aAAa,EACpB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,gDAAgD;AAAA,IAC9C,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,mBAAmB,CAAC,QAAQ,IAAI,YAAY,CAAC,EACzD,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,oDAAoD;AAAA,IAClD,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG;AAAA,QACP;AAAA;AAAA;AAAA,gCAGwB,QAAQ,EAAE;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAAA,EACA,6CAA6C;AAAA,IAC3C,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,aAAa,sCAAsC,QAAQ,EAAE,CAAC;AACvE,YAAM,GAAG;AAAA,QACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAYE,QAAQ,EAAE;AAAA,MACd;AAEA,YAAM,GAAG;AAAA,QACP;AAAA;AAAA,UAEE,QAAQ,EAAE;AAAA,MACd;AAEA,YAAM,GAAG;AAAA,QACP;AAAA;AAAA;AAAA;AAAA;AAAA,UAKE,QAAQ,EAAE;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,YAAY,EACZ,GAAG,MAAM,EACT,OAAO,YAAY,EACnB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,qCAAqC;AAAA,IACnC,MAAM,GAAG,IAAiB;AAGxB,YAAM,GAAG,OACN,WAAW,oBAAoB,EAC/B,eAAe,qCAAqC,EACpD,QAAQ;AACX,YAAM,GACH,YAAY,YAAY,EACxB,IAAI,EAAE,IAAI,kBAAkB,CAAC,EAC7B,QAAQ;AACX,YAAM,GACH,YAAY,oBAAoB,EAChC,IAAI,EAAE,aAAa,2BAA2B,CAAC,EAC/C,QAAQ;AAIX,YAAM,GAAG,OACN,WAAW,YAAY,EACvB;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ,EAAE,UAAU,CAAC;AAAA,MAC3B,EACC,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,YAAY,EACvB,YAAY,8BAA8B,CAAC,QAAQ,IAAI,YAAY,CAAC,EACpE,QAAQ;AAGX,YAAM,GAAG,OACN,WAAW,2BAA2B,EACtC,eAAe,0CAA0C,EACzD,QAAQ;AACX,YAAM,GACH,YAAY,WAAW,EACvB,IAAI,EAAE,IAAI,kBAAkB,CAAC,EAC7B,QAAQ;AACX,YAAM,GACH,YAAY,2BAA2B,EACvC,IAAI,EAAE,WAAW,yBAAyB,CAAC,EAC3C,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ,EAAE,UAAU,CAAC;AAAA,MAC3B,EACC,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB,YAAY,8BAA8B,CAAC,QAAQ,IAAI,YAAY,CAAC,EACpE,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,mBAAmB,aAAa,EAC1C;AAAA,QAAU;AAAA,QAAqB;AAAA,QAAkB,CAAC,QACjD,IAAI,QAAQ;AAAA,MACd,EACC;AAAA,QAAU;AAAA,QAAqB;AAAA,QAAkB,CAAC,QACjD,IAAI,QAAQ;AAAA,MACd,EACC,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,WAAW,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,gBAAgB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,UAAU,MAAM,aAAa,EAC7B;AAAA,QAAU;AAAA,QAAmB;AAAA,QAAe,CAAC,QAC5C,IAAI,QAAQ,EAAE,WAAW;AAAA,MAC3B,EACC,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,8BAA8B;AAAA,IAC5B,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D;AAAA,QAAU;AAAA,QAAiB;AAAA,QAAQ,CAAC,QACnC,IAAI,QAAQ,EAAE,WAAW,iBAAiB;AAAA,MAC5C,EACC,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mCAAmC,EAC/C,GAAG,sBAAsB,EACzB,OAAO,eAAe,EACtB,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,UAAU,cAAc,aAAa,EACrC,QAAQ;AAEX,YAAM,GAAG;AAAA,QACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAWI,QAAQ,EAAE;AAAA,MAChB;AAEA,YAAM,GAAG;AAAA,QACP;AAAA;AAAA;AAAA;AAAA;AAAA,UAKE,QAAQ,EAAE;AAAA,MACd;AAEA,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,YAAY,cAAc,CAAC,QAAQ,IAAI,WAAW,CAAC,EACnD,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,QAAQ,EACX,OAAO,SAAS,EAChB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,QAAQ,EACX,OAAO,YAAY,EACnB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,8BAA8B;AAAA,IAC5B,MAAM,GAAG,IAAiB;AAGxB,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,eAAe,aAAa,EACtC,UAAU,aAAa,aAAa,EACpC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,iBAAiB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mCAAmC,EAC/C,GAAG,sBAAsB,EACzB,OAAO,eAAe,EACtB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,YAAY,EACxB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,OAAO,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,MAAM,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,SAAS,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjE,UAAU,SAAS,MAAM,EACzB,UAAU,WAAW,gBAAgB,EACrC,UAAU,UAAU,MAAM,EAC1B,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,gBAAgB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,uBAAuB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,4BAA4B,EACxC,GAAG,YAAY,EACf,OAAO,aAAa,EACpB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,iCAAiC,EAC7C,GAAG,YAAY,EACf,OAAO,kBAAkB,EACzB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,YAAY,EACf,OAAO,OAAO,EACd,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,0BAA0B,EACtC,GAAG,YAAY,EACf,OAAO,WAAW,EAClB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,gCAAgC,EAC5C,GAAG,YAAY,EACf,OAAO,iBAAiB,EACxB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,2BAA2B,EACvC,GAAG,YAAY,EACf,OAAO,YAAY,EACnB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,wBAAwB,EACpC,GAAG,YAAY,EACf,OAAO,SAAS,EAChB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,YAAY,EACf,OAAO,MAAM,EACb,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,YAAY,EACf,OAAO,IAAI,EACX,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB,SAAS,mBAAmB,EAC5B,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,iBAAiB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,wBAAwB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,eAAe,aAAa,EACtC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,6BAA6B,EACzC,UAAU,MAAM,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,aAAa,MAAM,EAC7B,UAAU,cAAc,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,YAAY,kBAAkB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sCAAsC,EAClD,GAAG,6BAA6B,EAChC,OAAO,WAAW,EAClB,QAAQ;AAAA,IACb;AAAA,EACF;AACF;AAEA,IAAM,0BAAN,MAA2D;AAAA,EACzD,MAAM,gBAAgB;AACpB,WAAO;AAAA,EACT;AACF;AAEO,IAAM,oBAAoB,IAAI,wBAAwB;AAE7D,eAAsB,iBAAiB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AACF,GAIG;AAGD,MAAI,sBAAsB;AAC1B,MAAI;AACF,UAAM,EAAE,KAAK,IAAI,MAAM,GAAG;AAAA,MACxB,mDAAmD,QAAQ,EAAE;AAAA,IAC/D;AACA,QAAI,KAAK,CAAC,GAAG,SAAS;AAAwB,4BAAsB;AAAA,EACtE,SAAS,GAAG;AACV,UAAM,QAAQ;AACd,QAAI,CAAC,MAAM,QAAQ,SAAS,gBAAgB;AAAG,YAAM;AAAA,EACvD;AAEA,MAAI,CAAC;AAAqB;AAE1B,SAAO,OAAO,KAAK;AAAA,IACjB,SAAS;AAAA,IACT,KAAK;AAAA,EACP,CAAC;AAED,iBAAe,kBAAkB,WAAmB;AAClD,QAAI;AACF,YAAM,GAAG,OACN,WAAW,UAAU,SAAS,EAAE,EAChC,UAAU,aAAa,EACvB,QAAQ;AAAA,IACb,SAAS,GAAG;AACV,YAAM,QAAQ;AACd,cAAQ,MAAM,SAAS;AAAA,QACrB,KAAK,aAAa,SAAS,+BAA+B,aAAa,KAAK;AAC1E,gBAAM,GAAG,OACN,UAAU,UAAU,SAAS,EAAE,EAC/B,QAAQ,EAER,MAAM,MAAM;AAAA,UAAC,CAAC;AACjB;AAAA,QACF;AAAA,QACA,KAAK,oBAAoB,SAAS,oBAAoB;AACpD;AAAA,QACF;AAAA,QACA,SAAS;AACP,iBAAO,OAAO,KAAK;AAAA,YACjB,SAAS;AAAA,YACT,KAAK,4BAA4B,SAAS,8BAA8B,MAAM,OAAO;AAAA,UACvF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,KAAK;AAAA,MACjB,SAAS;AAAA,MACT,KAAK,8BAA8B,SAAS;AAAA,IAC9C,CAAC;AAAA,EACH;AAEA,QAAM,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,EACF;AAEA,aAAW,aAAa,YAAY;AAClC,UAAM,kBAAkB,SAAS;AAAA,EACnC;AACF;;;ACx5BA,IAAM,yBAAyB;AAG/B,IAAM,kBAAkB;AAExB,IAAM,sBAAsB;AAE5B,IAAM,2BAA2B;AAEjC,IAAM,oBAAoB;AAE1B,IAAM,qBAAqB;AAE3B,IAAM,oBACJ,yBACA,kBACA,sBACA,2BACA,oBACA;AAEK,IAAM,cAAc;AAAA,EACzB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,YAAY;AACd;AAEO,IAAM,mBAAmB,CAAC,eAA2B;AAC1D,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,MAAI,YAAY,KAAK,YAAY;AAC/B,UAAM,IAAI;AAAA,MACR,0BAA0B,SAAS;AAAA,IACrC;AAEF,QAAM,SACJ,eAAe,SAAS,EAAE,SAAS,wBAAwB,GAAG,IAC9D,QAAQ,SAAS,EAAE,SAAS,iBAAiB,GAAG,IAChD,YAAY,SAAS,EAAE,SAAS,qBAAqB,GAAG,IACxD,iBAAiB,SAAS,EAAE,SAAS,0BAA0B,GAAG,IAClE,UAAU,SAAS,IACnB,WAAW,SAAS,EAAE,SAAS,oBAAoB,GAAG;AAExD,MAAI,OAAO,WAAW;AACpB,UAAM,IAAI,MAAM,mCAAmC,MAAM,EAAE;AAE7D,SAAO;AACT;AAEO,IAAM,mBAAmB,CAAC,eAAmC;AAClE,MAAI,SAAS;AAEb,QAAM,iBAAiB,CAAC,WAAW;AAAA,IACjC;AAAA,IACA,SAAS;AAAA,EACX;AACA,YAAU;AAEV,QAAM,UAAU,OAAO,WAAW,MAAM,QAAQ,SAAS,eAAe,CAAC;AACzE,YAAU;AAEV,QAAM,cAAc;AAAA,IAClB,WAAW,MAAM,QAAQ,SAAS,mBAAmB;AAAA,EACvD;AACA,YAAU;AAEV,QAAM,mBAAmB;AAAA,IACvB,WAAW,MAAM,QAAQ,SAAS,wBAAwB;AAAA,EAC5D;AACA,YAAU;AAEV,QAAM,YAAY,CAAC,WAAW,MAAM,QAAQ,SAAS,iBAAiB;AACtE,YAAU;AAEV,QAAM,aAAa;AAAA,IACjB,WAAW,MAAM,QAAQ,SAAS,kBAAkB;AAAA,EACtD;AACA,YAAU;AAEV,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,iBAA6B;AAAA,EACxC,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,aAAa;AAAA,EACb,kBAAkB;AAAA,EAClB,WAAW;AAAA,EACX,YAAY;AACd;AAEO,IAAM,gBAA4B;AAAA,EACvC,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,aAAa;AAAA,EACb,kBAAkB;AAAA,EAClB,WAAW;AAAA,EACX,YAAY;AACd;AAKO,IAAM,oBAAoB,CAAC,GAAe,MAC/C,iBAAiB,CAAC,MAAM,iBAAiB,CAAC;AAMrC,IAAM,0BAA0B,CAAC,GAAe,MACrD,iBAAiB,CAAC,IAAI,iBAAiB,CAAC;AAenC,IAAM,gBAAgB,IAAI,gBAC/B,YAAY,OAAO,CAAC,KAAK,eAAe;AACtC,SAAO,wBAAwB,KAAK,UAAU,IAAI,aAAa;AACjE,CAAC;AAEI,IAAM,SAAS,iBAAiB,aAAa;;;AC3JpD,SAAS,cAAAC,mBAAkB;AAgBpB,SAAS,KAAK,OAAiC;AACpD,SAAOA,YAAW,QAAQ,EACvB,OAAO,KAAK,UAAU,KAAK,CAAC,EAC5B,OAAO,KAAK,EACZ,MAAM,GAAG,EAAE;AAChB;;;ACrBA,OAAO,QAA6B;;;ACE7B,SAAS,YACd,MACA;AACA,QAAM,UAAU,OAAO,QAAQ,IAAI,EAChC,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AACrB,QAAI,UAAU;AAAW,aAAO;AAEhC,UAAM,eACJ,OAAO,UAAU,YAAY,MAAM,SAAS,KACxC,MAAM,MAAM,GAAG,EAAE,EAAE,OAAO,KAAK,IAC/B;AAEN,WAAO,CAAC,KAAK,YAAY;AAAA,EAC3B,CAAC,EACA,OAAO,OAAO;AACjB,QAAM,YAAY,QAAQ;AAAA,IACxB,CAAC,KAAK,CAAC,GAAG,MAAM,KAAK,IAAI,KAAK,IAAI,MAAM;AAAA,IACxC;AAAA,EACF;AACA,SAAO,QACJ,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,KAAK,GAAG,GAAG,GAAG,OAAO,YAAY,CAAC,CAAC,KAAK,KAAK,EAAE,EACrE,KAAK,IAAI;AACd;;;ADnBA,GAAG,MAAM,cAAc,GAAG,MAAM,SAAS,SAAS,MAAM;AAExD,GAAG,MAAM,cAAc,GAAG,MAAM,SAAS,MAAM,MAAM;AAIrD,IAAM,sBAAsB,GAAG,OAAO,UAAU;AAEhD,GAAG,OAAO,UAAU,QAAQ,SAAS,SAChC,MACH;AACA,MAAI;AACF,WAAO,oBAAoB,MAAM,MAAM,IAAI;AAAA,EAC7C,SAAS,QAAQ;AACf,UAAM,QAAQ;AACd,UAAM,CAAC,WAAW,WAAW,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC;AAErD,UAAM,OAAO;AAEb,QAAI,aAAa,eAAe,CAAC;AACjC,iBACE,WAAW,UAAU,KACjB,aACA,WAAW,MAAM,GAAG,EAAE,EAAE,OAAO,CAAC,KAAK,CAAC;AAC5C,UAAM,SAAS,WAAW;AAAA,MACxB,CAAC,KAAK,WAAW,QAAQ;AACvB,YAAI,MAAM,CAAC,IAAI;AACf,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,UAAM,eAAe,CAAC;AACtB,QAAI,MAAM;AAAQ,mBAAa,KAAK;AAAA,IAAc,MAAM,MAAM,EAAE;AAChE,iBAAa,KAAK;AAAA,IAAiB,SAAS,EAAE;AAC9C,iBAAa,KAAK;AAAA,EAAgB,YAAY,MAAM,CAAC,EAAE;AAEvD,UAAM,OAAO,aAAa,KAAK,IAAI;AAEnC,UAAM;AAAA,EACR;AACF;AAEO,SAAS,WAAW,QAAoB;AAC7C,SAAO,IAAI,GAAG,KAAK;AAAA;AAAA,IAEjB,mBAAmB,IAAI,KAAK;AAAA;AAAA,IAC5B,GAAG;AAAA,EACL,CAAC;AACH;;;AExBA;AAAA,EAIE;AAAA,EACA;AAAA,EAEA;AAAA,EACA,OAAAC;AAAA,OACK;AAEP,OAAOC,iBAAgB;;;ACrCvB,SAAS,cAAmD;AAE5D,IAAM,cAAc;AACpB,IAAM,gBAAgB;AAEf,IAAM,iBAAN,cAAiC,OAAW;AAAA,EACzC;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EAEnB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACL,GAAoE;AAClE,UAAM,IAAI;AACV,SAAK,SAAS;AACd,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAe,UAAU;AACvB,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,OAAO,OACL,SACA,OAGe;AAEf,QAAI;AACJ,QAAI,WAAW;AAEf,aAAS,IAAI,GAAG,KAAK,aAAa,KAAK;AACrC,YAAM,WAAW,WAAW;AAC5B,UAAI;AACF,cAAM,SAAS,MAAM,GAAG;AACxB,aAAK,OAAO,QAAQ,gCAAgC;AAAA,UAClD,EAAE,SAAS,KAAK,MAAM,QAAQ,QAAQ,OAAO;AAAA,UAC7C,SAAS;AAAA,QACX;AACA,eAAO;AAAA,MACT,SAAS,QAAQ;AACf,cAAM,QAAQ;AAEd,aAAK,OAAO,QAAQ,gCAAgC;AAAA,UAClD,EAAE,SAAS,KAAK,MAAM,QAAQ,QAAQ,OAAO;AAAA,UAC7C,SAAS;AAAA,QACX;AACA,aAAK,OAAO,QAAQ,mCAAmC,IAAI;AAAA,UACzD,SAAS,KAAK;AAAA,UACd,QAAQ,QAAQ;AAAA,QAClB,CAAC;AAED,YAAI,KAAK,UAAU;AACjB,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS,KAAK;AAAA,YACd,KAAK,yBAAyB,QAAQ,MAAM;AAAA,UAC9C,CAAC;AACD,gBAAM,IAAI,eAAe;AAAA,QAC3B;AAEA,YAAI,CAAC,UAAU;AACb,qBAAW;AACX,uBAAa;AAAA,QACf;AAEA,YAAI,iBAAiB,mBAAmB;AACtC,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS,KAAK;AAAA,YACd,KAAK,WAAW,QAAQ,MAAM,+CAA+C,WAAW,OAAO;AAAA,UACjG,CAAC;AACD,gBAAM;AAAA,QACR;AAEA,YAAI,MAAM,aAAa;AACrB,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS,KAAK;AAAA,YACd,KAAK,WAAW,QAAQ,MAAM,4BAC5B,IAAI,CACN,0BAA0B,WAAW,OAAO;AAAA,UAC9C,CAAC;AACD,gBAAM;AAAA,QACR;AAEA,cAAM,WAAW,gBAAgB,KAAK;AACtC,aAAK,OAAO,OAAO,MAAM;AAAA,UACvB,SAAS,KAAK;AAAA,UACd,KAAK,WAAW,QAAQ,MAAM,qCAAqC,QAAQ,yBAAyB,MAAM,OAAO;AAAA,QACnH,CAAC;AACD,cAAM,KAAK,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AACF;;;AC/FO,IAAM,uBAAuB,OAAO;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AACF,MAIM;AACJ,QAAM,GAAG,KAAK,EAAE,QAAQ,SAAS,GAAG,YAAY;AAC9C,UAAM,oBAAoB,iBAAiB,UAAU;AAErD,UAAM,QAAQ;AAAA,MACZ,OAAO,QAAQ,cAAc,gBAAgB,EAAE;AAAA,QAC7C,OAAO,CAAC,WAAW,OAAO,MAAM;AAC9B,gBAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAC3C,kBAAM,OAAO,MAAM,GAChB,WAAW,cAAc,iBAAiB,EAC1C,WAAW,OAAO,EAClB,aAAa,EACb,MAAM,cAAc,KAAK,iBAAiB,EAC1C,QAAQ;AAEX,kBAAM,WAAW,KAAK;AAAA,cACpB,CAAC,GAAG,MAAM,EAAE,eAAe,EAAE;AAAA,YAC/B;AAGA,uBAAW,OAAO,UAAU;AAC1B,kBAAI,IAAI,cAAc,GAAG;AAEvB,sBAAM,GACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,cACb,WAAW,IAAI,cAAc,GAAG;AAE9B,oBAAI,eAAe;AACnB,oBAAI,aAAa;AACjB,oBAAI,YAAY;AAEhB,sBAAM,GACH,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,GAAG,EACP,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,cACb,OAAO;AAEL,oBAAI,eAAe;AACnB,oBAAI,aAAa;AACjB,oBAAI,YAAY;AAEhB,sBAAM,GACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,GAAG,EACV,QAAQ;AAAA,cACb;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;ACtEA,OAA4B;AAC5B,OAAuD;AAEvD,IAAMC,cAAwC;AAAA,EAC5C,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,gBAAgB,EAC5B,YAAY,EACZ,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAClE,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,gBAAgB,UAAU,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD;AAAA,QAAU;AAAA,QAAwB;AAAA,QAAe,CAAC,QACjD,IAAI,QAAQ;AAAA,MACd,EACC,UAAU,UAAU,SAAS,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,QAAQ;AAAA,IACb;AAAA,EACF;AACF;AAEA,IAAMC,2BAAN,MAA2D;AAAA,EACzD,MAAM,gBAAgB;AACpB,WAAOD;AAAA,EACT;AACF;AAEO,IAAME,qBAAoB,IAAID,yBAAwB;;;AHmBtD,IAAM,0BAAN,MAA6D;AAAA,EAClE,OAAO;AAAA,EAEC,oBAAoB;AAAA,EAEpB;AAAA,EACA;AAAA,EACA;AAAA,EAER;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEQ,SAAiB;AAAA,EACjB,UAAkB;AAAA,EAClB;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACf,GAMG;AACD,SAAK,SAAS;AACd,SAAK,gBAAgB;AACrB,SAAK,gBAAgB;AAErB,UAAM,cAAc;AACpB,UAAM,WAAW,KAAK,OAAO,WAAW,MAAM,eAAe,CAAC;AAC9D,UAAM,CAAC,aAAa,aAAa,OAAO,IAAI,aACxC,CAAC,WAAW,MAAM,aAAa,GAAG,CAAC,IACnC,CAAC,UAAU,UAAU,QAAQ;AAEjC,SAAK,eAAe,WAAW;AAAA,MAC7B,GAAG;AAAA,MACH,kBAAkB,GAAG,aAAa;AAAA,MAClC,KAAK;AAAA,MACL,mBAAmB,KAAK,KAAK;AAAA;AAAA,IAC/B,CAAC;AACD,SAAK,WAAW,WAAW;AAAA,MACzB,GAAG;AAAA,MACH,kBAAkB,GAAG,aAAa;AAAA,MAClC,KAAK;AAAA,IACP,CAAC;AACD,SAAK,eAAe,WAAW;AAAA,MAC7B,GAAG;AAAA,MACH,kBAAkB,GAAG,aAAa;AAAA,MAClC,KAAK;AAAA,IACP,CAAC;AACD,SAAK,eAAe,WAAW;AAAA,MAC7B,GAAG;AAAA,MACH,kBAAkB,GAAG,aAAa;AAAA,MAClC,KAAK;AAAA,IACP,CAAC;AAED,SAAK,KAAK,IAAI,eAA+B;AAAA,MAC3C,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,gBAAgB,EAAE,MAAM,KAAK,aAAa,CAAC;AAAA,MACxD,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,4BAA4B,IAAI,EAAE,MAAM,WAAW,CAAC;AAAA,QACrE;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,SAAS,IAAI,eAAgC;AAAA,MAChD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,gBAAgB,EAAE,MAAM,KAAK,SAAS,CAAC;AAAA,MACpD,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,4BAA4B,IAAI,EAAE,MAAM,OAAO,CAAC;AAAA,QACjE;AAAA,MACF;AAAA,MACA,SAAS,CAAC,IAAI,iBAAiB,aAAa,CAAC;AAAA,IAC/C,CAAC;AAED,SAAK,aAAa,IAAI,eAA+B;AAAA,MACnD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,gBAAgB,EAAE,MAAM,KAAK,aAAa,CAAC;AAAA,MACxD,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,4BAA4B,IAAI,EAAE,MAAM,WAAW,CAAC;AAAA,QACrE;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,aAAa,IAAI,eAA+B;AAAA,MACnD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,gBAAgB,EAAE,MAAM,KAAK,aAAa,CAAC;AAAA,MACxD,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,4BAA4B,IAAI,EAAE,MAAM,WAAW,CAAC;AAAA,QACrE;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,MAAM,MAAM,EAAE,QAAQ,QAAQ,GAAwC;AACpE,SAAK,SAAS;AACd,SAAK,UAAU;AAEf,UAAM,KAAK,GAAG,OACX,aAAa,KAAK,aAAa,EAC/B,YAAY,EACZ,QAAQ;AACX,UAAM,KAAK,GAAG,OACX,aAAa,KAAK,iBAAiB,EACnC,YAAY,EACZ,QAAQ;AAEX,UAAM,WAAW,IAAI,SAAS;AAAA,MAC5B,IAAI,KAAK,GAAG,WAAW,IAAI,iBAAiB,KAAK,iBAAiB,CAAC;AAAA,MACnE,UAAUE;AAAA,MACV,sBAAsB,KAAK;AAAA,IAC7B,CAAC;AACD,UAAM,SAAS,MAAM,SAAS,gBAAgB;AAE9C,QAAI,OAAO;AAAO,YAAM,OAAO;AAE/B,UAAM,gBAAgB;AAAA,MACpB,eAAe,KAAK;AAAA,MACpB,mBAAmB,KAAK;AAAA,MACxB,kBAAkB,OAAO,KAAK,UAAU,MAAM,CAAC,EAAE;AAAA,QAC/C,CAAC,KAAK,cAAc;AAClB,cAAI,SAAS,IAAI,KAAK,CAAC,KAAK,eAAe,KAAK,SAAS,SAAS,CAAC;AACnE,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,QAAQ,GAAG,YAAY;AACnD,YAAM,eAAe,YAAY;AAC/B,eAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,gBAAM,kBAAkB,MAAM,GAC3B,WAAW,KAAK,iBAAiB,EACjC,WAAW,gBAAgB,EAC3B,UAAU,EACV,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,iBAAiB;AAEpB,gBAAM,aAAa;AAAA,YACjB,WAAW,KAAK;AAAA,YAChB,WAAW;AAAA,YACX,cAAc,KAAK,IAAI;AAAA,YACvB,UAAU,KAAK;AAAA,YACf,sBAAsB,iBAAiB,cAAc;AAAA;AAAA;AAAA,YAGrD,QAAQ,aAAa,MAAM;AAAA,UAC7B;AAGA,gBAAM,eAAe,YAAY;AAC/B,uBAAW,CAAC,WAAW,KAAK,KAAK,OAAO;AAAA,cACtC,UAAU,MAAM;AAAA,YAClB,GAAG;AACD,oBAAM,UAAU,cAAc,iBAAiB,SAAS;AAExD,oBAAM,GAAG,OACN,WAAW,KAAK,iBAAiB,EACjC,YAAY,OAAO,EACnB;AAAA,gBAAM,CAAC,YACN,KAAK,yBAAyB,SAAS,MAAM,KAAK;AAAA,cACpD,EACC,QAAQ;AAEX,oBAAM,GAAG,OACN,WAAW,KAAK,iBAAiB,EACjC,YAAY,GAAG,OAAO,kBAAkB,EACxC,GAAG,OAAO,EACV,OAAO,YAAY,EACnB,QAAQ;AAEX,kBAAI;AACF,sBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,YAAY,SAAS,EACrB;AAAA,kBAAM,CAAC,YACN,KAAK,aAAa,SAAS,QAAQ,MAAM,KAAK;AAAA,gBAChD,EACC,QAAQ;AAAA,cACb,SAAS,KAAK;AACZ,sBAAM,QAAQ;AACd,oBAAI,CAAC,MAAM,QAAQ,SAAS,gBAAgB;AAAG,wBAAM;AACrD,sBAAM,IAAI;AAAA,kBACR,2BAA2B,KAAK,aAAa,MAAM,SAAS,4FAA4F,KAAK,aAAa;AAAA,gBAC5K;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,kBAAkB,KAAK,aAAa,MAAM,SAAS;AAAA,cAC1D,CAAC;AAAA,YACH;AAAA,UACF;AAGA,cAAI,oBAAoB,QAAW;AACjC,kBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,WAAW,gBAAgB,EAC3B,OAAO,UAAU,EACjB,QAAQ;AACX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,gCAAgC,KAAK,aAAa;AAAA,YACzD,CAAC;AAED,kBAAM,aAAa;AAEnB,mBAAO,EAAE,QAAQ,WAAW,YAAY,eAAe;AAAA,UACzD;AAGA,gBAAM,YACJ,gBAAgB,eAChB,KAAK,OAAO,QAAQ;AAEtB,cAAI,gBAAgB,cAAc,KAAK,KAAK,IAAI,KAAK,WAAW;AAC9D,kBAAM,cAAc,YAAY,KAAK,IAAI;AACzC,mBAAO,EAAE,QAAQ,UAAU,YAAY;AAAA,UACzC;AAKA,cACE,KAAK,OAAO,QAAQ,YAAY,WAChC,gBAAgB,aAAa,KAAK,WAClC,gBAAgB,yBACd,iBAAiB,cAAc,GACjC;AACA,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,iCAAiC,KAAK,OAAO,gBAChD,KAAK,aACP,iBAAiB;AAAA,gBACf,KAAK,IAAI,IAAI,gBAAgB;AAAA,cAC/B,CAAC;AAAA,YACH,CAAC;AAID,uBAAW,CAAC,WAAW,KAAK,KAAK,OAAO;AAAA,cACtC,UAAU,MAAM;AAAA,YAClB,GAAG;AACD,kBAAI,MAAM,gBAAgB;AAAW;AAErC,yBAAW,QAAQ,OAAO,KAAK,MAAM,WAAW,GAAG;AACjD,sBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,UAAU,GAAG,SAAS,IAAI,IAAI,EAAE,EAChC,SAAS,EACT,QAAQ;AAEX,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,kBAAkB,SAAS,IAAI,IAAI,gBAAgB,KAAK,aAAa;AAAA,gBAC5E,CAAC;AAAA,cACH;AAAA,YACF;AAEA,kBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,IAAI,EAAE,WAAW,GAAG,cAAc,KAAK,IAAI,EAAE,CAAC,EAC9C,QAAQ;AACX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,4BAA4B,KAAK,aAAa;AAAA,YACrD,CAAC;AAED,kBAAMC,uBAAsB;AAAA,cAC1B,gBAAgB;AAAA,YAClB;AAEA,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,iEAAiEA,qBAAoB,cAAc,YAAYA,qBAAoB,OAAO,UAAUA,qBAAoB,WAAW;AAAA,YAC1L,CAAC;AAGD,kBAAM,MAAM;AACZ,uBAAW,CAAC,WAAW,OAAO,KAAK,OAAO;AAAA,cACxC,cAAc;AAAA,YAChB,GAAG;AACD,oBAAM,OAAO,MAAM,IAChB,WAAW,cAAc,iBAAiB,EAC1C,WAAW,OAAO,EAClB,aAAa,EACb,MAAM,cAAc,KAAK,gBAAgB,oBAAoB,EAC7D,QAAQ;AAEX,oBAAM,WAAW,KAAK;AAAA,gBACpB,CAAC,GAAG,MAAM,EAAE,eAAe,EAAE;AAAA,cAC/B;AAEA,yBAAW,OAAO,UAAU;AAC1B,oBAAI,IAAI,cAAc,GAAG;AAEvB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,gBACb,WAAW,IAAI,cAAc,GAAG;AAE9B,sBAAI,eAAe;AACnB,sBAAI,aAAa;AACjB,sBAAI,YAAY;AAChB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,GAAG,EACP,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,gBACb,OAAO;AAEL,sBAAI,eAAe;AACnB,sBAAI,aAAa;AACjB,sBAAI,YAAY;AAChB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,GAAG,EACV,QAAQ;AAAA,gBACb;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,YAAY,KAAK,MAAM,0CAA0C,SAAS;AAAA,cACjF,CAAC;AAAA,YACH;AAEA,mBAAO;AAAA,cACL,QAAQ;AAAA,cACR,YAAYA;AAAA,YACd;AAAA,UACF;AAIA,gBAAM,kBAAkB,gBAAgB;AAGxC,gBAAM,iBAAiB,gBAAgB;AAKvC,gBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,UAAU,EACd,QAAQ;AAEX,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,4BAA4B,KAAK,aAAa,+BAA+B,eAAe;AAAA,UACnG,CAAC;AAED,qBAAW,aAAa,OAAO,KAAK,eAAe,MAAM,GAAG;AAC1D,kBAAM,UAAU,KAAK;AAAA,cACnB,KAAK;AAAA,cACL;AAAA,cACA;AAAA,YACF,CAAC;AAED,kBAAM,GAAG,OACN,WAAW,KAAK,iBAAiB,EACjC,UAAU,OAAO,EACjB,SAAS,EACT,QAAQ;AAEX,kBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,UAAU,SAAS,EACnB,QAAQ,EACR,SAAS,EACT,QAAQ;AAEX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,YAAY,SAAS;AAAA,YAC5B,CAAC;AAAA,UACH;AAEA,gBAAM,aAAa;AAEnB,iBAAO,EAAE,QAAQ,WAAW,YAAY,eAAe;AAAA,QACzD,CAAC;AAAA,MACH;AAEA,YAAMC,UAAS,MAAM,aAAa;AAElC,UAAI;AAEJ,UAAIA,QAAO,WAAW,WAAW;AAC/B,8BAAsBA,QAAO;AAAA,MAC/B,OAAO;AAEL,cAAM,EAAE,YAAY,IAAIA;AACxB,aAAK,OAAO,OAAO,KAAK;AAAA,UACtB,SAAS;AAAA,UACT,KAAK,WAAW,KAAK,aAAa;AAAA,QACpC,CAAC;AACD,aAAK,OAAO,OAAO,KAAK;AAAA,UACtB,SAAS;AAAA,UACT,KAAK,WAAW,UAAU,WAAW,CAAC,wBACpC,KAAK,aACP;AAAA,QACF,CAAC;AAED,cAAM,KAAK,WAAW;AAEtB,cAAM,YAAY,MAAM,aAAa;AACrC,YAAI,UAAU,WAAW,UAAU;AACjC,gBAAM,IAAI;AAAA,YACR,qCAAqC,KAAK,aAAa;AAAA,UACzD;AAAA,QACF;AACA,8BAAsB,UAAU;AAAA,MAClC;AAGA,WAAK,oBAAoB,YAAY,YAAY;AAC/C,YAAI;AACF,gBAAM,UAAU,MAAM,KAAK,GACxB,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,cAAc,KAAK,IAAI,EAAE,CAAC,EAChC,aAAa,EACb,iBAAiB;AAEpB,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,kCAAkC,SAAS,YAAY,uBAAuB,KAAK,OAAO;AAAA,UACjG,CAAC;AAAA,QACH,SAAS,KAAK;AACZ,gBAAM,QAAQ;AACd,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,qDAAqD;AAAA,cACxD,KAAK,OAAO,QAAQ;AAAA,YACtB,CAAC;AAAA,YACD;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,GAAG,KAAK,OAAO,QAAQ,yBAAyB;AAEhD,aAAO,EAAE,YAAY,qBAAqB,cAAc;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,OAAO;AAAA,IACX;AAAA,IACA;AAAA,EACF,GAGG;AACD,UAAM,qBAAqB;AAAA,MACzB,IAAI,KAAK;AAAA,MACT;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,0BAA0B;AAAA,IAC9B;AAAA,EACF,GAA8C;AAC5C,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACtE,YAAM,KAAK,GACR,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,sBAAsB,iBAAiB,UAAU,EAAE,CAAC,EAC1D,QAAQ;AAEX,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK,8CAA8C,WAAW,cAAc,YAAY,WAAW,OAAO,UAAU,WAAW,WAAW;AAAA,MAC5I,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAU;AACd,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,UAAU,GAAG,YAAY;AACpD,YAAM,gBAAgB,KAAK;AAC3B,UAAI,kBAAkB,QAAW;AAC/B,aAAK,OAAO,OAAO,MAAM;AAAA,UACvB,SAAS;AAAA,UACT,KAAK;AAAA,QACP,CAAC;AACD;AAAA,MACF;AAEA,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAEhD,cAAM,GAAG,OAAO,aAAa,aAAa,EAAE,YAAY,EAAE,QAAQ;AAElE,mBAAW,aAAa,OAAO,KAAK,UAAU,KAAK,MAAM,CAAC,GAAG;AAE3D,gBAAM,SAAS,MAAM,GAAG;AAAA,YAGtBC;AAAA;AAAA;AAAA,sCAG0BA,KAAI,IAAI,aAAa,CAAC;AAAA,kCAC1BA,KAAI,IAAI,SAAS,CAAC;AAAA,cACtC,QAAQ,EAAE;AAAA,UACd;AAEA,gBAAMC,WAAU,OAAO,KAAK,CAAC,GAAG,eAAe;AAC/C,cAAIA,UAAS;AACX,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,2BAA2B,aAAa,MAAM,SAAS;AAAA,YAC9D,CAAC;AACD;AAAA,UACF;AAEA,gBAAM,SAAS,OAAO,KAAK,CAAC,GAAG,eAAe;AAC9C,cAAI,QAAQ;AACV,kBAAM,GAAG,OACN,WAAW,aAAa,EACxB,SAAS,SAAS,EAClB,SAAS,EACT,QAAQ;AAEX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,0BAA0B,aAAa,MAAM,SAAS;AAAA,YAC7D,CAAC;AAAA,UACH;AAEA,gBAAM,GAAG,OACN,WAAW,aAAa,EACxB,WAAW,SAAS,EACpB;AAAA,YACE,GACE,WAAW,KAAK,aAAa,EAC7B,WAAW,SAAS,EACpB,UAAU;AAAA,UACf,EACC,QAAQ;AAEX,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS;AAAA,YACT,KAAK,iBAAiB,aAAa,MAAM,SAAS,wBAAwB,KAAK,aAAa,MAAM,SAAS;AAAA,UAC7G,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,cAAc,EAAE,OAAO,GAAuB;AAClD,UAAM,QAAQ;AAAA,MACZ,OAAO,QAAQ,UAAU,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,WAAW,KAAK,MAAM;AAChE,YAAI,MAAM,gBAAgB;AAAW,iBAAO,CAAC;AAE7C,eAAO,OAAO,QAAQ,MAAM,WAAW,EAAE,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM;AACpE,gBAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,gBAAgB,GAAG,YAAY;AAC1D,kBAAM,YAAY,GAAG,SAAS,IAAI,IAAI;AAEtC,kBAAM,cAAc,MAAM,SAAS;AACnC,kBAAM,QAAQ,MAAM,QAAQ;AAC5B,kBAAM,QAAQ,MAAM,QAAQ;AAE5B,kBAAM,UAAU,MAAM,QAAQ,WAAW,IACrC,YAAY,IAAI,CAAC,OAAO,IAAI,EAAE,GAAG,EAAE,KAAK,IAAI,IAC5C,IAAI,WAAW,KACb,UAAU,QAAQ,QAAQ,UAAU,SAAS,SAAS,EACxD,IACE,UAAU,UACN,gBACA,UAAU,SACR,eACA,EACR;AAEJ,kBAAM,KAAK,GAAG;AAAA,cACZD,oBAAmBA,KAAI,IAAI,SAAS,CAAC,OAAOA,KAAI;AAAA,gBAC9C,GAAG,KAAK,aAAa,IAAI,SAAS;AAAA,cACpC,CAAC,KAAKA,KAAI,IAAI,OAAO,CAAC,IAAI,QAAQ,KAAK,EAAE;AAAA,YAC3C;AAAA,UACF,CAAC;AAED,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS;AAAA,YACT,KAAK,kBAAkB,SAAS,IAAI,IAAI,iBACtC,MAAM,QAAQ,MAAM,SAAS,CAAC,IAC1B,MAAM,SAAS,EAAE,KAAK,IAAI,IAC1B,MAAM,SAAS,CACrB,gBAAgB,KAAK,aAAa;AAAA,UACpC,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,OAAO,GAAG,YAAY;AACjD,oBAAc,KAAK,iBAAiB;AAEpC,YAAM,KAAK,GACR,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,WAAW,EAAE,CAAC,EACpB,aAAa,EACb,iBAAiB;AAEpB,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK,+BAA+B,KAAK,aAAa;AAAA,MACxD,CAAC;AAED,YAAM,KAAK,WAAW,QAAQ;AAC9B,YAAM,KAAK,WAAW,QAAQ;AAC9B,YAAM,KAAK,OAAO,QAAQ;AAC1B,YAAM,KAAK,GAAG,QAAQ;AAEtB,YAAM,KAAK,aAAa,IAAI;AAC5B,YAAM,KAAK,aAAa,IAAI;AAC5B,YAAM,KAAK,SAAS,IAAI;AACxB,YAAM,KAAK,aAAa,IAAI;AAE5B,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK;AAAA,MACP,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,mBAAmB;AACvB,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,mBAAmB,GAAG,YAAY;AAE7D,YAAM,iBAAiB;AAAA,QACrB,QAAQ,KAAK;AAAA,QACb,IAAI,KAAK;AAAA,QACT,eAAe;AAAA,MACjB,CAAC;AAED,YAAM,WAAW,IAAI,SAAS;AAAA,QAC5B,IAAI,KAAK,GAAG,WAAW,IAAI,iBAAiB,aAAa,CAAC;AAAA,QAC1D,UAAU;AAAA,QACV,sBAAsB;AAAA,MACxB,CAAC;AAED,YAAM,EAAE,MAAM,IAAI,MAAM,SAAS,gBAAgB;AACjD,UAAI;AAAO,cAAM;AAAA,IACnB,CAAC;AAAA,EACH;AAAA,EAEQ,aACN,SACA,QACA,OACA;AACA,WAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,UAAI,YAAY,MAAM;AAAG;AACzB,UAAI,aAAa,MAAM;AAAG;AAC1B,UAAI,aAAa,MAAM,GAAG;AAExB,kBAAU,QAAQ,UAAU,YAAY,QAAQ,CAAC,QAAQ;AACvD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,cAAI,aAAa,MAAM,MAAM,OAAO;AAClC,kBAAM,IAAI;AAAA,cACRA,OAAMA,KAAI,IAAI,UAAU,CAAC,QAAQA,KAAI;AAAA,gBACnC,SAAS,MAAM,EAAE,OAAO,OAAO,CAAC,EAAE,IAAI,CAAC,MAAMA,KAAI,IAAI,CAAC,CAAC;AAAA,cACzD,CAAC;AAAA,YACH;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,QAAQ,CAAC,QAAQ;AACvD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,SAAS,CAAC,QAAQ;AACxD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,OAAO;AAEL,kBAAU,QAAQ;AAAA,UAChB;AAAA,UACA,gBAAgB,OAAO,SAAS,CAAC;AAAA,UACjC,CAAC,QAAQ;AACP,gBAAI,iBAAiB,MAAM,MAAM;AAAO,oBAAM,IAAI,QAAQ;AAC1D,gBAAI,eAAe;AAAM,oBAAM,IAAI,WAAW;AAC9C,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEQ,yBACN,SACA,OACA;AACA,WAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,UAAI,YAAY,MAAM;AAAG;AACzB,UAAI,aAAa,MAAM;AAAG;AAC1B,UAAI,aAAa,MAAM,GAAG;AAGxB,kBAAU,QAAQ,UAAU,YAAY,MAAM;AAAA,MAChD,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,MAAM;AAAA,MAChD,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,OAAO;AAAA,MACjD,OAAO;AAEL,kBAAU,QAAQ;AAAA,UAChB;AAAA,UACA,gBAAgB,OAAO,SAAS,CAAC;AAAA,UACjC,CAAC,QAAQ;AACP,gBAAI,eAAe;AAAM,oBAAM,IAAI,QAAQ;AAC3C,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,cAAU,QACP,UAAU,gBAAgB,UAAU,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACvE,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC;AAE3D,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAkB;AACxB,UAAM,UAAU;AAEhB,SAAK,OAAO,QAAQ,SAAS;AAAA,MAC3B;AAAA,IACF;AACA,SAAK,OAAO,QAAQ,8BAA8B,IAAIE,YAAW,QAAQ;AAAA,MACvE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,MAAM;AAAA,MACnB,WAAW,CAAC,KAAK,OAAO,QAAQ,QAAQ;AAAA,IAC1C,CAAC;AAED,SAAK,OAAO,QAAQ,SAAS;AAAA,MAC3B;AAAA,IACF;AACA,SAAK,OAAO,QAAQ,mCAAmC,IAAIA,YAAW;AAAA,MACpE;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,QACN,YAAY,CAAC,QAAQ,MAAM;AAAA,QAC3B,WAAW,CAAC,KAAK,OAAO,QAAQ,QAAQ;AAAA,QACxC,UAAU;AACR,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,OAAO;AAAA,YACjC,QAAQ,aAAa;AAAA,UACvB;AACA,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,QAAQ;AAAA,YAClC,QAAQ,aAAa;AAAA,UACvB;AAEA,eAAK,IAAI,EAAE,MAAM,QAAQ,MAAM,OAAO,GAAG,QAAQ,SAAS,SAAS;AACnE,eAAK;AAAA,YACH,EAAE,MAAM,QAAQ,MAAM,QAAQ;AAAA,YAC9B,QAAQ,SAAS;AAAA,UACnB;AAEA,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,OAAO;AAAA,YACjC,QAAQ,aAAa;AAAA,UACvB;AACA,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,QAAQ;AAAA,YAClC,QAAQ,aAAa;AAAA,UACvB;AAEA,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,OAAO;AAAA,YACjC,QAAQ,aAAa;AAAA,UACvB;AACA,eAAK;AAAA,YACH,EAAE,MAAM,YAAY,MAAM,QAAQ;AAAA,YAClC,QAAQ,aAAa;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,SAAK,OAAO,QAAQ,SAAS;AAAA,MAC3B;AAAA,IACF;AACA,SAAK,OAAO,QAAQ,mCAAmC,IAAIA,YAAW;AAAA,MACpE;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,QACN,YAAY,CAAC,MAAM;AAAA,QACnB,WAAW,CAAC,KAAK,OAAO,QAAQ,QAAQ;AAAA,QACxC,UAAU;AACR,eAAK,IAAI,EAAE,MAAM,WAAW,GAAG,QAAQ,aAAa,YAAY;AAChE,eAAK,IAAI,EAAE,MAAM,OAAO,GAAG,QAAQ,SAAS,YAAY;AACxD,eAAK,IAAI,EAAE,MAAM,WAAW,GAAG,QAAQ,aAAa,YAAY;AAChE,eAAK,IAAI,EAAE,MAAM,WAAW,GAAG,QAAQ,aAAa,YAAY;AAAA,QAClE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,kBAAkB;AAAA,EACtB,SAAS;AAAA,EACT,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,KAAK;AACP;;;AIr4BA,SAAS,cAAAC,aAAY,cAAc;AACnC,OAAOC,WAAU;;;ACAjB,SAAS,OAAAC,YAAW;AAEpB,IAAMC,cAAwC;AAAA,EAC5C,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,QAAQ,EACpB,UAAU,iBAAiB,MAAM,EACjC,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,gBAAgB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,mBAAmB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,oBAAoB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,cAAc,MAAM,EAC9B,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,eAAe,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,OAAO,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/C,UAAU,YAAY,MAAM,EAC5B,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC7D,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,gBAAgB,MAAM,EAChC,UAAU,wBAAwB,MAAM,EACxC,UAAU,SAAS,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7C,UAAU,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7C,UAAU,MAAM,MAAM,EACtB,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7C,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,MAAM,EAClB,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,eAAe,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,UAAU,MAAM,EAC1B,UAAU,mBAAmB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,eAAe,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,gCAAgC;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,qBAAqB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAGrD,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D,UAAU,cAAc,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,MAAM,EACT,QAAQ,CAAC,WAAW,WAAW,WAAW,CAAC,EAC3C,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,GAAG,QAAQ,EACX,QAAQ,CAAC,aAAa,QAAQ,CAAC,EAC/B,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,6BAA6B,EACzC,GAAG,uBAAuB,EAC1B,QAAQ,CAAC,WAAW,CAAC,EACrB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,MAAM,GAAG,IAAiB;AAExB,YAAM,GAAG,OAAO,UAAU,kBAAkB,EAAE,QAAQ;AACtD,YAAM,GAAG,OAAO,UAAU,cAAc,EAAE,QAAQ;AAGlD,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,MAAM,EACT,OAAO,WAAW,EAClB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,MAAM,EACT,OAAO,QAAQ,EACf,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,GAAG,QAAQ,EACX,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,WAAW,QAAQ,EAAE,WAAW,WAAW,EAAE,QAAQ;AACrE,YAAM,GAAG,OACN,WAAW,cAAc,EACzB,WAAW,WAAW,EACtB,QAAQ;AACX,YAAM,GAAG,OAAO,WAAW,MAAM,EAAE,WAAW,WAAW,EAAE,QAAQ;AACnE,YAAM,GAAG,OACN,WAAW,qBAAqB,EAChC,WAAW,WAAW,EACtB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,gCAAgC;AAAA,IAC9B,MAAM,GAAG,IAAiB;AAExB,YAAM,GAAG,OAAO,UAAU,uBAAuB,EAAE,QAAQ;AAG3D,YAAM,GAAG,OAAO,UAAU,QAAQ,EAAE,QAAQ;AAC5C,YAAM,GAAG,OACN,YAAY,QAAQ,EACpB,UAAU,iBAAiB,aAAa,EACxC,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACpE,UAAU,aAAa,gBAAgB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,UAAU,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,gBAAgB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnE,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,QAAQ,EACX,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,cAAc,EAAE,QAAQ;AAClD,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,cAAc,MAAM,EAC9B,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,OAAO,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,YAAY,aAAa,EACnC,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACpE,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,gBAAgB,aAAa,EACvC,UAAU,wBAAwB,aAAa,EAC/C,UAAU,SAAS,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,KAAK,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,MAAM,aAAa,EAC7B,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,KAAK,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,MAAM,EAAE,QAAQ;AAC1C,YAAM,GAAG,OACN,YAAY,MAAM,EAClB,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,MAAM,EACT,OAAO,WAAW,EAClB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,iBAAiB,EAC7B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,iBAAiB,EAC7B,GAAG,MAAM,EACT,OAAO,SAAS,EAChB,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,gBAAgB,EAC5B,GAAG,MAAM,EACT,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,QAAQ;AACzD,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,gCAAgC;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,YAAY,EACxB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,aAAa,EAClC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D;AAAA,QAAU;AAAA,QAAe;AAAA,QAAQ,CAAC,QACjC,IAAI,QAAQ,EAAE,WAAW,eAAe;AAAA,MAC1C,EACC,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,+BAA+B,EAC3C,GAAG,oBAAoB,EACvB,OAAO,aAAa,EACpB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,WAAW,EACvB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,iBAAiB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,wBAAwB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,2BAA2B,EACvC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D;AAAA,QAAU;AAAA,QAAa;AAAA,QAAQ,CAAC,QAC/B,IAAI,QAAQ,EAAE,WAAW,cAAc;AAAA,MACzC,EACC,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oCAAoC,EAChD,GAAG,2BAA2B,EAC9B,OAAO,WAAW,EAClB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,qCAAqC;AAAA,IACnC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,QAAQ;AAUzD,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,UAAU,WAAW,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,wBAAwB,8BAA8B;AAAA,QACrD;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC,EACA,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,sCAAsC;AAAA,IACpC,MAAM,GAAG,IAAiB;AAQxB,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,UAAU,qBAAqB,aAAa,EAC5C,QAAQ;AACX,YAAM,GACH,YAAY,QAAQ,EACpB,IAAI,CAAC,QAAa;AAAA,QACjB,mBAAmB,GAAG,WAAW,QAAQ,EAAE,OAAO,SAAS;AAAA,MAC7D,EAAE,EACD,QAAQ;AACX,YAAM,GAAG,OAAO,WAAW,QAAQ,EAAE,WAAW,SAAS,EAAE,QAAQ;AACnE,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,aAAa,qBAAqB,SAAS,EAC3C,QAAQ;AAGX,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,UAAU,mBAAmB,aAAa,EAC1C,QAAQ;AACX,YAAM,GACH,YAAY,QAAQ,EACpB,IAAI,CAAC,QAAa;AAAA,QACjB,iBAAiB,GAAG,WAAW,QAAQ,EAAE,OAAO,OAAO;AAAA,MACzD,EAAE,EACD,QAAQ;AACX,YAAM,GAAG,OAAO,WAAW,QAAQ,EAAE,WAAW,OAAO,EAAE,QAAQ;AACjE,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,aAAa,mBAAmB,OAAO,EACvC,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,2CAA2C;AAAA,IACzC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,4BAA4B,EACxC,GAAG,MAAM,EACT,OAAO,iBAAiB,EACxB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,kDAAkD;AAAA,IAChD,MAAM,GAAG,IAAiB;AACxB,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,IAAiB;AACxB,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,KAAkB;AAEzB;AAAA,IACF;AAAA,EACF;AAAA,EACA,mCAAmC;AAAA,IACjC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OAAO,UAAU,kBAAkB,EAAE,SAAS,EAAE,QAAQ;AACjE,YAAM,GAAG,OAAO,UAAU,qBAAqB,EAAE,SAAS,EAAE,QAAQ;AAEpE,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,MAAM,EACT,OAAO,aAAa,EACpB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,gDAAgD;AAAA,IAC9C,MAAM,GAAG,IAAiB;AACxB,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,oDAAoD;AAAA,IAClD,MAAM,GAAG,IAAiB;AACxB,UAAI,MAAM,iBAAiB,EAAE,GAAG;AAC9B;AAAA,MACF;AACA,YAAM,GAAG,OACN,WAAW,MAAM,EACjB,UAAU,cAAc,aAAa,EACrC,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,6CAA6C;AAAA,IAC3C,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG;AAAA,QACPD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAYA,QAAQ,EAAE;AAAA,MACZ;AAEA,YAAM,GAAG;AAAA,QACPA;AAAA;AAAA;AAAA;AAAA;AAAA,QAKA,QAAQ,EAAE;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAAA,EACA,yCAAyC;AAAA,IACvC,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,uBAAuB,EACnC,YAAY,EACZ,GAAG,MAAM,EACT,OAAO,YAAY,EACnB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,qCAAqC;AAAA,IACnC,MAAM,GAAG,IAAiB;AAExB,YAAM,GAAG,aAAaA,8BAA6B,QAAQ,EAAE,CAAC;AAI9D,YAAM,GAAG,OACN,WAAW,YAAY,EACvB,SAAS,iBAAiB,EAC1B,QAAQ;AACX,YAAM,GACH,YAAY,iBAAiB,EAC7B,IAAI,EAAE,IAAIA,mBAAkB,CAAC,EAC7B,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,iBAAiB,EAC5B;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ,EAAE,UAAU,CAAC;AAAA,MAC3B,EACC,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,oBAAoB,EAC/B,SAAS,yBAAyB,EAClC,QAAQ;AACX,YAAM,GACH,YAAY,yBAAyB,EACrC,IAAI,EAAE,aAAaA,4BAA2B,CAAC,EAC/C,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,YAAY,EAExB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,aAAa,EAClC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ;AAAA,MACd,EACC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,oBAAoB,EAChC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAE9D,UAAU,eAAe,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AAEX,YAAM,GAAG;AAAA,QACPA,+DAA8D;AAAA,UAC5D;AAAA,QACF;AAAA,MACF;AACA,YAAM,GAAG;AAAA,QACPA,+EAA8E;AAAA,UAC5E;AAAA,QACF;AAAA,MACF;AAEA,YAAM,GAAG,OAAO,UAAU,iBAAiB,EAAE,QAAQ;AACrD,YAAM,GAAG,OAAO,UAAU,yBAAyB,EAAE,QAAQ;AAE7D,YAAM,GAAG,OACN,YAAY,+BAA+B,EAC3C,GAAG,oBAAoB,EACvB,OAAO,aAAa,EACpB,QAAQ;AAGX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB,SAAS,gBAAgB,EACzB,QAAQ;AACX,YAAM,GACH,YAAY,gBAAgB,EAC5B,IAAI,EAAE,IAAIA,mBAAkB,CAAC,EAC7B,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,gBAAgB,EAC3B;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ,EAAE,UAAU,CAAC;AAAA,MAC3B,EACC,QAAQ;AACX,YAAM,GAAG,OACN,WAAW,2BAA2B,EACtC,SAAS,gCAAgC,EACzC,QAAQ;AACX,YAAM,GACH,YAAY,gCAAgC,EAC5C,IAAI,EAAE,WAAWA,0BAAyB,CAAC,EAC3C,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,WAAW,EAEvB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,iBAAiB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,wBAAwB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC,UAAU,UAAU,aAAa,EACjC;AAAA,QAAU;AAAA,QAA8B;AAAA,QAAW,CAAC,QACnD,IAAI,QAAQ;AAAA,MACd,EACC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,2BAA2B,EACvC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAE9D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG;AAAA,QACPA,6DAA4D,QAAQ,EAAE;AAAA,MACxE;AACA,YAAM,GAAG;AAAA,QACPA,6FAA4F;AAAA,UAC1F;AAAA,QACF;AAAA,MACF;AACA,YAAM,GAAG,OAAO,UAAU,gBAAgB,EAAE,QAAQ;AACpD,YAAM,GAAG,OAAO,UAAU,gCAAgC,EAAE,QAAQ;AACpE,YAAM,GAAG,OACN,YAAY,oCAAoC,EAChD,GAAG,2BAA2B,EAC9B,OAAO,WAAW,EAClB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,mBAAmB,aAAa,EAC1C,UAAU,qBAAqB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpE,UAAU,qBAAqB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpE,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,UAAU,aAAa,gBAAgB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,UAAU,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClD,UAAU,MAAM,aAAa,EAC7B;AAAA,QAAU;AAAA,QAAmB;AAAA,QAAe,CAAC,QAC5C,IAAI,QAAQ,EAAE,WAAW;AAAA,MAC3B,EACC,UAAU,oBAAoB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,QAAQ,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChD,QAAQ;AAEX,YAAM,GAAG,aAAaA,8BAA6B,QAAQ,EAAE,CAAC;AAAA,IAChE;AAAA,EACF;AAAA,EACA,8BAA8B;AAAA,IAC5B,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,YAAY,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,UAAU,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D;AAAA,QAAU;AAAA,QAAiB;AAAA,QAAQ,CAAC,QACnC,IAAI,QAAQ,EAAE,WAAW,iBAAiB;AAAA,MAC5C,EACC,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mCAAmC,EAC/C,GAAG,sBAAsB,EACzB,OAAO,eAAe,EACtB,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,QAAQ,EACnB,UAAU,cAAc,aAAa,EACrC,QAAQ;AACX,YAAM,GAAG;AAAA,QACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWE,QAAQ,EAAE;AAAA,MACd;AACA,YAAM,GAAG;AAAA,QACPA;AAAA;AAAA;AAAA;AAAA;AAAA,UAKE,QAAQ,EAAE;AAAA,MACd;AAEA,YAAM,GAAG,OAAO,WAAW,QAAQ,EAAE,SAAS,aAAa,EAAE,QAAQ;AAErE,YAAM,GAAG,OACN,YAAY,QAAQ,EACpB,UAAU,iBAAiB,aAAa,EACxC,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACpE,UAAU,aAAa,gBAAgB,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,UAAU,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,gBAAgB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC/D,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,QAAQ;AAEX,YAAM,GAAG;AAAA,QACPA,uDAAsD,QAAQ,EAAE;AAAA,MAClE;AAEA,YAAM,GAAG,OAAO,UAAU,aAAa,EAAE,QAAQ;AAGjD,YAAM,GAAG,OACN,YAAY,kBAAkB,EAC9B,GAAG,QAAQ,EACX,OAAO,QAAQ,EACf,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,QAAQ,EACX,OAAO,SAAS,EAChB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,QAAQ,EACX,OAAO,YAAY,EACnB,QAAQ;AAAA,IACb;AAAA,EACF;AAAA,EACA,4CAA4C;AAAA,IAC1C,MAAM,GAAG,IAAiB;AACxB,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AACD,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,8BAA8B;AAAA,IAC5B,MAAM,GAAG,IAAiB;AAGxB,YAAM,GAAG,OACN,YAAY,cAAc,EAC1B,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,eAAe,aAAa,EACtC,UAAU,aAAa,aAAa,EACpC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D,UAAU,iBAAiB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACzD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,mCAAmC,EAC/C,GAAG,sBAAsB,EACzB,OAAO,eAAe,EACtB,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,YAAY,EACxB,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD,UAAU,QAAQ,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACvD,UAAU,OAAO,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,SAAS,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACjD,UAAU,MAAM,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACrD,UAAU,SAAS,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,aAAa,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC5D,UAAU,eAAe,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC9D,UAAU,SAAS,MAAM,EACzB,UAAU,WAAW,aAAa,EAClC,UAAU,UAAU,MAAM,EAC1B,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,gBAAgB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,mBAAmB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,uBAAuB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAClE,UAAU,oBAAoB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnE,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,4BAA4B,EACxC,GAAG,YAAY,EACf,OAAO,aAAa,EACpB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,iCAAiC,EAC7C,GAAG,YAAY,EACf,OAAO,kBAAkB,EACzB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,sBAAsB,EAClC,GAAG,YAAY,EACf,OAAO,OAAO,EACd,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,0BAA0B,EACtC,GAAG,YAAY,EACf,OAAO,WAAW,EAClB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,gCAAgC,EAC5C,GAAG,YAAY,EACf,OAAO,iBAAiB,EACxB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,2BAA2B,EACvC,GAAG,YAAY,EACf,OAAO,YAAY,EACnB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,wBAAwB,EACpC,GAAG,YAAY,EACf,OAAO,SAAS,EAChB,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,GAAG,YAAY,EACf,OAAO,MAAM,EACb,QAAQ;AAGX,YAAM,GAAG,OACN,YAAY,mBAAmB,EAC/B,GAAG,YAAY,EACf,OAAO,IAAI,EACX,QAAQ;AAEX,YAAM,GAAG,OACN,WAAW,WAAW,EACtB,SAAS,mBAAmB,EAC5B,QAAQ;AAEX,YAAM,GAAG,OACN,YAAY,qBAAqB,EACjC,UAAU,MAAM,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC3D,UAAU,WAAW,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACtD,UAAU,WAAW,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC1D,UAAU,iBAAiB,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,wBAAwB,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAChE,UAAU,eAAe,aAAa,EACtC,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,6BAA6B,EACzC,UAAU,MAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAC9D,UAAU,aAAa,MAAM,EAC7B,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,YAAY,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,QAAQ;AACX,YAAM,GAAG,OACN,YAAY,sCAAsC,EAClD,GAAG,6BAA6B,EAChC,OAAO,WAAW,EAClB,QAAQ;AAAA,IACb;AAAA,EACF;AACF;AAEA,eAAe,iBAAiB,IAAiB;AAC/C,QAAM,MAAM,MAAM,GAAG,aAAaA,gCAA+B,QAAQ,EAAE,CAAC;AAC5E,SAAO,IAAI,KAAK,KAAK,CAAC,MAAW,EAAE,SAAS,YAAY;AAC1D;AAEA,IAAM,oBAAoB,OAAO;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAOM;AACJ,QAAM,WAAW,GAAG,MAAM;AAE1B,QAAM,GAAG,OAAO,WAAW,KAAK,EAAE,UAAU,UAAU,UAAU,EAAE,QAAQ;AAC1E,QAAM,GACH,YAAY,KAAK,EACjB,IAAI,CAAC,QAAa,EAAE,CAAC,QAAQ,GAAG,GAAG,WAAW,KAAK,EAAE,OAAO,MAAM,EAAE,EAAE,EACtE,QAAQ;AACX,QAAM,GAAG,OAAO,WAAW,KAAK,EAAE,WAAW,MAAM,EAAE,QAAQ;AAC7D,QAAM,GAAG,OAAO,WAAW,KAAK,EAAE,aAAa,UAAU,MAAM,EAAE,QAAQ;AAC3E;AAEA,IAAME,2BAAN,MAA2D;AAAA,EACzD,MAAM,gBAAgB;AACpB,WAAOD;AAAA,EACT;AACF;AAEO,IAAME,qBAAoB,IAAID,yBAAwB;;;ACp/B7D,OAAO,mBAAmB;;;ACA1B,SAAS,cAAAE,aAAY,aAAAC,kBAAiB;AACtC,OAAOC,WAAU;AAEV,IAAM,kBAAkB,CAAC,aAAqB;AACnD,QAAMC,WAAUD,MAAK,QAAQ,QAAQ;AACrC,MAAIF,YAAWG,QAAO,GAAG;AACvB;AAAA,EACF;AACA,EAAAF,WAAUE,UAAS,EAAE,WAAW,KAAK,CAAC;AACxC;;;ADJA,SAAS,oBAAoB,UAAkC;AAC7D,QAAM,kBAAkB,SAAS;AAEjC,WAAS,UAAU,CAAC,WAAmB;AACrC,QAAI;AACJ,QAAI;AACF,kBAAY,gBAAgB,MAAM,UAAU,CAAC,MAAM,CAAC;AAAA,IACtD,SAAS,QAAQ;AAEf,YAAM,QAAQ;AACd,YAAM,OAAO;AACb,YAAM,kBAAkB,KAAK;AAE7B,YAAM,eAAe,CAAC;AACtB,UAAI,MAAM;AAAQ,qBAAa,KAAK;AAAA,IAAc,MAAM,MAAM,EAAE;AAChE,mBAAa,KAAK;AAAA,IAAiB,MAAM,EAAE;AAC3C,YAAM,OAAO,aAAa,KAAK,IAAI;AAEnC,YAAM;AAAA,IACR;AAEA,UAAM,UACJ,CAAC,OACD,IAAI,SAAc;AAChB,UAAI;AACF,eAAO,GAAG,MAAM,WAAW,IAAI;AAAA,MACjC,SAAS,QAAQ;AACf,cAAM,QAAQ;AACd,cAAM,OAAO;AAEb,YAAI,aAAc,KAAK,CAAC,KAAK,CAAC;AAC9B,qBACE,WAAW,UAAU,KACjB,aACA,WAAW,MAAM,GAAG,EAAE,EAAE,OAAO,CAAC,KAAK,CAAC;AAC5C,cAAM,SAAS,WAAW;AAAA,UACxB,CAAC,KAAK,WAAW,QAAQ;AACvB,gBAAI,MAAM,CAAC,IAAI;AACf,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,eAAe,CAAC;AACtB,YAAI,MAAM;AAAQ,uBAAa,KAAK;AAAA,IAAc,MAAM,MAAM,EAAE;AAChE,qBAAa,KAAK;AAAA,IAAiB,MAAM,EAAE;AAC3C,qBAAa,KAAK;AAAA,EAAgB,YAAY,MAAM,CAAC,EAAE;AAEvD,cAAM,OAAO,aAAa,KAAK,IAAI;AAEnC,cAAM;AAAA,MACR;AAAA,IACF;AAEF,eAAW,UAAU,CAAC,OAAO,OAAO,KAAK,GAAG;AAE1C,gBAAU,MAAM,IAAI,QAAQ,UAAU,MAAM,CAAC;AAAA,IAC/C;AAEA,WAAO;AAAA,EACT;AACF;AAIO,SAAS,qBACd,MACA,SACgB;AAChB,kBAAgB,IAAI;AACpB,QAAM,WAAW,IAAI,cAAc,MAAM,OAAO;AAChD,sBAAoB,QAAQ;AAC5B,WAAS,OAAO,oBAAoB;AACpC,SAAO;AACT;;;AFnDA;AAAA,EAIE,YAAAC;AAAA,EACA;AAAA,EAEA,oBAAAC;AAAA,EACA,OAAAC;AAAA,OACK;AACP,OAAOC,iBAAgB;;;AItCvB,OAA4B;AAC5B,OAAuD;AAEvD,IAAMC,cAAwC;AAAA,EAC5C,wBAAwB;AAAA,IACtB,MAAM,GAAG,IAAiB;AACxB,YAAM,GAAG,OACN,YAAY,gBAAgB,EAC5B,YAAY,EACZ,UAAU,aAAa,QAAQ,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EAClE,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACxD,UAAU,gBAAgB,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC3D,UAAU,YAAY,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACpD;AAAA,QAAU;AAAA,QAAwB;AAAA,QAAe,CAAC,QACjD,IAAI,QAAQ;AAAA,MACd,EACC,UAAU,UAAU,SAAS,CAAC,QAAQ,IAAI,QAAQ,CAAC,EACnD,QAAQ;AAAA,IACb;AAAA,EACF;AACF;AAEA,IAAMC,2BAAN,MAA2D;AAAA,EACzD,MAAM,gBAAgB;AACpB,WAAOD;AAAA,EACT;AACF;AAEO,IAAME,qBAAoB,IAAID,yBAAwB;;;AJgBtD,IAAM,wBAAN,MAA2D;AAAA,EAChE,OAAO;AAAA,EAEC;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAER;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEQ,UAAkB;AAAA,EAClB;AAAA,EAER,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA,gBAAgB;AAAA,EAClB,GAIG;AACD,SAAK,SAAS;AACd,SAAK,YAAY;AAEjB,SAAK,sBAAsB;AAE3B,SAAK,gBAAgB;AACrB,UAAM,mBAAmBE,MAAK,KAAK,WAAW,GAAG,aAAa,KAAK;AAMnE,SAAK,oBAAoB;AACzB,UAAM,uBAAuBA,MAAK,KAAK,WAAW,WAAW;AAE7D,SAAK,mBAAmB,qBAAqB,oBAAoB;AACjE,SAAK,iBAAiB;AAAA,MACpB,oBAAoB,gBAAgB,QAAQ,KAAK,aAAa;AAAA,IAChE;AAEA,SAAK,KAAK,IAAI,eAA+B;AAAA,MAC3C,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,cAAc,EAAE,UAAU,KAAK,iBAAiB,CAAC;AAAA,MAC9D,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,0BAA0B,IAAI;AAAA,YAC3C,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,mBAAmBA,MAAK,KAAK,WAAW,gBAAgB;AAC9D,SAAK,eAAe,qBAAqB,gBAAgB;AACzD,SAAK,SAAS,IAAI,eAAgC;AAAA,MAChD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,cAAc,EAAE,UAAU,KAAK,aAAa,CAAC;AAAA,MAC1D,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,0BAA0B,IAAI,EAAE,UAAU,OAAO,CAAC;AAAA,QACnE;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,aAAa,IAAI,eAA+B;AAAA,MACnD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,cAAc,EAAE,UAAU,KAAK,iBAAiB,CAAC;AAAA,MAC9D,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,0BAA0B,IAAI;AAAA,YAC3C,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,aAAa,IAAI,eAA+B;AAAA,MACnD,MAAM;AAAA,MACN;AAAA,MACA,SAAS,IAAI,cAAc,EAAE,UAAU,KAAK,iBAAiB,CAAC;AAAA,MAC9D,IAAI,OAAO;AACT,YAAI,MAAM,UAAU,SAAS;AAC3B,iBAAO,QAAQ,0BAA0B,IAAI;AAAA,YAC3C,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,MAAM,MAAM,EAAE,QAAQ,QAAQ,GAAwC;AACpE,SAAK,UAAU;AAEf,UAAM,WAAW,IAAIC,UAAS;AAAA,MAC5B,IAAI,KAAK,GAAG,WAAW,IAAIC,kBAAiB,KAAK,iBAAiB,CAAC;AAAA,MACnE,UAAUC;AAAA,IACZ,CAAC;AACD,UAAM,SAAS,MAAM,SAAS,gBAAgB;AAC9C,QAAI,OAAO;AAAO,YAAM,OAAO;AAE/B,UAAM,gBAAgB;AAAA,MACpB,eAAe,KAAK;AAAA,MACpB,mBAAmB,KAAK;AAAA,MACxB,kBAAkB,OAAO,KAAK,UAAU,MAAM,CAAC,EAAE;AAAA,QAC/C,CAAC,KAAK,cAAc;AAClB,cAAI,SAAS,IAAI,KAAK,CAAC,KAAK,eAAe,KAAK,SAAS,SAAS,CAAC;AACnE,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,QAAQ,GAAG,YAAY;AACnD,YAAM,eAAe,YAAY;AAC/B,eAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,gBAAM,kBAAkB,MAAM,GAC3B,WAAW,KAAK,iBAAiB,EACjC,WAAW,gBAAgB,EAC3B,UAAU,EACV,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,iBAAiB;AAEpB,gBAAM,aAAa;AAAA,YACjB,WAAW,KAAK;AAAA,YAChB,WAAW;AAAA,YACX,cAAc,KAAK,IAAI;AAAA,YACvB,UAAU,KAAK;AAAA,YACf,sBAAsB,iBAAiB,cAAc;AAAA;AAAA;AAAA,YAGrD,QAAQ,aAAa,MAAM;AAAA,UAC7B;AAGA,gBAAM,eAAe,YAAY;AAC/B,uBAAW,CAAC,WAAW,KAAK,KAAK,OAAO;AAAA,cACtC,UAAU,MAAM;AAAA,YAClB,GAAG;AACD,oBAAM,UAAU,cAAc,iBAAiB,SAAS;AAExD,oBAAM,GAAG,OACN,WAAW,KAAK,iBAAiB,EACjC,YAAY,OAAO,EACnB;AAAA,gBAAM,CAAC,YACN,KAAK,yBAAyB,SAAS,MAAM,KAAK;AAAA,cACpD,EACC,QAAQ;AAEX,oBAAM,GAAG,OACN,YAAY,GAAG,OAAO,kBAAkB,EACxC,GAAG,OAAO,EACV,OAAO,YAAY,EACnB,QAAQ;AAEX,kBAAI;AACF,sBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,YAAY,SAAS,EACrB;AAAA,kBAAM,CAAC,YACN,KAAK,aAAa,SAAS,QAAQ,MAAM,KAAK;AAAA,gBAChD,EACC,QAAQ;AAAA,cACb,SAAS,KAAK;AACZ,sBAAM,QAAQ;AACd,oBAAI,CAAC,MAAM,QAAQ,SAAS,gBAAgB;AAAG,wBAAM;AACrD,sBAAM,IAAI;AAAA,kBACR,2BAA2B,SAAS,SAAS,KAAK,aAAa,+FAA+F,KAAK,aAAa;AAAA,gBAClL;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,kBAAkB,SAAS,SAAS,KAAK,aAAa;AAAA,cAC7D,CAAC;AAAA,YACH;AAAA,UACF;AAGA,cAAI,oBAAoB,QAAW;AACjC,kBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,WAAW,gBAAgB,EAC3B,OAAO,UAAU,EACjB,QAAQ;AACX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,mCAAmC,KAAK,aAAa;AAAA,YAC5D,CAAC;AAED,kBAAM,aAAa;AAEnB,mBAAO,EAAE,QAAQ,WAAW,YAAY,eAAe;AAAA,UACzD;AAGA,gBAAM,YACJ,gBAAgB,eAChB,KAAK,OAAO,QAAQ;AAEtB,cAAI,gBAAgB,cAAc,KAAK,KAAK,IAAI,KAAK,WAAW;AAC9D,kBAAM,cAAc,YAAY,KAAK,IAAI;AACzC,mBAAO,EAAE,QAAQ,UAAU,YAAY;AAAA,UACzC;AAKA,cACE,KAAK,OAAO,QAAQ,YAAY,WAChC,gBAAgB,aAAa,KAAK,WAClC,gBAAgB,yBACd,iBAAiB,cAAc,GACjC;AACA,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,iCACH,KAAK,OACP,uBACE,KAAK,aACP,oBAAoB;AAAA,gBAClB,KAAK,IAAI,IAAI,gBAAgB;AAAA,cAC/B,CAAC;AAAA,YACH,CAAC;AAID,uBAAW,CAAC,WAAW,KAAK,KAAK,OAAO;AAAA,cACtC,UAAU,MAAM;AAAA,YAClB,GAAG;AACD,kBAAI,MAAM,gBAAgB;AAAW;AAErC,yBAAW,QAAQ,OAAO,KAAK,MAAM,WAAW,GAAG;AACjD,sBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,UAAU,GAAG,SAAS,IAAI,IAAI,EAAE,EAChC,SAAS,EACT,QAAQ;AAEX,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,kBAAkB,SAAS,IAAI,IAAI,gBAAgB,KAAK,aAAa;AAAA,gBAC5E,CAAC;AAAA,cACH;AAAA,YACF;AAEA,kBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,IAAI,EAAE,WAAW,GAAG,cAAc,KAAK,IAAI,EAAE,CAAC,EAC9C,QAAQ;AACX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,4BAA4B,KAAK,aAAa;AAAA,YACrD,CAAC;AAED,kBAAMC,uBAAsB;AAAA,cAC1B,gBAAgB;AAAA,YAClB;AAEA,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,iEAAiEA,qBAAoB,cAAc,YAAYA,qBAAoB,OAAO,UAAUA,qBAAoB,WAAW;AAAA,YAC1L,CAAC;AAGD,kBAAM,MAAM;AACZ,uBAAW,CAAC,WAAW,OAAO,KAAK,OAAO;AAAA,cACxC,cAAc;AAAA,YAChB,GAAG;AACD,oBAAM,OAAO,MAAM,IAChB,WAAW,cAAc,iBAAiB,EAC1C,WAAW,OAAO,EAClB,aAAa,EACb,MAAM,cAAc,KAAK,gBAAgB,oBAAoB,EAC7D,QAAQ;AAEX,oBAAM,WAAW,KAAK;AAAA,gBACpB,CAAC,GAAG,MAAM,EAAE,eAAe,EAAE;AAAA,cAC/B;AAEA,yBAAW,OAAO,UAAU;AAC1B,oBAAI,IAAI,cAAc,GAAG;AAEvB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,gBACb,WAAW,IAAI,cAAc,GAAG;AAE9B,sBAAI,eAAe;AACnB,sBAAI,aAAa;AACjB,sBAAI,YAAY;AAChB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,GAAG,EACP,MAAM,MAAM,KAAK,IAAI,EAAE,EACvB,QAAQ;AAAA,gBACb,OAAO;AAEL,sBAAI,eAAe;AACnB,sBAAI,aAAa;AACjB,sBAAI,YAAY;AAChB,wBAAM,IACH,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,GAAG,EACV,QAAQ;AAAA,gBACb;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,YAAY,KAAK,MAAM,0CAA0C,SAAS;AAAA,cACjF,CAAC;AAAA,YACH;AAEA,mBAAO;AAAA,cACL,QAAQ;AAAA,cACR,YAAYA;AAAA,YACd;AAAA,UACF;AAIA,gBAAM,kBAAkB,gBAAgB;AAGxC,gBAAM,iBAAiB,KAAK,MAAM,gBAAgB,MAAM;AAKxD,gBAAM,GACH,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,UAAU,EACd,QAAQ;AAEX,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,4BAA4B,KAAK,aAAa,+BAA+B,eAAe;AAAA,UACnG,CAAC;AAED,qBAAW,aAAa,OAAO,KAAK,eAAe,MAAM,GAAG;AAC1D,kBAAM,UAAU,KAAK;AAAA,cACnB,KAAK;AAAA,cACL;AAAA,cACA;AAAA,YACF,CAAC;AAED,kBAAM,GAAG,OACN,WAAW,KAAK,iBAAiB,EACjC,UAAU,OAAO,EACjB,SAAS,EACT,QAAQ;AAEX,kBAAM,GAAG,OACN,WAAW,KAAK,aAAa,EAC7B,UAAU,SAAS,EACnB,SAAS,EACT,QAAQ;AAEX,iBAAK,OAAO,OAAO,MAAM;AAAA,cACvB,SAAS;AAAA,cACT,KAAK,YAAY,SAAS;AAAA,YAC5B,CAAC;AAAA,UACH;AAEA,gBAAM,aAAa;AAEnB,iBAAO,EAAE,QAAQ,WAAW,YAAY,eAAe;AAAA,QACzD,CAAC;AAAA,MACH;AAEA,YAAMC,UAAS,MAAM,aAAa;AAElC,UAAI;AAEJ,UAAIA,QAAO,WAAW,WAAW;AAC/B,8BAAsBA,QAAO;AAAA,MAC/B,OAAO;AAEL,cAAM,EAAE,YAAY,IAAIA;AACxB,aAAK,OAAO,OAAO,KAAK;AAAA,UACtB,SAAS;AAAA,UACT,KAAK,kBAAkB,KAAK,aAAa;AAAA,QAC3C,CAAC;AACD,aAAK,OAAO,OAAO,KAAK;AAAA,UACtB,SAAS;AAAA,UACT,KAAK,WAAW,UAAU,WAAW,CAAC,+BACpC,KAAK,aACP;AAAA,QACF,CAAC;AAED,cAAM,KAAK,WAAW;AAEtB,cAAM,YAAY,MAAM,aAAa;AACrC,YAAI,UAAU,WAAW,UAAU;AACjC,gBAAM,IAAI;AAAA,YACR,4CAA4C,KAAK,aAAa;AAAA,UAChE;AAAA,QACF;AACA,8BAAsB,UAAU;AAAA,MAClC;AAGA,WAAK,oBAAoB,YAAY,YAAY;AAC/C,YAAI;AACF,gBAAM,UAAU,MAAM,KAAK,GACxB,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,cAAc,KAAK,IAAI,EAAE,CAAC,EAChC,aAAa,EACb,iBAAiB;AAEpB,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,kCAAkC,SAAS,YAAY,cAAc,KAAK,OAAO;AAAA,UACxF,CAAC;AAAA,QACH,SAAS,KAAK;AACZ,gBAAM,QAAQ;AACd,eAAK,OAAO,OAAO,MAAM;AAAA,YACvB,SAAS;AAAA,YACT,KAAK,qDAAqD;AAAA,cACxD,KAAK,OAAO,QAAQ;AAAA,YACtB,CAAC;AAAA,YACD;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,GAAG,KAAK,OAAO,QAAQ,yBAAyB;AAEhD,aAAO,EAAE,YAAY,qBAAqB,cAAc;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,OAAO;AAAA,IACX;AAAA,IACA;AAAA,EACF,GAGG;AACD,UAAM,qBAAqB;AAAA,MACzB,IAAI,KAAK;AAAA,MACT;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,0BAA0B;AAAA,IAC9B;AAAA,EACF,GAA8C;AAC5C,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACtE,YAAM,KAAK,GACR,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,sBAAsB,iBAAiB,UAAU,EAAE,CAAC,EAC1D,QAAQ;AAEX,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK,8CAA8C,WAAW,cAAc,YAAY,WAAW,OAAO,UAAU,WAAW,WAAW;AAAA,MAC5I,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,cAAc,EAAE,OAAO,GAAuB;AAClD,UAAM,QAAQ;AAAA,MACZ,OAAO,QAAQ,UAAU,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,WAAW,KAAK,MAAM;AAChE,YAAI,MAAM,gBAAgB;AAAW,iBAAO,CAAC;AAE7C,eAAO,OAAO,QAAQ,MAAM,WAAW,EAAE,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM;AACpE,gBAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,gBAAgB,GAAG,YAAY;AAC1D,kBAAM,YAAY,GAAG,SAAS,IAAI,IAAI;AAEtC,kBAAM,cAAc,MAAM,SAAS;AACnC,kBAAM,QAAQ,MAAM,QAAQ;AAE5B,kBAAM,UAAU,MAAM,QAAQ,WAAW,IACrC,YAAY,IAAI,CAAC,OAAO,IAAI,EAAE,GAAG,EAAE,KAAK,IAAI,IAC5C,IAAI,WAAW,KACb,UAAU,QAAQ,QAAQ,UAAU,SAAS,SAAS,EACxD;AAEJ,kBAAM,KAAK,GAAG;AAAA,cACZC,oBAAmBA,KAAI,IAAI,KAAK,aAAa,CAAC,IAAIA,KAAI;AAAA,gBACpD;AAAA,cACF,CAAC,OAAOA,KAAI,MAAM,SAAS,CAAC,KAAKA,KAAI,IAAI,OAAO,CAAC,IAAI;AAAA,gBACnD,KAAK;AAAA,cACP;AAAA,YACF;AAAA,UACF,CAAC;AAED,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS;AAAA,YACT,KAAK,kBAAkB,SAAS,IAAI,IAAI,iBACtC,MAAM,QAAQ,MAAM,SAAS,CAAC,IAC1B,MAAM,SAAS,EAAE,KAAK,IAAI,IAC1B,MAAM,SAAS,CACrB,SAAS,KAAK,aAAa;AAAA,UAC7B,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,OAAO,GAAG,YAAY;AACjD,oBAAc,KAAK,iBAAiB;AAEpC,YAAM,KAAK,GACR,WAAW,KAAK,iBAAiB,EACjC,YAAY,gBAAgB,EAC5B,MAAM,aAAa,KAAK,KAAK,aAAa,EAC1C,IAAI,EAAE,WAAW,EAAE,CAAC,EACpB,aAAa,EACb,iBAAiB;AAEpB,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK,+BAA+B,KAAK,aAAa;AAAA,MACxD,CAAC;AAED,YAAM,KAAK,WAAW,QAAQ;AAC9B,YAAM,KAAK,WAAW,QAAQ;AAC9B,YAAM,KAAK,OAAO,QAAQ;AAC1B,YAAM,KAAK,GAAG,QAAQ;AAEtB,WAAK,aAAa,MAAM;AACxB,WAAK,iBAAiB,MAAM;AAE5B,WAAK,OAAO,OAAO,MAAM;AAAA,QACvB,SAAS;AAAA,QACT,KAAK;AAAA,MACP,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,mBAAmB;AACvB,UAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,mBAAmB,GAAG,YAAY;AAC7D,YAAM,WAAW,IAAIL,UAAS;AAAA,QAC5B,IAAI,KAAK;AAAA,QACT,UAAUE;AAAA,MACZ,CAAC;AAED,YAAM,EAAE,MAAM,IAAI,MAAM,SAAS,gBAAgB;AACjD,UAAI;AAAO,cAAM;AAAA,IACnB,CAAC;AAAA,EACH;AAAA,EAEQ,aACN,SACA,QACA,OACA;AACA,WAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,UAAI,YAAY,MAAM;AAAG;AACzB,UAAI,aAAa,MAAM;AAAG;AAC1B,UAAI,aAAa,MAAM,GAAG;AAExB,kBAAU,QAAQ,UAAU,YAAY,QAAQ,CAAC,QAAQ;AACvD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,cAAI,aAAa,MAAM,MAAM,OAAO;AAClC,kBAAM,IAAI;AAAA,cACRG,OAAMA,KAAI,IAAI,UAAU,CAAC,QAAQA,KAAI;AAAA,gBACnC,SAAS,MAAM,EAAE,OAAO,OAAO,CAAC,EAAE,IAAI,CAAC,MAAMA,KAAI,IAAI,CAAC,CAAC;AAAA,cACzD,CAAC;AAAA,YACH;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,QAAQ,CAAC,QAAQ;AACvD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,SAAS,CAAC,QAAQ;AACxD,cAAI,iBAAiB,MAAM,MAAM;AAAO,kBAAM,IAAI,QAAQ;AAC1D,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,OAAO;AAEL,kBAAU,QAAQ;AAAA,UAChB;AAAA,UACAC,iBAAgB,OAAO,SAAS,CAAC;AAAA,UACjC,CAAC,QAAQ;AACP,gBAAI,iBAAiB,MAAM,MAAM;AAAO,oBAAM,IAAI,QAAQ;AAC1D,gBAAI,eAAe;AAAM,oBAAM,IAAI,WAAW;AAC9C,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEQ,yBACN,SACA,OACA;AACA,WAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,YAAY,MAAM,MAAM;AACtD,UAAI,YAAY,MAAM;AAAG;AACzB,UAAI,aAAa,MAAM;AAAG;AAC1B,UAAI,aAAa,MAAM,GAAG;AAGxB,kBAAU,QAAQ,UAAU,YAAY,MAAM;AAAA,MAChD,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,MAAM;AAAA,MAChD,WAAW,aAAa,MAAM,GAAG;AAE/B,kBAAU,QAAQ,UAAU,YAAY,OAAO;AAAA,MACjD,OAAO;AAEL,kBAAU,QAAQ;AAAA,UAChB;AAAA,UACAA,iBAAgB,OAAO,SAAS,CAAC;AAAA,UACjC,CAAC,QAAQ;AACP,gBAAI,eAAe;AAAM,oBAAM,IAAI,QAAQ;AAC3C,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,cAAU,QACP,UAAU,gBAAgB,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,WAAW,CAAC,EACxE,UAAU,cAAc,eAAe,CAAC,QAAQ,IAAI,QAAQ,CAAC,EAC7D,UAAU,aAAa,WAAW,CAAC,QAAQ,IAAI,QAAQ,CAAC;AAE3D,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAkB;AACxB,SAAK,OAAO,QAAQ,SAAS;AAAA,MAC3B;AAAA,IACF;AACA,SAAK,OAAO,QAAQ,4BAA4B,IAAIC,YAAW,QAAQ;AAAA,MACrE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY,CAAC,UAAU;AAAA,MACvB,WAAW,CAAC,KAAK,OAAO,QAAQ,QAAQ;AAAA,IAC1C,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,wBAAwB;AAEpC,UAAM,aAAaC,YAAWT,MAAK,KAAK,KAAK,WAAW,iBAAiB,CAAC;AAE1E,QAAI,CAAC;AAAY;AAEjB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAGD,WAAOA,MAAK,KAAK,KAAK,WAAW,iBAAiB,GAAG,EAAE,OAAO,KAAK,CAAC;AACpE,WAAOA,MAAK,KAAK,KAAK,WAAW,qBAAqB,GAAG,EAAE,OAAO,KAAK,CAAC;AACxE,WAAOA,MAAK,KAAK,KAAK,WAAW,qBAAqB,GAAG,EAAE,OAAO,KAAK,CAAC;AACxE,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAGD,WAAOA,MAAK,KAAK,KAAK,WAAW,WAAW,GAAG,EAAE,OAAO,KAAK,CAAC;AAC9D,WAAOA,MAAK,KAAK,KAAK,WAAW,eAAe,GAAG,EAAE,OAAO,KAAK,CAAC;AAClE,WAAOA,MAAK,KAAK,KAAK,WAAW,eAAe,GAAG,EAAE,OAAO,KAAK,CAAC;AAClE,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAAA,EACH;AACF;AAEA,IAAMO,mBAAkB;AAAA,EACtB,SAAS;AAAA,EACT,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,KAAK;AACP;;;AKtuBA,SAAS,OAAAG,YAAW;;;ACPb,IAAM,eACX;AAEK,IAAM,cACX,CAAC;AAUI,SAAS,aAAa,OAA8B;AACzD,MAAI,OAAO,UAAU,YAAY,OAAO,UAAU;AAChD,YAAQ,OAAO,KAAK;AAEtB,MAAI,QAAQ;AACV,UAAM,IAAI,MAAM,8CAA8C,KAAK,GAAG;AACxE,MAAI,QAAQ;AACV,UAAM,IAAI,MAAM,0CAA0C,KAAK,GAAG;AAEpE,QAAM,WAAW,SAAS,KAAK,MAAM;AAGrC,MAAI,QAAQ;AAAI,YAAQ,QAAQ;AAEhC,QAAM,QAAQ,MAAM,SAAS,EAAE;AAG/B,SAAO,WAAW,MAAM,SAAS,IAAI,GAAG;AAC1C;AAUO,SAAS,eAAe,MAAc;AAC3C,MAAI,OAAO,SAAS;AAAU,WAAO;AAErC,QAAM,WAAW,KAAK,GAAG,CAAC;AAC1B,MAAI,aAAa,KAAK,UAAU,CAAC,EAAE,QAAQ,OAAO,EAAE;AAEpD,MAAI,WAAW,WAAW;AAAG,iBAAa;AAC1C,MAAI,QAAQ,OAAO,UAAU;AAI7B,MAAI,aAAa;AAAK,YAAQ,QAAQ;AAEtC,SAAO;AACT;;;AChCA,SAAS,YAAY,YAAY,aAAa;AAE9C,IAAM,iBAAiB;AAAA,EACrB,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,KAAK;AACP;AAKO,SAAS,UACd,MACA,OACA,UACgB;AAChB,QAAM,WAA2B,CAAC;AAElC,aAAW,CAAC,YAAY,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AACtD,UAAM,SAAS,MAAM,UAAU;AAC/B,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI;AAAA,QACR,8CAA8C,UAAU,sBAAsB,OAAO;AAAA,UACnF;AAAA,QACF,EACG;AAAA,UACC,CAACC,YACC,eAAe,MAAMA,OAAM,CAAC,KAC5B,kBAAkB,MAAMA,OAAM,CAAC,KAC/B,aAAa,MAAMA,OAAM,CAAC,KAC1B,aAAa,MAAMA,OAAM,CAAC;AAAA,QAC9B,EACC,KAAK,IAAI,CAAC;AAAA,MACf;AAAA,IACF;AAEA,aAAS,UAAU,IAAI,YAAY,OAAO,QAAQ,QAAQ;AAAA,EAC5D;AAEA,SAAO;AACT;AAKO,SAAS,YACd,OACA,QACA,UACgB;AAChB,MAAI,aAAa,MAAM,GAAG;AACxB,QAAI,iBAAiB,MAAM,MAAM,UAAU,UAAa,UAAU,OAAO;AACvE,aAAO;AAAA,IACT;AAEA,QAAI,aAAa,MAAM,GAAG;AACxB,UAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,yBAAyB,OAAO,KAAK;AAAA,QAChE;AAAA,MACF;AAEA,aAAO,KAAK,UAAU,KAAK;AAAA,IAC7B,WAAW,OAAO,UAAU,UAAU;AACpC,YAAM,IAAI;AAAA,QACR,oBAAoB,KAAK,0BAA0B,OAAO,KAAK;AAAA,MACjE;AAAA,IACF;AACA,WAAO;AAAA,EACT,WAAW,aAAa,MAAM,GAAG;AAC/B,QAAI,aAAa;AAAY,aAAO;AAEpC,QAAI;AACF,aAAO,KAAK,UAAU,KAAK;AAAA,IAC7B,SAAS,QAAQ;AACf,YAAM,QAAQ,IAAI,yBAA0B,OAAqB,OAAO;AACxE,YAAM,KAAK;AAAA,QACT;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF,WAAW,eAAe,MAAM,KAAK,kBAAkB,MAAM,GAAG;AAC9D,QAAI,iBAAiB,MAAM,MAAM,UAAU,UAAa,UAAU,OAAO;AACvE,aAAO;AAAA,IACT;AAEA,QAAI,aAAa,MAAM,GAAG;AAExB,UAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,yBAAyB,OAAO,KAAK,wBAC5D,eAAe,OAAO,SAAS,CAAC,CAClC;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO,SAAS,MAAM,UAAU;AAClC,eAAO,KAAK,UAAU,MAAM,IAAI,MAAM,CAAC;AAAA,MACzC,WAAW,OAAO,SAAS,MAAM,OAAO;AACtC,eAAO,KAAK,UAAU,MAAM,IAAI,CAAC,MAAO,EAAa,YAAY,CAAC,CAAC;AAAA,MACrE,OAAO;AACL,eAAO,KAAK,UAAU,KAAK;AAAA,MAC7B;AAAA,IACF;AAEA,QAAI,OAAO,SAAS,MAAM,UAAU;AAClC,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,2BAA2B,OAAO,KAAK;AAAA,QAClE;AAAA,MACF;AACA,aAAO;AAAA,IACT,WAAW,OAAO,SAAS,MAAM,OAAO;AACtC,UAAI,OAAO,UAAU,YAAY,CAAC,MAAM,KAAK,GAAG;AAC9C,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,wBAAwB,OAAO,KAAK;AAAA,QAC/D;AAAA,MACF;AACA,aAAO,OAAO,KAAK,WAAW,KAAK,CAAC;AAAA,IACtC,WAAW,OAAO,SAAS,MAAM,OAAO;AACtC,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,yBAAyB,OAAO,KAAK;AAAA,QAChE;AAAA,MACF;AACA,aAAO;AAAA,IACT,WAAW,OAAO,SAAS,MAAM,SAAS;AACxC,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,0BAA0B,OAAO,KAAK;AAAA,QACjE;AAAA,MACF;AACA,aAAO;AAAA,IACT,WAAW,OAAO,SAAS,MAAM,UAAU;AACzC,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,2BAA2B,OAAO,KAAK;AAAA,QAClE;AAAA,MACF;AACA,aAAO,aAAa,WAAW,aAAa,KAAK,IAAI;AAAA,IACvD,WAAW,OAAO,SAAS,MAAM,WAAW;AAC1C,UAAI,OAAO,UAAU,WAAW;AAC9B,cAAM,IAAI;AAAA,UACR,oBAAoB,KAAK,4BAA4B,OAAO,KAAK;AAAA,QACnE;AAAA,MACF;AACA,aAAO,QAAQ,IAAI;AAAA,IACrB;AAGA,UAAM,IAAI;AAAA,MACR,oBAAoB,KAAK,YAAY,OAAO,SAAS,CAAC;AAAA,IACxD;AAAA,EACF;AAGA,QAAM,IAAI;AAAA,IACR,oBAAoB,KAAK,YACvB,aAAa,MAAM,IAAI,SAAS,KAClC,cACE,aAAa,MAAM,IAAI,SAAS,KAClC;AAAA,EACF;AACF;AAEO,SAAS,UACd,MACA,OACA,UACY;AACZ,QAAM,WAAW,CAAC;AAElB,aAAW,CAAC,YAAY,MAAM,KAAK,OAAO,QAAQ,KAAK,GAAG;AACxD,QACE,eAAe,MAAM,KACrB,kBAAkB,MAAM,KACxB,aAAa,MAAM,KACnB,aAAa,MAAM,GACnB;AACA,eAAS,UAAU,IAAI,YAAY,KAAK,UAAU,GAAG,QAAQ,QAAQ;AAAA,IACvE;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,YACP,OACA,QACA,UACY;AACZ,MAAI,UAAU;AAAM,WAAO;AAAA,WAClB,aAAa,MAAM,GAAG;AAC7B,QAAI,aAAa,MAAM,GAAG;AACxB,aAAO,KAAK,MAAM,KAAe;AAAA,IACnC;AACA,WAAO;AAAA,EACT,WAAW,aAAa,MAAM,GAAG;AAC/B,WAAO,aAAa,aAAa,QAAQ,KAAK,MAAM,KAAe;AAAA,EACrE,WAAW,aAAa,MAAM,GAAG;AAC/B,WAAO,OAAO,SAAS,MAAM,WACzB,KAAK,MAAM,KAAe,EAAE,IAAI,MAAM,IACtC,KAAK,MAAM,KAAe;AAAA,EAChC,WAAW,OAAO,SAAS,MAAM,WAAW;AAC1C,WAAO,UAAU,IAAI,OAAO;AAAA,EAC9B,WAAW,OAAO,SAAS,MAAM,OAAO;AACtC,WAAO,WAAW,KAAe;AAAA,EACnC,WAAW,OAAO,SAAS,MAAM,YAAY,aAAa,UAAU;AAClE,WAAO,eAAe,KAAe;AAAA,EACvC,OAAO;AACL,WAAO;AAAA,EACT;AACF;;;ACvOO,SAAS,gBAAgB,KAAc,MAA+B;AAC3E,MAAI,QAAQ,aAAa,GAAG;AAE5B,MAAI,MAAM,SAAS,SAAS,WAAW,GAAG;AACxC,YAAQ,IAAI;AAAA,MACV;AAAA,IACF;AAAA,EACF,WACE,MAAM,SAAS,SAAS,0BAA0B,KAClD,MAAM,SAAS,SAAS,4BAA4B,GACpD;AACA,YAAQ,IAAI,sBAAsB,MAAM,OAAO;AAC/C,UAAM,KAAK;AAAA,MACT;AAAA,IACF;AAAA,EACF,WACE,MAAM,SAAS,SAAS,4BAA4B,KACpD,MAAM,SAAS,SAAS,8BAA8B,GACtD;AACA,YAAQ,IAAI,uBAAuB,MAAM,OAAO;AAAA,EAClD,WACE,MAAM,SAAS,SAAS,yBAAyB,KACjD,MAAM,SAAS,SAAS,2BAA2B,GACnD;AACA,YAAQ,IAAI,qBAAqB,MAAM,OAAO;AAAA,EAChD,WAAW,MAAM,SAAS,SAAS,uCAAuC,GAAG;AAC3E,YAAQ,IAAI,yBAAyB,MAAM,OAAO;AAClD,UAAM,KAAK;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAGA,MAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,UAAM,KAAK,KAAK,EAAE;AAAA,EACpB;AAEA,QAAM,KAAK,KAAK;AAAA,EAA4B,YAAY,IAAI,CAAC,EAAE;AAE/D,SAAO;AACT;;;AChCA,IAAM,oBAAoB;AAAA,EACxB,SAAS;AAAA,IACP,UAAU,CAAC,UAAU,OAAO,MAAM,OAAO;AAAA,IACzC,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,QAAQ;AAAA,IACN,UAAU;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,KAAK;AAAA,IACH,UAAU,CAAC,UAAU,OAAO,MAAM,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,IACnE,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,KAAK;AAAA,IACH,UAAU,CAAC,UAAU,OAAO,MAAM,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,IACnE,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,QAAQ;AAAA,IACN,UAAU,CAAC,UAAU,OAAO,MAAM,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,IACnE,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AAAA,EACA,OAAO;AAAA,IACL,UAAU,CAAC,UAAU,OAAO,MAAM,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,IACnE,MAAM,CAAC,UAAU,OAAO,OAAO,QAAQ;AAAA,EACzC;AACF;AAEA,IAAM,oBAKF;AAAA;AAAA,EAEF,QAAQ,CAAC,OAAO,WACd,UAAU,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,OAAO,KAAK,CAAC;AAAA,EACrD,KAAK,CAAC,OAAO,WACX,UAAU,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,OAAO,KAAK,CAAC;AAAA;AAAA,EAE1D,IAAI,CAAC,OAAO,WAAW,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC;AAAA,EAC/C,OAAO,CAAC,OAAO,WAAW,CAAC,UAAU,MAAM,IAAI,MAAM,CAAC;AAAA;AAAA,EAEtD,KAAK,CAAC,OAAO,WAAW,CAAC,QAAQ,IAAI,OAAO,KAAK,CAAC,GAAG;AAAA,EACrD,QAAQ,CAAC,OAAO,WAAW,CAAC,YAAY,IAAI,OAAO,KAAK,CAAC,GAAG;AAAA;AAAA,EAE5D,IAAI,CAAC,OAAO,WAAW,CAAC,KAAK,OAAO,KAAK,CAAC;AAAA,EAC1C,IAAI,CAAC,OAAO,WAAW,CAAC,KAAK,OAAO,KAAK,CAAC;AAAA,EAC1C,KAAK,CAAC,OAAO,WAAW,CAAC,MAAM,OAAO,KAAK,CAAC;AAAA,EAC5C,KAAK,CAAC,OAAO,WAAW,CAAC,MAAM,OAAO,KAAK,CAAC;AAAA;AAAA,EAE5C,UAAU,CAAC,OAAO,WAAW,CAAC,QAAQ,IAAI,OAAO,KAAK,CAAC,GAAG;AAAA,EAC1D,aAAa,CAAC,OAAO,WAAW,CAAC,YAAY,IAAI,OAAO,KAAK,CAAC,GAAG;AAAA,EACjE,YAAY,CAAC,OAAO,WAAW,CAAC,QAAQ,GAAG,OAAO,KAAK,CAAC,GAAG;AAAA,EAC3D,eAAe,CAAC,OAAO,WAAW,CAAC,YAAY,GAAG,OAAO,KAAK,CAAC,GAAG;AAAA,EAClE,UAAU,CAAC,OAAO,WAAW,CAAC,QAAQ,IAAI,OAAO,KAAK,CAAC,EAAE;AAAA,EACzD,aAAa,CAAC,OAAO,WAAW,CAAC,YAAY,IAAI,OAAO,KAAK,CAAC,EAAE;AAClE;AAEO,SAAS,qBAAqB;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM,QAA+C,CAAC;AAEtD,aAAW,CAAC,YAAY,GAAG,KAAK,OAAO,QAAQ,KAAK,GAAG;AACrD,QAAI,eAAe,SAAS,eAAe,MAAM;AAC/C,UAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACvB,cAAM,IAAI;AAAA,UACR,2DAA2D,UAAU,WAAW,GAAG;AAAA,QACrF;AAAA,MACF;AAEA,YAAM,cAAc,IAAI;AAAA,QAAI,CAAC,gBAC3B,qBAAqB,EAAE,IAAI,OAAO,aAAa,OAAO,SAAS,CAAC;AAAA,MAClE;AAEA,YAAM,KAAK,GAAG,eAAe,QAAQ,QAAQ,IAAI,EAAE,WAAW,CAAC;AAC/D;AAAA,IACF;AAEA,UAAM,SAAS,MAAM,UAAU;AAE/B,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI;AAAA,QACR,+CAA+C,UAAU,uBAAuB,OAAO;AAAA,UACrF;AAAA,QACF,EACG;AAAA,UACC,CAACC,gBACC,eAAe,MAAMA,WAAU,CAAC,KAChC,kBAAkB,MAAMA,WAAU,CAAC,KACnC,aAAa,MAAMA,WAAU,CAAC,KAC9B,aAAa,MAAMA,WAAU,CAAC;AAAA,QAClC,EACC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,MACf;AAAA,IACF;AAEA,QAAI,YAAY,MAAM,KAAK,aAAa,MAAM,GAAG;AAC/C,YAAM,IAAI;AAAA,QACR,oDAAoD,UAAU;AAAA,MAChE;AAAA,IACF;AAEA,QAAI,aAAa,MAAM,GAAG;AACxB,YAAM,IAAI;AAAA,QACR,iDAAiD,UAAU;AAAA,MAC7D;AAAA,IACF;AAGA,UAAM,sBACJ,MAAM,QAAQ,GAAG,KAAK,OAAO,QAAQ,WAAW,EAAE,QAAQ,IAAI,IAAI;AAEpE,eAAW,CAAC,WAAW,KAAK,KAAK,OAAO,QAAQ,mBAAmB,GAAG;AACpE,YAAM,aAAa,aAAa,MAAM,IAAI,WAAW,OAAO,SAAS;AAErE,YAAM,oBACJ,kBAAkB,UAAU,IAC1B,aAAa,MAAM,IAAI,SAAS,UAClC;AACF,UAAI,CAAC,kBAAkB,SAAS,SAAS,GAAG;AAC1C,cAAM,IAAI;AAAA,UACR,wCAAwC,UAAU,WAAW,SAAS,uBAAuB,kBAC1F,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,QACf;AAAA,MACF;AAEA,YAAM,mBAAmB,kBAAkB,SAAS;AAIpD,YAAM,SAAS,CAAC,MAAW;AACzB,cAAM,kBACJ,aAAa,MAAM,MAClB,cAAc,SAAS,cAAc;AAExC,YAAI,iBAAiB;AAGnB,cAAK,OAAwB,SAAS,MAAM,UAAU;AACpD,mBAAO,OAAO,CAAW;AAAA,UAC3B,WAAY,OAAwB,SAAS,MAAM,OAAO;AACxD,mBAAQ,EAAa,YAAY;AAAA,UACnC;AACA,iBAAO;AAAA,QACT;AACA,eAAO,YAAY,GAAG,QAAQ,QAAQ;AAAA,MACxC;AAEA,YAAM,CAAC,YAAY,YAAY,IAAI,iBAAiB,OAAO,MAAM;AACjE,YAAM,KAAK,GAAG,GAAG,YAAY,YAAY,YAAY,CAAC;AAAA,IACxD;AAAA,EACF;AAEA,SAAO,GAAG,IAAI,KAAK;AACrB;;;AJnLA,IAAM,iBAAiB;AAEhB,IAAM,qBAAqB,CAAC;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,OAKiC;AAAA,EAC/B,QAAQ,OAAO;AAAA,IACb;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAIM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,UAAU,EAAE,IAAI,GAAG,KAAK,GAAG,OAAO,IAAI;AAExD,YAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,SAAS,EAChB,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,cAAM,gBAAgB,KAAK,EAAE,IAAI,GAAG,KAAK,CAAC;AAAA,MAC5C,CAAC;AAEH,aAAO,UAAU,KAAK,OAAO,IAAI;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EACA,YAAY,OAAO;AAAA,IACjB;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,UAAM,OAAyB,CAAC;AAEhC,aAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,KAAK,KAAK,gBAAgB;AAC/D,YAAM,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,cAAc,GAAG,YAAY;AAC/D,cAAM,aAAa,KAChB,MAAM,GAAG,IAAI,cAAc,EAC3B,IAAI,CAAC,MAAM,UAAU,GAAG,OAAO,IAAI,CAAC;AAEvC,cAAM,QAAQ,MAAM,GACjB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,UAAU,EACjB,aAAa,EACb,QAAQ,EACR,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;AAAA,QAC3D,CAAC;AAEH,aAAK,KAAK,GAAG,KAAK;AAAA,MACpB,CAAC;AAAA,IACH;AAEA,WAAO,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,EACtD;AAAA,EACA,QAAQ,OAAO;AAAA,IACb;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAMM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAEhD,UAAI;AACJ,UAAI,OAAO,SAAS,YAAY;AAC9B,cAAM,YAAY,MAAM,GACrB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,EAAE,IAAI,MAAM,aAAa,CAAC;AAAA,QACvD,CAAC;AAEH,uBAAe,KAAK,EAAE,SAAS,UAAU,WAAW,OAAO,IAAI,EAAE,CAAC;AAAA,MACpE,OAAO;AACL,uBAAe;AAAA,MACjB;AACA,YAAM,YAAY,UAAU,EAAE,IAAI,GAAG,aAAa,GAAG,OAAO,IAAI;AAEhE,YAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,SAAS,EAC1B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,cAAM,gBAAgB,KAAK,EAAE,IAAI,GAAG,aAAa,CAAC;AAAA,MACpD,CAAC;AAEH,aAAO,UAAU,KAAK,OAAO,IAAI;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EACA,YAAY,OAAO;AAAA,IACjB;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAMM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,QAAI,OAAO,SAAS,YAAY;AAC9B,YAAMC,SAAQ,GACX,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV;AAAA,QAAM,CAAC,OACN,qBAAqB;AAAA,UACnB;AAAA,UACA;AAAA,UACA;AAAA,UACA,UAAU;AAAA,QACZ,CAAC;AAAA,MACH,EACC,QAAQ,MAAM,KAAK;AAEtB,YAAM,OAAqB,CAAC;AAC5B,UAAI,SAAyB;AAE7B,aAAO,MAAM;AACX,cAAM,QAAQ,MAAM,GAAG;AAAA,UACrB,EAAE,QAAQ,GAAG,SAAS,cAAc;AAAA,UACpC,YAAY;AACV,kBAAM,aAA+B,MAAMA,OACxC,MAAM,cAAc,EACpB,IAAI,WAAW,MAAM,CAAC,OAAO,GAAG,MAAM,MAAM,KAAK,MAAM,CAAC,EACxD,QAAQ;AAEX,kBAAMC,QAAyB,CAAC;AAEhC,uBAAW,aAAa,YAAY;AAClC,oBAAM,UAAU,UAAU,WAAW,OAAO,IAAI;AAChD,oBAAM,eAAe,KAAK,EAAE,QAAQ,CAAC;AAErC,oBAAM,YAAY;AAAA,gBAChB,IAAI,UAAU;AAAA,gBACd,GAAG,UAAU,cAAc,OAAO,IAAI;AAAA,cACxC;AAEA,oBAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,UAAU,EAAE,EAC7B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,sBAAM,gBAAgB,KAAK,YAAY;AAAA,cACzC,CAAC;AACH,cAAAA,MAAK,KAAK,GAAG;AAAA,YACf;AAEA,mBAAOA,MAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,UACtD;AAAA,QACF;AAEA,aAAK,KAAK,GAAG,KAAK;AAElB,YAAI,MAAM,WAAW,GAAG;AACtB;AAAA,QACF,OAAO;AACL,mBAAS,YAAY,MAAM,MAAM,SAAS,CAAC,EAAE,IAAI,MAAM,IAAI,IAAI;AAAA,QACjE;AAAA,MACF;AAEA,aAAO;AAAA,IACT,OAAO;AACL,aAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,cAAc,GAAG,YAAY;AAChE,cAAM,YAAY,UAAU,MAAM,OAAO,IAAI;AAE7C,cAAM,OAAO,MAAM,GAChB;AAAA,UAAK;AAAA,UAAkB,CAACC,QACvBA,IACG,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,IAAI,EACX;AAAA,YAAM,CAAC,OACN,qBAAqB;AAAA,cACnB;AAAA,cACA;AAAA,cACA;AAAA,cACA,UAAU;AAAA,YACZ,CAAC;AAAA,UACH;AAAA,QACJ,EACC,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,KAAK,YAAY,EACjB,MAAM,GAAG,SAAS,OAAO,KAAKC,KAAI,IAAI,eAAe,CAAC,EACtD,aAAa,EACb,QAAQ,EACR,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,IAAI;AAAA,QACjC,CAAC;AAEH,eAAO,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,MACtD,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,QAAQ,OAAO;AAAA,IACb;AAAA,IACA;AAAA,IACA,QAAAC,UAAS,CAAC;AAAA,IACV,SAAS,CAAC;AAAA,EACZ,MAOM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAChD,YAAM,YAAY,UAAU,EAAE,IAAI,GAAGA,QAAO,GAAG,OAAO,IAAI;AAE1D,UAAI,OAAO,WAAW,YAAY;AAChC,cAAM,YAAY,MAAM,GACrB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,iBAAiB;AAEpB,YAAI,cAAc,QAAW;AAC3B,gBAAMC,OAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,SAAS,EAChB,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,kBAAM,eAAoB,EAAE,GAAG;AAC/B,uBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQD,OAAM;AAC9C,2BAAa,UAAU,GAAG,EAAE,IAAI;AAClC,yBAAa,SAAS;AACtB,kBAAM,gBAAgB,KAAK,YAAY;AAAA,UACzC,CAAC;AAEH,iBAAO,UAAUC,MAAK,OAAO,IAAI;AAAA,QACnC;AAEA,cAAM,UAAU,UAAU,WAAW,OAAO,IAAI;AAChD,cAAM,eAAe,OAAO,EAAE,QAAQ,CAAC;AACvC,cAAM,YAAY,UAAU,EAAE,IAAI,GAAG,aAAa,GAAG,OAAO,IAAI;AAEhE,cAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,SAAS,EAC1B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,eAAoB,EAAE,GAAG;AAC/B,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQD,OAAM;AAC9C,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,YAAY;AACpD,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,gBAAM,gBAAgB,KAAK,YAAY;AAAA,QACzC,CAAC;AAEH,eAAO,UAAU,KAAK,OAAO,IAAI;AAAA,MACnC,OAAO;AACL,cAAM,YAAY,UAAU,EAAE,IAAI,GAAG,OAAO,GAAG,OAAO,IAAI;AAE1D,cAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,SAAS,EAChB,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,SAAS,CAAC,EACzD,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,eAAoB,EAAE,GAAG;AAC/B,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQA,OAAM;AAC9C,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM;AAC9C,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,gBAAM,gBAAgB,KAAK,YAAY;AAAA,QACzC,CAAC;AAEH,eAAO,UAAU,KAAK,OAAO,IAAI;AAAA,MACnC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,QAAQ,OAAO;AAAA,IACb;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAEhD,YAAM,aAAa,MAAM,GACtB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,MAAM,MAAM,KAAK,SAAS,EAC1B,UAAU,CAAC,IAAI,CAAC,EAChB,iBAAiB,EACjB,MAAM,CAAC,QAAQ;AACd,cAAM,gBAAgB,KAAK,EAAE,GAAG,CAAC;AAAA,MACnC,CAAC;AAEH,aAAO,CAAC,CAAC;AAAA,IACX,CAAC;AAAA,EACH;AACF;;;AKrWA,SAAS,OAAAE,YAAW;;;ACGb,SAAS,UAAU,OAAY;AACpC,SAAO,KAAK;AAAA,IAAU;AAAA,IAAO,CAAC,GAAG,MAC/B,OAAO,MAAM,WAAW,EAAE,QAAQ,UAAU,OAAO,EAAE,SAAS,EAAE,IAAI;AAAA,EACtE;AACF;AAUO,SAAS,YAAkB,OAAqB;AACrD,SAAO,KAAK;AAAA,IAAM;AAAA,IAAO,CAAC,GAAG,WAC3B,QAAQ,WAAW,WAAW,OAAO,OAAO,KAAK,IAAI;AAAA,EACvD;AACF;;;ACpBO,SAAS,aACd,QACA,mBACA;AACA,QAAM,eAAe,kBAAkB,IAAI,CAAC,CAAC,UAAU,MAAM;AAAA,IAC3D;AAAA,IACA,OAAO,UAAU;AAAA,EACnB,CAAC;AAED,SAAO,OAAO,KAAK,UAAU,YAAY,CAAC,EAAE,SAAS,QAAQ;AAC/D;AAEO,SAAS,aACd,QACA,mBACA;AACA,QAAM,eAAe;AAAA,IACnB,OAAO,KAAK,QAAQ,QAAQ,EAAE,SAAS;AAAA,EACzC;AAGA,MAAI,aAAa,WAAW,kBAAkB,QAAQ;AACpD,UAAM,IAAI;AAAA,MACR,uBAAuB,aAAa,MAAM,KAAK,kBAAkB,MAAM;AAAA,IACzE;AAAA,EACF;AAEA,aAAW,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,kBAAkB,QAAQ,GAAG;AAC/D,QAAI,aAAa,KAAK,EAAE,CAAC,MAAM,YAAY;AACzC,YAAM,IAAI;AAAA,QACR,+BAA+B,aAAa,KAAK,EAAE,CAAC,CAAC,cAAc,KAAK,eAAe,UAAU;AAAA,MACnG;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,sBACd,cACA,MACA,WACA,IACA;AACA,QAAM,aACJ,SAAS,UACL,cAAc,QACZ,MACA,MACF,cAAc,QACZ,MACA;AACR,QAAM,qBAAqB,GAAG,UAAU;AAExC,MAAI,aAAa,WAAW,GAAG;AAC7B,UAAM,CAAC,YAAY,KAAK,IAAI,aAAa,CAAC;AAC1C,WAAO,GAAG,GAAG,YAAY,oBAAoB,KAAK;AAAA,EACpD,WAAW,aAAa,WAAW,GAAG;AACpC,UAAM,CAAC,aAAa,MAAM,IAAI,aAAa,CAAC;AAC5C,UAAM,CAAC,aAAa,MAAM,IAAI,aAAa,CAAC;AAE5C,WAAO,GAAG,GAAG;AAAA,MACX,GAAG,GAAG,aAAa,YAAY,MAAM;AAAA,MACrC,GAAG,IAAI;AAAA,QACL,GAAG,GAAG,aAAa,KAAK,MAAM;AAAA,QAC9B,GAAG,GAAG,aAAa,oBAAoB,MAAM;AAAA,MAC/C,CAAC;AAAA,IACH,CAAC;AAAA,EACH,OAAO;AACL,UAAM,IAAI;AAAA,MACR,uBAAuB,aAAa,MAAM;AAAA,IAC5C;AAAA,EACF;AACF;;;AC9DO,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AACF,GAGsB;AACpB,MAAI,CAAC,SAAS;AACZ,WAAO,CAAC,CAAC,MAAM,KAAK,CAAC;AAAA,EACvB;AAEA,QAAM,aAAa,OAAO,QAAQ,OAAO;AACzC,MAAI,WAAW,SAAS;AACtB,UAAM,IAAI,WAAW,gDAAgD;AAEvE,QAAM,CAAC,YAAY,cAAc,IAAI,WAAW,CAAC;AAGjD,QAAM,SAAS,MAAM,UAAU;AAC/B,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR,6CAA6C,UAAU,uBAAuB,OAAO;AAAA,QACnF;AAAA,MACF,EACG;AAAA,QACC,CAACC,gBACC,eAAe,MAAMA,WAAU,CAAC,KAChC,kBAAkB,MAAMA,WAAU,CAAC,KACnC,aAAa,MAAMA,WAAU,CAAC,KAC9B,aAAa,MAAMA,WAAU,CAAC;AAAA,MAClC,EACC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI,CAAC;AAAA,IACf;AAAA,EACF;AACA,MAAI,YAAY,MAAM,KAAK,aAAa,MAAM,GAAG;AAC/C,UAAM,IAAI;AAAA,MACR,gDAAgD,UAAU;AAAA,IAC5D;AAAA,EACF;AAEA,MAAI,aAAa,MAAM,GAAG;AACxB,UAAM,IAAI;AAAA,MACR,6CAA6C,UAAU;AAAA,IACzD;AAAA,EACF;AAEA,MAAI,mBAAmB,UAAa,CAAC,CAAC,OAAO,MAAM,EAAE,SAAS,cAAc;AAC1E,UAAM,IAAI;AAAA,MACR,gCAAgC,cAAc;AAAA,IAChD;AAEF,QAAM,oBAAuC,CAAC,CAAC,YAAY,cAAc,CAAC;AAI1E,MAAI,eAAe,MAAM;AACvB,sBAAkB,KAAK,CAAC,MAAM,cAAc,CAAC;AAAA,EAC/C;AAEA,SAAO;AACT;AAEO,SAAS,yBAAyB,mBAAsC;AAC7E,SAAO,kBAAkB,IAAI,CAAC,CAAC,YAAY,SAAS,MAAM;AAAA,IACxD;AAAA,IACA,cAAc,QAAQ,SAAS;AAAA,EACjC,CAAC;AACH;;;AHlEA,IAAM,gBAAgB;AACtB,IAAM,YAAY;AAEX,IAAM,mBAAmB,CAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,OAKsB;AAAA,EACpB,YAAY,OAAO;AAAA,IACjB;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,cAAc,GAAG,YAAY;AAChE,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAEhD,YAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,iBAAiB;AAEpB,UAAI,QAAQ;AAAW,eAAO;AAE9B,aAAO,UAAU,KAAK,OAAO,IAAI;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EACA,UAAU,OAAO;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV,MAOM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,YAAY,GAAG,YAAY;AAC9D,UAAIC,SAAQ,GACT,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU;AAEb,UAAI,OAAO;AACT,QAAAA,SAAQA,OAAM;AAAA,UAAM,CAAC,OACnB,qBAAqB,EAAE,IAAI,OAAO,OAAO,UAAU,KAAK,CAAC;AAAA,QAC3D;AAAA,MACF;AAEA,YAAM,oBAAoB,uBAAuB,EAAE,SAAS,MAAM,CAAC;AACnE,iBAAW,CAAC,QAAQ,SAAS,KAAK,mBAAmB;AACnD,QAAAA,SAAQA,OAAM;AAAA,UACZ;AAAA,UACA,SAAS,WACL,YACA,cAAc,QACZC,wBACAA;AAAA,QACR;AAAA,MACF;AACA,YAAM,iBAAiB,kBAAkB,CAAC,EAAE,CAAC;AAE7C,UAAI,QAAQ,WAAW;AACrB,cAAM,IAAI;AAAA,UACR,sBAAsB,KAAK,gBAAgB,SAAS;AAAA,QACtD;AAAA,MACF;AAEA,UAAI,UAAU,QAAQ,WAAW,MAAM;AACrC,cAAM,IAAI,WAAW,+CAA+C;AAAA,MACtE;AAEA,UAAI,cAAc;AAClB,UAAI,YAAY;AAChB,UAAI,kBAAkB;AACtB,UAAI,cAAc;AAGlB,UAAI,UAAU,QAAQ,WAAW,MAAM;AACrC,QAAAD,SAAQA,OAAM,MAAM,QAAQ,CAAC;AAC7B,cAAM,OAAO,MAAMA,OAAM,QAAQ;AACjC,cAAM,UAAU,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAE7D,YAAI,QAAQ,WAAW,QAAQ,GAAG;AAChC,kBAAQ,IAAI;AACZ,wBAAc;AAAA,QAChB;AAEA,sBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,CAAC,GAAG,iBAAiB,IAC1C;AACN,oBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,QAAQ,SAAS,CAAC,GAAG,iBAAiB,IAC3D;AAEN,eAAO;AAAA,UACL,OAAO;AAAA,UACP,UAAU,EAAE,aAAa,iBAAiB,aAAa,UAAU;AAAA,QACnE;AAAA,MACF;AAEA,UAAI,UAAU,MAAM;AAElB,cAAM,kBAAkB,aAAa,OAAO,iBAAiB;AAC7D,cAAM,eAAe,gBAAgB,IAAI,CAAC,CAAC,YAAY,KAAK,MAAM;AAAA,UAChE;AAAA,UACA,YAAY,OAAO,MAAM,UAAU,GAAG,IAAI;AAAA,QAC5C,CAAC;AACD,QAAAA,SAAQA,OACL;AAAA,UAAM,CAAC,OACN,sBAAsB,cAAc,SAAS,gBAAgB,EAAE;AAAA,QACjE,EACC,MAAM,QAAQ,CAAC;AAElB,cAAM,OAAO,MAAMA,OAAM,QAAQ;AACjC,cAAM,UAAU,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAE7D,YAAI,QAAQ,WAAW,GAAG;AACxB,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,UAAU;AAAA,cACR;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAIA,YAAI,aAAa,QAAQ,CAAC,GAAG,iBAAiB,MAAM,OAAO;AACzD,kBAAQ,MAAM;AACd,4BAAkB;AAAA,QACpB,OAAO;AAEL,kBAAQ,IAAI;AAAA,QACd;AAIA,YAAI,QAAQ,WAAW,QAAQ,GAAG;AAChC,kBAAQ,IAAI;AACZ,wBAAc;AAAA,QAChB;AAGA,sBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,CAAC,GAAG,iBAAiB,IAC1C;AACN,oBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,QAAQ,SAAS,CAAC,GAAG,iBAAiB,IAC3D;AAEN,eAAO;AAAA,UACL,OAAO;AAAA,UACP,UAAU,EAAE,aAAa,iBAAiB,aAAa,UAAU;AAAA,QACnE;AAAA,MACF,OAAO;AAEL,cAAM,kBAAkB,aAAa,QAAS,iBAAiB;AAC/D,cAAM,eAAe,gBAAgB,IAAI,CAAC,CAAC,YAAY,KAAK,MAAM;AAAA,UAChE;AAAA,UACA,YAAY,OAAO,MAAM,UAAU,GAAG,IAAI;AAAA,QAC5C,CAAC;AACD,QAAAA,SAAQA,OACL;AAAA,UAAM,CAAC,OACN,sBAAsB,cAAc,UAAU,gBAAgB,EAAE;AAAA,QAClE,EACC,MAAM,QAAQ,CAAC;AAGlB,QAAAA,SAAQA,OAAM,aAAa;AAC3B,cAAM,4BACJ,yBAAyB,iBAAiB;AAC5C,mBAAW,CAAC,QAAQ,SAAS,KAAK,2BAA2B;AAC3D,UAAAA,SAAQA,OAAM,QAAQ,QAAQ,SAAS;AAAA,QACzC;AAEA,cAAM,OAAO,MAAMA,OAAM,QAAQ;AACjC,cAAM,UAAU,KACb,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC,EAExC,QAAQ;AAEX,YAAI,QAAQ,WAAW,GAAG;AACxB,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,UAAU;AAAA,cACR;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAIA,YACE,aAAa,QAAQ,QAAQ,SAAS,CAAC,GAAG,iBAAiB,MAC3D,QACA;AACA,kBAAQ,IAAI;AACZ,wBAAc;AAAA,QAChB,OAAO;AAEL,kBAAQ,MAAM;AAAA,QAChB;AAIA,YAAI,QAAQ,WAAW,QAAQ,GAAG;AAChC,kBAAQ,MAAM;AACd,4BAAkB;AAAA,QACpB;AAGA,sBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,CAAC,GAAG,iBAAiB,IAC1C;AACN,oBACE,QAAQ,SAAS,IACb,aAAa,QAAQ,QAAQ,SAAS,CAAC,GAAG,iBAAiB,IAC3D;AAEN,eAAO;AAAA,UACL,OAAO;AAAA,UACP,UAAU,EAAE,aAAa,iBAAiB,aAAa,UAAU;AAAA,QACnE;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AIrQA,IAAME,kBAAiB;AAEhB,IAAM,mBAAmB,CAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,OAK+B;AAAA,EAC7B,QAAQ,CAAC;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAKM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,UAAU,EAAE,IAAI,GAAG,KAAK,GAAG,OAAO,IAAI;AAExD,aAAO,MAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAClD,cAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,SAAS,EAChB,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,EAAE,IAAI,GAAG,KAAK,CAAC;AAAA,QAC5C,CAAC;AAEH,cAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,UACN,WAAW;AAAA,UACX,IAAI,UAAU;AAAA,UACd,YAAY;AAAA,QACd,CAAC,EACA,QAAQ;AAEX,eAAO,UAAU,KAAK,OAAO,IAAI;AAAA,MACnC,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EACA,YAAY,CAAC;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAIM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,cAAc,GAAG,YAAY;AAChE,YAAM,OAAyB,CAAC;AAChC,YAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAC3C,iBAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,KAAK,KAAKA,iBAAgB;AAC/D,gBAAM,aAAa,KAChB,MAAM,GAAG,IAAIA,eAAc,EAC3B,IAAI,CAAC,MAAM,UAAU,GAAG,OAAO,IAAI,CAAC;AAEvC,gBAAM,QAAQ,MAAM,GACjB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,UAAU,EACjB,aAAa,EACb,QAAQ,EACR,MAAM,CAAC,QAAQ;AACd,kBAAM,gBAAgB,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;AAAA,UAC3D,CAAC;AAEH,eAAK,KAAK,GAAG,KAAK;AAElB,gBAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD;AAAA,YACC,WAAW,IAAI,CAAC,SAAS;AAAA,cACvB,WAAW;AAAA,cACX,IAAI,IAAI;AAAA,cACR,YAAY;AAAA,YACd,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAED,aAAO,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,IACtD,CAAC;AAAA,EACH;AAAA,EACA,QAAQ,CAAC;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAOM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAEhD,YAAM,MAAM,MAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,cAAM,YAAY,MAAM,GACrB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,EAAE,IAAI,MAAM,aAAa,CAAC;AAAA,QACvD,CAAC;AAEH,cAAM,eACJ,OAAO,SAAS,aACZ,KAAK,EAAE,SAAS,UAAU,WAAW,OAAO,IAAI,EAAE,CAAC,IACnD;AACN,cAAM,YAAY,UAAU,EAAE,IAAI,GAAG,aAAa,GAAG,OAAO,IAAI;AAEhE,cAAM,eAAe,MAAM,GACxB,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,SAAS,EAC1B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,EAAE,IAAI,GAAG,aAAa,CAAC;AAAA,QACpD,CAAC;AAEH,cAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,UACN,WAAW;AAAA,UACX,YAAY;AAAA,UACZ,GAAG;AAAA,QACL,CAAC,EACA,QAAQ;AAEX,eAAO;AAAA,MACT,CAAC;AAED,YAAM,SAAS,UAAU,KAAK,OAAO,IAAI;AAEzC,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EACA,YAAY,OAAO;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,EACV,MAOM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,UAAM,OAAqB,CAAC;AAC5B,QAAI,SAAyB;AAE7B,WAAO,MAAM;AACX,YAAM,QAAQ,MAAM,GAAG;AAAA,QAAK,EAAE,QAAQ,GAAG,SAAS,cAAc;AAAA,QAAG,MACjE,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACrC,gBAAM,aAA+B,MAAM,GACxC,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV;AAAA,YAAM,CAAC,OACN,qBAAqB;AAAA,cACnB;AAAA,cACA;AAAA,cACA;AAAA,cACA,UAAU;AAAA,YACZ,CAAC;AAAA,UACH,EACC,QAAQ,MAAM,KAAK,EACnB,MAAMA,eAAc,EACpB,IAAI,WAAW,MAAM,CAAC,OAAO,GAAG,MAAM,MAAM,KAAK,MAAM,CAAC,EACxD,QAAQ;AAEX,gBAAMC,QAAyB,CAAC;AAEhC,qBAAW,aAAa,YAAY;AAClC,kBAAM,eACJ,OAAO,SAAS,aACZ,KAAK,EAAE,SAAS,UAAU,WAAW,OAAO,IAAI,EAAE,CAAC,IACnD;AAGN,kBAAM,YAAY;AAAA,cAChB,IAAI,UAAU;AAAA,cACd,GAAG,UAAU,cAAc,OAAO,IAAI;AAAA,YACxC;AAEA,kBAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,UAAU,EAAE,EAC7B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,oBAAM,gBAAgB,KAAK,YAAY;AAAA,YACzC,CAAC;AAEH,YAAAA,MAAK,KAAK,GAAG;AAEb,kBAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,cACN,WAAW;AAAA,cACX,YAAY;AAAA,cACZ,GAAG;AAAA,YACL,CAAC,EACA,QAAQ;AAAA,UACb;AAEA,iBAAOA,MAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,OAAO,IAAI,CAAC;AAAA,QACtD,CAAC;AAAA,MACH;AAEA,WAAK,KAAK,GAAG,KAAK;AAElB,UAAI,MAAM,WAAW,GAAG;AACtB;AAAA,MACF,OAAO;AACL,iBAAS,YAAY,MAAM,MAAM,SAAS,CAAC,EAAE,IAAI,MAAM,IAAI,IAAI;AAAA,MACjE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EACA,QAAQ,CAAC;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAAC,UAAS,CAAC;AAAA,IACV,SAAS,CAAC;AAAA,EACZ,MAQM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAChD,YAAM,YAAY,UAAU,EAAE,IAAI,GAAGA,QAAO,GAAG,OAAO,IAAI;AAE1D,YAAM,MAAM,MAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAEvD,cAAM,YAAY,MAAM,GACrB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,iBAAiB;AAGpB,YAAI,cAAc,QAAW;AAC3B,gBAAMC,OAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,OAAO,SAAS,EAChB,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,kBAAM,eAAoB,EAAE,GAAG;AAC/B,uBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQD,OAAM;AAC9C,2BAAa,UAAU,GAAG,EAAE,IAAI;AAClC,gBAAI,OAAO,WAAW,YAAY;AAChC,2BAAa,SAAS;AAAA,YACxB,OAAO;AACL,yBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM;AAC9C,6BAAa,UAAU,GAAG,EAAE,IAAI;AAAA,YACpC;AACA,kBAAM,gBAAgB,KAAK,YAAY;AAAA,UACzC,CAAC;AAEH,gBAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,YACN,WAAW;AAAA,YACX,IAAI,UAAU;AAAA,YACd,YAAY;AAAA,UACd,CAAC,EACA,QAAQ;AAEX,iBAAOC;AAAA,QACT;AAEA,cAAM,eACJ,OAAO,WAAW,aACd,OAAO,EAAE,SAAS,UAAU,WAAW,OAAO,IAAI,EAAE,CAAC,IACrD;AACN,cAAM,YAAY,UAAU,EAAE,IAAI,GAAG,aAAa,GAAG,OAAO,IAAI;AAEhE,cAAMA,OAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,YAAY,SAAS,EACrB,IAAI,SAAS,EACb,MAAM,MAAM,KAAK,SAAS,EAC1B,aAAa,EACb,wBAAwB,EACxB,MAAM,CAAC,QAAQ;AACd,gBAAM,eAAoB,EAAE,GAAG;AAC/B,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQD,OAAM;AAC9C,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,qBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,YAAY;AACpD,yBAAa,UAAU,GAAG,EAAE,IAAI;AAClC,gBAAM,gBAAgB,KAAK,YAAY;AAAA,QACzC,CAAC;AAEH,cAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,UACN,WAAW;AAAA,UACX,YAAY;AAAA,UACZ,GAAG;AAAA,QACL,CAAC,EACA,QAAQ;AAEX,eAAOC;AAAA,MACT,CAAC;AAED,aAAO,UAAU,KAAK,OAAO,IAAI;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EACA,QAAQ,CAAC;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAIM;AACJ,UAAM,QAAS,OAAO,SAAS,EAAuB;AAEtD,WAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,SAAS,UAAU,GAAG,YAAY;AAC5D,YAAM,YAAY,YAAY,IAAI,MAAM,IAAI,IAAI;AAEhD,YAAM,YAAY,MAAM,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAC7D,cAAM,MAAM,MAAM,GACf,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,UAAU,EACV,MAAM,MAAM,KAAK,SAAS,EAC1B,iBAAiB;AAEpB,cAAM,aAAa,MAAM,GACtB,WAAW,cAAc,aAAa,EACtC,WAAW,SAAS,EACpB,MAAM,MAAM,KAAK,SAAS,EAC1B,UAAU,CAAC,IAAI,CAAC,EAChB,iBAAiB,EACjB,MAAM,CAAC,QAAQ;AACd,gBAAM,gBAAgB,KAAK,EAAE,GAAG,CAAC;AAAA,QACnC,CAAC;AAEH,YAAI,QAAQ,QAAW;AACrB,gBAAM,GACH,WAAW,cAAc,iBAAiB,EAC1C,WAAW,cAAc,iBAAiB,SAAS,CAAC,EACpD,OAAO;AAAA,YACN,WAAW;AAAA,YACX,YAAY;AAAA,YACZ,GAAG;AAAA,UACL,CAAC,EACA,QAAQ;AAAA,QACb;AAEA,eAAO,CAAC,CAAC;AAAA,MACX,CAAC;AAED,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACF;;;ACvaO,IAAM,QAAQ,CAAC,OAAc;AAClC,QAAM;AACR;;;ACsBA,SAAS,iBAAiB,oBAAoB;;;ACD9C;AAAA,EACE,cAAc;AAAA,EACd,eAAe;AAAA,EACf,gBAAgB;AAAA,EAChB,aAAa;AAAA,EACb,gBAAgB;AAAA,OACX;AA6DA,IAAM,qBAAqB,CAChC,iBACG;AACH,SAAO,CAKL,YACmB;AAAA,IACnB,YAAY,CAAC;AAAA,MACX;AAAA,MACA,aAAa;AAAA,MACb,GAAG;AAAA,IACL,MAEE,eAAe,QAAQ;AAAA,MACrB,GAAG;AAAA,MACH,GAAI,UAAU,cACV,EAAE,UAAU,SAAS,IACrB,EAAE,aAAa,mBAAmB,aAAa,YAAY;AAAA,IACjE,CAAC;AAAA,IACH,aAAa,CAAC;AAAA,MACZ;AAAA,MACA,aAAa;AAAA,MACb,GAAG;AAAA,IACL,MAEE,gBAAgB,QAAQ;AAAA,MACtB,GAAG;AAAA,MACH,GAAI,UAAU,cACV,EAAE,UAAU,SAAS,IACrB,EAAE,aAAa,mBAAmB,aAAa,YAAY;AAAA,IACjE,CAAC;AAAA,IACH,cAAc,CAAC;AAAA,MACb;AAAA,MACA,aAAa;AAAA,MACb,GAAG;AAAA,IACL,MAEE,iBAAiB,QAAQ;AAAA,MACvB,GAAG;AAAA,MACH,GAAI,UAAU,cACV,EAAE,UAAU,SAAS,IACrB,EAAE,aAAa,mBAAmB,aAAa,YAAY;AAAA,IACjE,CAAC;AAAA,IACH,WAAW,CAGT;AAAA,MACA;AAAA,MACA,aAAa;AAAA,MACb,GAAG;AAAA,IACL,MAKE,cAAc,QAAQ;AAAA,MACpB,GAAG;AAAA,MACH,GAAI,UAAU,cACV,EAAE,UAAU,SAAS,IACrB,EAAE,aAAa,mBAAmB,aAAa,YAAY;AAAA,IACjE,CAAC;AAAA;AAAA,IAEH,cAAc,CAGZ;AAAA,MACA;AAAA,MACA,aAAa;AAAA,MACb,GAAG;AAAA,IACL,MAKE,iBAAiB,QAAQ;AAAA,MACvB,GAAG;AAAA,MACH,GAAI,UAAU,cACV,EAAE,UAAU,SAAS,IACrB,EAAE,aAAa,mBAAmB,aAAa,YAAY;AAAA,IACjE,CAAgD;AAAA,EACpD;AACF;AAEO,IAAM,UAAU,CAAC;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAKM;AACJ,SAAO,OAAO,KAAK,UAAU,MAAM,CAAC,EAAE,OAEpC,CAAC,KAAK,cAAc;AACpB,QAAI,SAAS,IAAI;AAAA,MACf,YAAY,OAAO,EAAE,GAAG,MAAM;AAC5B,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,kBAAkB,EAAE;AAAA,QACvC,CAAC;AACD,eAAO,cAAc,WAAW;AAAA,UAC9B;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,UAAU,OAAO,EAAE,OAAO,SAAS,OAAO,QAAQ,MAAM,IAAI,CAAC,MAAM;AACjE,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS;AAAA,QACnB,CAAC;AACD,eAAO,cAAc,SAAS;AAAA,UAC5B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,QAAQ,OAAO,EAAE,IAAI,KAAK,MAAM;AAC9B,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,cAAc,EAAE;AAAA,QACnC,CAAC;AACD,eAAO,cAAc,OAAO;AAAA,UAC1B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,YAAY,OAAO,EAAE,KAAK,MAAM;AAC9B,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,qBAAqB,KAAK,MAAM;AAAA,QACnD,CAAC;AACD,eAAO,cAAc,WAAW;AAAA,UAC9B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,QAAQ,OAAO,EAAE,IAAI,KAAK,MAAM;AAC9B,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,cAAc,EAAE;AAAA,QACnC,CAAC;AACD,eAAO,cAAc,OAAO;AAAA,UAC1B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,YAAY,OAAO,EAAE,OAAO,KAAK,MAAM;AACrC,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS;AAAA,QACnB,CAAC;AACD,eAAO,cAAc,WAAW;AAAA,UAC9B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,QAAQ,OAAO,EAAE,IAAI,QAAAC,SAAQ,OAAO,MAAM;AACxC,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,cAAc,EAAE;AAAA,QACnC,CAAC;AACD,eAAO,cAAc,OAAO;AAAA,UAC1B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,UACA,QAAAA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,QAAQ,OAAO,EAAE,GAAG,MAAM;AACxB,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,GAAG,SAAS,cAAc,EAAE;AAAA,QACnC,CAAC;AACD,eAAO,cAAc,OAAO;AAAA,UAC1B;AAAA,UACA,mBAAmB,aAAa;AAAA,UAChC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;;;ACjSA,SAAS,gBAAAC,qBAAoB;AAE7B,SAAS,oBAAAC,yBAAwB;AACjC,SAA0B,SAASC,wBAAuB;AAEnD,IAAM,oBAAoB,CAAC,OAAc,YAAqB;AACnE,MAAI,CAAC,MAAM;AAAO;AAElB,QAAM,aAAaA,iBAAgB,MAAM,KAAK;AAE9C,MAAI;AACJ,MAAI;AAGJ,QAAM,sBAAsB,WAAW;AAAA,IAAU,CAAC,UAChD,MAAM,MAAM,SAAS,QAAQ,MAAM;AAAA,EACrC;AAEA,MAAI,uBAAuB,GAAG;AAC5B,qBAAiB,WAAW;AAAA,MAAO,CAAC,UAClC,MAAM,MAAM,SAAS,QAAQ,MAAM;AAAA,IACrC;AAEA,UAAM,iBAAiB,WAAW,mBAAmB;AACrD,QAAI,gBAAgB,QAAQ,gBAAgB,YAAY;AACtD,UAAI;AACF,cAAM,gBAAgBF,cAAa,eAAe,MAAM;AAAA,UACtD,UAAU;AAAA,QACZ,CAAC;AACD,oBAAYC;AAAA,UACV;AAAA,UACA;AAAA,YACE,OAAO;AAAA,cACL,MAAM,eAAe;AAAA,cACrB,QAAQ,eAAe,UAAU;AAAA,YACnC;AAAA,UACF;AAAA,UACA,EAAE,eAAe,KAAK;AAAA,QACxB;AAAA,MACF,SAAS,KAAK;AAAA,MAEd;AAAA,IACF;AAAA,EACF,OAAO;AACL,qBAAiB;AAAA,EACnB;AAEA,QAAM,sBAAsB;AAAA,IAC1B,GAAG,MAAM,IAAI,KAAK,MAAM,OAAO;AAAA,IAC/B,GAAG,eAAe,IAAI,CAAC,EAAE,MAAM,YAAY,QAAQ,WAAW,MAAM;AAClE,YAAM,SAAS;AACf,YAAME,SAAO,GAAG,IAAI,GAAG,eAAe,OAAO,IAAI,UAAU,KAAK,EAAE,GAChE,WAAW,OAAO,IAAI,MAAM,KAAK,EACnC;AACA,UAAI,eAAe,QAAQ,eAAe,aAAa;AACrD,eAAO,GAAG,MAAM,IAAIA,MAAI;AAAA,MAC1B,OAAO;AACL,eAAO,GAAG,MAAM,IAAI,UAAU,KAAKA,MAAI;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,IACD;AAAA,EACF,EAAE,KAAK,IAAI;AAEX,QAAM,QAAQ;AAChB;;;AFwBO,IAAMC,UAAS,CAAC;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAQe;AACb,QAAM,eAAwD;AAAA,IAC5D,mBAAmB;AAAA,IACnB,aAAa;AAAA,EACf;AACA,QAAM,kBAA8C,CAAC;AACrD,QAAM,qBAAoD,CAAC;AAE3D,QAAM,mBAAmB,SAAS;AAAA,IAChC,CAAC,KAAK,QAAQ;AACZ,UAAI,IAAI,OAAO,IAAI;AACnB,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAGA,aAAW,UAAU,SAAS;AAC5B,QAAI,OAAO,SAAS;AAAS;AAE7B,UAAM,UACJ,OAAO,SAAS,sBAAsB,OAAO,SAAS,eAClD,SACA,OAAO,SAAS,cACd,OAAO,SAAS,UAAW,WAAW,IACpC,OAAO,SAAS,UAAW,CAAC,IAC5B,SACF,OAAO,OAAO,SAAS,YAAY,WACjC,OAAO,SAAS,UAChB;AAEV,QAAI,mBAAmB,OAAO,OAAO,MAAM,QAAW;AACpD,yBAAmB,OAAO,OAAO,IAAI,CAAC;AAAA,IACxC;AAIA,QAAI,mBAAmB,OAAO,OAAO,EAAE,OAAO,YAAY,MAAM;AAC9D;AAEF,uBAAmB,OAAO,OAAO,EAAE,OAAO,YAAY,IAAI;AAAA,MACxD,KAAK,OAAO;AAAA,MACZ,SAAS,UAAU,gBAAgB,OAAO,IAAI;AAAA,MAC9C,YAAY,OAAO;AAAA,MACnB,UAAU,OAAO;AAAA,MACjB,eAAe,OAAO;AAAA,IACxB;AAAA,EACF;AAGA,QAAM,KAAK,QAAQ,EAAE,QAAQ,QAAQ,eAAe,aAAa,CAAC;AAGlE,QAAM,gBAAgB,mBAAmB,YAAY;AAGrD,aAAW,WAAW,UAAU;AAC9B,UAAM,YAAY,YAAY,mBAAmB,OAAO;AACxD,oBAAgB,QAAQ,OAAO,IAAI,aAAa;AAAA,MAC9C;AAAA,MACA,OAAO,QAAQ;AAAA,IACjB,CAAC,EAAE,OAAO,aAAa;AAAA,EACzB;AAGA,QAAM,aAAoC,CAAC;AAC3C,aAAW,aAAa,OAAO,KAAK,iBAAiB,GAAG;AACtD,eAAW,SAAS,IAAI,CAAC;AACzB,eAAW,WAAW,UAAU;AAC9B,iBAAW,SAAS,EAAE,QAAQ,IAAI,IAAI;AAAA,IACxC;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,cAAc;AAAA,MACZ;AAAA,MACA,SAAS;AAAA,QACP,SAAS,EAAE,MAAM,QAAY,SAAS,OAAW;AAAA,QACjD,WAAW;AAAA,QACX,QAAQ;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,sBAAsB,OACjC,iBACA,EAAE,eAAe,OAAO,MACrB;AACH,QAAM,KAAK,QAAQ;AAAA,IACjB,QAAQ,gBAAgB;AAAA,IACxB;AAAA,IACA;AAAA,IACA,cAAc,gBAAgB,aAAa;AAAA,EAC7C,CAAC;AAED,kBAAgB,aAAa,QAAQ,KAAK;AAC5C;AAEO,IAAM,qBAAqB,OAChC,iBACA;AAAA,EACE;AAAA,EACA;AACF,MAQG;AACH,aAAW,aAAa,OAAO,KAAK,gBAAgB,iBAAiB,GAAG;AACtE,QAAI,CAAC,UAAU,SAAS,QAAQ;AAAG;AAEnC,UAAM,CAAC,YAAY,IAAI,UAAU,MAAM,GAAG;AAE1C,eAAW,WAAW,UAAU;AAC9B,YAAM,SAAS,QAAQ;AAAA,QACrB,CAAC,OACE,YAAY,CAAC,KAAK,mBAAmB,CAAC,MACvC,EAAE,iBAAiB,gBACnB,EAAE,YAAY,QAAQ;AAAA,MAC1B;AAEA,UAAI,gBAAgB;AAAU,eAAO,EAAE,QAAQ,SAAS;AACxD,sBAAgB,WAAW,SAAS,EAAE,OAAO,WAAW;AAExD,YAAM,SAAS,MAAM,aAAa,iBAAiB;AAAA,QACjD,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,QAAQ;AAAA,UACjB,cAAc,OAAO;AAAA,UACrB,YAAY,OAAO,OAAO,UAAU;AAAA,UACpC,mBAAmB,iBAAiB;AAAA,YAClC,GAAG;AAAA,YACH,SAAS,OAAO,QAAQ,OAAO;AAAA,YAC/B,aAAa,OAAO,OAAO,UAAU;AAAA,UACvC,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAED,UAAI,OAAO,WAAW,WAAW;AAC/B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;AAEO,IAAM,gBAAgB,OAC3B,iBACA,EAAE,OAAO,MAKN;AAEH,MAAI,OAAO,SAAS,KAAK,gBAAgB,yBAAyB,QAAW;AAC3E,oBAAgB,uBAAuB;AAAA,MACrC,OAAO,CAAC,EAAE;AAAA,IACZ;AAGA,QAAI,gBAAgB,wBAAwB,QAAW;AACrD,sBAAgB,OAAO,QAAQ,8BAA8B;AAAA,QAC3D,gBAAgB,oBAAoB,iBAClC,gBAAgB,qBAAqB;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAA+C,CAAC;AAEtD,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,gBAAgB;AAAU,aAAO,EAAE,QAAQ,SAAS;AAExD,UAAM,QAAQ,OAAO,CAAC;AAEtB,YAAQ,MAAM,MAAM;AAAA,MAClB,KAAK,OAAO;AACV,cAAM,YAAY,GAAG,MAAM,YAAY,IAAI,MAAM,YAAY;AAE7D,wBAAgB,WAAW,SAAS,EAClC,gBAAgB,iBAAiB,MAAM,OAAO,EAAE,IAClD;AAEA,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,qCAAqC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC7F,CAAC;AAED,cAAM,SAAS,MAAM,WAAW,iBAAiB,EAAE,MAAM,CAAC;AAC1D,YAAI,OAAO,WAAW,WAAW;AAC/B,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,SAAS,MAAM;AAAW,sBAAY,SAAS,IAAI;AACnE,oBAAY,SAAS;AAErB,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,uCAAuC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC/F,CAAC;AAED;AAAA,MACF;AAAA,MAEA,KAAK,SAAS;AACZ,cAAM,YAAY,GAAG,MAAM,UAAU;AAErC,wBAAgB,WAAW,SAAS,EAClC,gBAAgB,iBAAiB,MAAM,OAAO,EAAE,IAClD;AAEA,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,qCAAqC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC7F,CAAC;AAED,cAAM,SAAS,MAAM,aAAa,iBAAiB,EAAE,MAAM,CAAC;AAC5D,YAAI,OAAO,WAAW,WAAW;AAC/B,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,SAAS,MAAM;AAAW,sBAAY,SAAS,IAAI;AACnE,oBAAY,SAAS;AAErB,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,uCAAuC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC/F,CAAC;AAED;AAAA,MACF;AAAA,MAEA,KAAK,aAAa;AAChB,cAAM,YAAY,GAAG,MAAM,YAAY,IAAI,MAAM,YAAY;AAE7D,wBAAgB,WAAW,SAAS,EAClC,gBAAgB,iBAAiB,MAAM,OAAO,EAAE,IAClD;AAEA,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,qCAAqC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC7F,CAAC;AAED,cAAM,SAAS,MAAM,iBAAiB,iBAAiB,EAAE,MAAM,CAAC;AAChE,YAAI,OAAO,WAAW,WAAW;AAC/B,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,SAAS,MAAM;AAAW,sBAAY,SAAS,IAAI;AACnE,oBAAY,SAAS;AAErB,wBAAgB,OAAO,OAAO,MAAM;AAAA,UAClC,SAAS;AAAA,UACT,KAAK,uCAAuC,SAAS,iBAAiB,MAAM,iBAAiB;AAAA,QAC/F,CAAC;AAED;AAAA,MACF;AAAA,MAEA;AACE,cAAM,KAAK;AAAA,IACf;AAGA,QAAI,IAAI,OAAO,GAAG;AAChB,4BAAsB,eAAe;AAErC,YAAM,iBAAiB;AAAA,QACrB,MAAM;AAAA,MACR,EAAE;AAEF,sBAAgB,OAAO,QAAQ,kCAAkC;AAAA,QAC/D,iBAAiB,gBAAgB,qBAAsB;AAAA,MACzD;AACA,sBAAgB,OAAO,QAAQ,oCAAoC;AAAA,QACjE;AAAA,MACF;AAGA,YAAM,IAAI,QAAQ,YAAY;AAAA,IAChC;AAAA,EACF;AAGA,MACE,OAAO,SAAS,KAChB,gBAAgB,yBAAyB,UACzC,gBAAgB,wBAAwB,QACxC;AACA,UAAM,4BAA4B;AAAA,MAChC,OAAO,OAAO,SAAS,CAAC,EAAE;AAAA,IAC5B,EAAE;AAEF,oBAAgB,OAAO,QAAQ,kCAAkC;AAAA,MAC/D,4BACE,gBAAgB,qBAAqB;AAAA,IACzC;AACA,oBAAgB,OAAO,QAAQ,oCAAoC;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAEA,wBAAsB,eAAe;AAErC,aAAW,CAAC,WAAW,KAAK,KAAK,OAAO,QAAQ,WAAW,GAAG;AAC5D,QAAI,UAAU,GAAG;AACf,sBAAgB,OAAO,OAAO,KAAK;AAAA,QACjC,SAAS;AAAA,QACT,KAAK,cAAc,SAAS;AAAA,MAC9B,CAAC;AAAA,IACH,OAAO;AACL,sBAAgB,OAAO,OAAO,KAAK;AAAA,QACjC,SAAS;AAAA,QACT,KAAK,WAAW,KAAK,KAAK,SAAS;AAAA,MACrC,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;AAEO,IAAMC,QAAO,CAAC,oBAA6B;AAChD,kBAAgB,OAAO,OAAO,MAAM;AAAA,IAClC,SAAS;AAAA,IACT,KAAK;AAAA,EACP,CAAC;AACD,kBAAgB,WAAW;AAC7B;AAEO,IAAM,4BAA4B,CACvC,iBACA,wBACG;AACH,kBAAgB,sBAAsB;AAEtC,MAAI,gBAAgB,yBAAyB,QAAW;AACtD,oBAAgB,OAAO,QAAQ,8BAA8B;AAAA,MAC3D,gBAAgB,oBAAoB,iBAClC,gBAAgB,qBAAqB;AAAA,IACzC;AAAA,EACF;AACF;AAEA,IAAM,wBAAwB,CAAC,oBAA6B;AAC1D,aAAW,SAAS,OAAO,KAAK,gBAAgB,UAAU,GAAG;AAC3D,eAAW,WAAW,OAAO,KAAK,gBAAgB,WAAW,KAAK,CAAC,GAAG;AACpE,YAAM,cAAc;AAAA,QAClB;AAAA,QACA;AAAA,MACF;AACA,sBAAgB,OAAO,QAAQ,iCAAiC;AAAA,QAC9D;AAAA,QACA,gBAAgB,WAAW,KAAK,EAAE,OAAO;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,eAAe,OACnB,iBACA,EAAE,MAAM,MAKL;AACH,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,GAAG,MAAM,YAAY;AACvC,QAAM,mBAAmB,kBAAkB,SAAS;AAEpD,QAAM,cAAc,iBAAiB,MAAM,OAAO,EAAE;AACpD,QAAM,cAAc,EAAE,OAAO,WAAW,SAAS,YAAY;AAE7D,MAAI;AAEF,iBAAa,QAAQ,QAAQ,UAAU,MAAM;AAC7C,iBAAa,QAAQ,QAAQ,OAAO,iBAAiB,MAAM,OAAO,EAAE;AACpE,iBAAa,QAAQ,SAAS,gBAAgB,MAAM,OAAO;AAC3D,iBAAa,QAAQ,YAAY,mBAAmB,MAAM,OAAO;AACjE,iBAAa,aAAa,oBAAoB,MAAM;AACpD,iBAAa,aAAa,cAAc,MAAM;AAE9C,UAAM,WAAW,WAAW;AAE5B,UAAM,iBAAiB;AAAA,MACrB,SAAS,aAAa;AAAA,IACxB,CAAC;AAED,WAAO,QAAQ,kCAAkC;AAAA,MAC/C;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,SAAS,QAAQ;AACf,QAAI,gBAAgB;AAAU,aAAO,EAAE,QAAQ,SAAS;AACxD,UAAM,QAAQ;AAEd,WAAO,QAAQ,qCAAqC,IAAI,WAAW;AAEnE,UAAM,oBAAoB,iBAAiB,MAAM,iBAAiB;AAElE,sBAAkB,OAAO,OAAO,OAAO;AAEvC,WAAO,QAAQ,0BAA0B,IAAI,CAAC;AAE9C,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK,2BAA2B,SAAS,eAAe,WAAW,WAAW,kBAAkB,WAAW;AAAA,MAC3G;AAAA,IACF,CAAC;AAED,WAAO,EAAE,QAAQ,SAAS,MAAa;AAAA,EACzC;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;AAEA,IAAM,aAAa,OACjB,iBACA,EAAE,MAAM,MAKL;AACH,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,GAAG,MAAM,YAAY,IAAI,MAAM,YAAY;AAC7D,QAAM,mBAAmB,kBAAkB,SAAS;AAEpD,QAAM,cAAc,iBAAiB,MAAM,OAAO,EAAE;AACpD,QAAM,cAAc,EAAE,OAAO,WAAW,SAAS,YAAY;AAE7D,MAAI;AAEF,iBAAa,QAAQ,QAAQ,UAAU,MAAM;AAC7C,iBAAa,QAAQ,QAAQ,OAAO,iBAAiB,MAAM,OAAO,EAAE;AACpE,iBAAa,QAAQ,SAAS,gBAAgB,MAAM,OAAO;AAC3D,iBAAa,QAAQ,YAAY,mBAAmB,MAAM,OAAO;AACjE,iBAAa,aAAa,oBAAoB,MAAM;AACpD,iBAAa,aAAa,cAAc,MAAM,MAAM,MAAM;AAE1D,UAAM,WAAW,WAAW;AAE5B,UAAM,iBAAiB;AAAA,MACrB,OAAO;AAAA,QACL,MAAM,MAAM;AAAA,QACZ,MAAM,MAAM,MAAM;AAAA,QAClB,KAAK,MAAM,MAAM;AAAA,QACjB,OAAO,MAAM,MAAM;AAAA,QACnB,aAAa,MAAM,MAAM;AAAA,QACzB,oBAAoB,MAAM,MAAM;AAAA,MAClC;AAAA,MACA,SAAS,aAAa;AAAA,IACxB,CAAC;AAED,WAAO,QAAQ,kCAAkC;AAAA,MAC/C;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,SAAS,QAAQ;AACf,QAAI,gBAAgB;AAAU,aAAO,EAAE,QAAQ,SAAS;AACxD,UAAM,QAAQ;AAEd,WAAO,QAAQ,qCAAqC,IAAI,WAAW;AAEnE,UAAM,oBAAoB,iBAAiB,MAAM,iBAAiB;AAElE,sBAAkB,OAAO,OAAO,OAAO;AAEvC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK,2BAA2B,SAAS,eAAe,WAAW,WAAW,kBAAkB,WAAW;AAAA,MAC3G;AAAA,IACF,CAAC;AAED,WAAO,QAAQ,0BAA0B,IAAI,CAAC;AAE9C,WAAO,EAAE,QAAQ,SAAS,MAAa;AAAA,EACzC;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;AAEA,IAAM,eAAe,OACnB,iBACA,EAAE,MAAM,MAKL;AACH,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,GAAG,MAAM,UAAU;AACrC,QAAM,mBAAmB,kBAAkB,SAAS;AAEpD,QAAM,cAAc;AAAA,IAClB,OAAO;AAAA,IACP,SAAS,iBAAiB,MAAM,OAAO,EAAE;AAAA,EAC3C;AAEA,MAAI;AAEF,iBAAa,QAAQ,QAAQ,UAAU,MAAM;AAC7C,iBAAa,QAAQ,QAAQ,OAAO,iBAAiB,MAAM,OAAO,EAAE;AACpE,iBAAa,QAAQ,SAAS,gBAAgB,MAAM,OAAO;AAC3D,iBAAa,QAAQ,YAAY,mBAAmB,MAAM,OAAO;AACjE,iBAAa,aAAa,oBAAoB,MAAM;AACpD,iBAAa,aAAa,cAAc,MAAM,MAAM,MAAM;AAE1D,UAAM,WAAW,WAAW;AAE5B,UAAM,iBAAiB;AAAA,MACrB,OAAO;AAAA,QACL,OAAO,MAAM,MAAM;AAAA,MACrB;AAAA,MACA,SAAS,aAAa;AAAA,IACxB,CAAC;AAED,WAAO,QAAQ,kCAAkC;AAAA,MAC/C;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,SAAS,QAAQ;AACf,QAAI,gBAAgB;AAAU,aAAO,EAAE,QAAQ,SAAS;AACxD,UAAM,QAAQ;AAEd,WAAO,QAAQ,qCAAqC,IAAI,WAAW;AAEnE,UAAM,oBAAoB,iBAAiB,MAAM,iBAAiB;AAElE,sBAAkB,OAAO,OAAO,OAAO;AAEvC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK,0BAA0B,SAAS,qBAAqB,kBAAkB,OAAO,WAAW,kBAAkB,WAAW;AAAA,MAC9H;AAAA,IACF,CAAC;AAED,WAAO,QAAQ,0BAA0B,IAAI,CAAC;AAE9C,WAAO,EAAE,QAAQ,SAAS,MAAa;AAAA,EACzC;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;AAEA,IAAM,mBAAmB,OACvB,iBACA,EAAE,MAAM,MAKL;AACH,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,GAAG,MAAM,YAAY,IAAI,MAAM,YAAY;AAC7D,QAAM,mBAAmB,kBAAkB,SAAS;AAEpD,QAAM,cAAc,iBAAiB,MAAM,OAAO,EAAE;AACpD,QAAM,cAAc,EAAE,OAAO,WAAW,SAAS,YAAY;AAE7D,MAAI;AAEF,iBAAa,QAAQ,QAAQ,UAAU,MAAM;AAC7C,iBAAa,QAAQ,QAAQ,OAAO,iBAAiB,MAAM,OAAO,EAAE;AACpE,iBAAa,QAAQ,SAAS,gBAAgB,MAAM,OAAO;AAC3D,iBAAa,QAAQ,YAAY,mBAAmB,MAAM,OAAO;AACjE,iBAAa,aAAa,oBAAoB,MAAM;AACpD,iBAAa,aAAa,cAAc,MAAM,MAAM,MAAM;AAE1D,UAAM,WAAW,WAAW;AAE5B,UAAM,iBAAiB;AAAA,MACrB,OAAO;AAAA,QACL,MAAM,MAAM,MAAM;AAAA,QAClB,QAAQ,MAAM,MAAM;AAAA,QACpB,OAAO,MAAM,MAAM;AAAA,QACnB,OAAO,MAAM,MAAM;AAAA,QACnB,aAAa,MAAM,MAAM;AAAA,QACzB,oBAAoB,MAAM,MAAM;AAAA,MAClC;AAAA,MACA,SAAS,aAAa;AAAA,IACxB,CAAC;AAED,WAAO,QAAQ,kCAAkC;AAAA,MAC/C;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF,SAAS,QAAQ;AACf,QAAI,gBAAgB;AAAU,aAAO,EAAE,QAAQ,SAAS;AACxD,UAAM,QAAQ;AAEd,WAAO,QAAQ,qCAAqC,IAAI,WAAW;AAEnE,UAAM,oBAAoB,iBAAiB,MAAM,iBAAiB;AAElE,sBAAkB,OAAO,OAAO,OAAO;AAEvC,WAAO,OAAO,MAAM;AAAA,MAClB,SAAS;AAAA,MACT,KAAK,2BAA2B,SAAS,eAAe,WAAW,WAAW,kBAAkB,WAAW;AAAA,MAC3G;AAAA,IACF,CAAC;AAED,WAAO,QAAQ,0BAA0B,IAAI,CAAC;AAE9C,WAAO,EAAE,QAAQ,SAAS,MAAa;AAAA,EACzC;AAEA,SAAO,EAAE,QAAQ,UAAU;AAC7B;;;AG7uBA,IAAMC,WAAU;AAAA,EACd,QAAAC;AAAA,EACA,MAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,wBAAwB,OAAOD,SAAQD,QAAO;;;ACpB3D,OAAO,UAAU;;;ACEV,IAAM,eAAe,CAACG,WAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uDA4CSA,MAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADzC3D,SAAS,wBAAwB;AACjC,SAAS,sBAAsB;AAC/B,SAAS,uBAAuB;AAChC,SAAS,aAAa;AACtB,SAAS,oBAAmC;AAC5C,SAAS,kBAAkB;AAC3B,SAAS,YAAY;AACrB,SAAS,YAAY;AACrB,SAAS,wBAAwB;AACjC,SAAS,4BAA4B;;;AEbrC,OAAO,gBAAgB;AAIhB,SAAS,iBAAiB,EAAE,MAAM,GAA6B;AACpE,QAAM,cAGF,CAAC;AAEL,SAAO,CAAC,EAAE,UAAU,MAA6B;AAC/C,UAAM,SAAU,YAAY,SAAS,MAAM,IAAI;AAAA,MAC7C,OAAO,QAAQ;AACb,cAAM,OAAO,MAAM,MAAM,SAAS;AAAA,UAChC;AAAA,UACA,OAAO,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE;AAAA,UACzB,OAAO,IAAI;AAAA,QACb,CAAC;AAED,eAAO,IAAI,IAAI,CAAC,OAAO,KAAK,MAAM,KAAK,CAAC,QAAQ,IAAI,OAAO,EAAE,CAAC;AAAA,MAChE;AAAA,MACA,EAAE,cAAc,IAAM;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AACF;;;AFAA,eAAsBC,cAAa;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,GAIoB;AAClB,QAAM,OAAO,IAAI,KAEd;AAEH,MAAI,OAAO,OAAO,QAAQ;AAC1B,MAAI,YAAY;AAChB,QAAM,YAAY,KAAK,IAAI;AAE3B,QAAM,oBAAoB,iBAAiB,OAAO,GAAG,SAAS;AAC5D,UAAM,eAAe,EAAE,QAAQ,EAAE,IAAI,QAAQ,MAAM,EAAE,IAAI,KAAK;AAC9D,WAAO,QAAQ,mCAAmC,IAAI,YAAY;AAClE,UAAM,WAAW,WAAW;AAE5B,QAAI;AACF,YAAM,KAAK;AAAA,IACb,UAAE;AACA,YAAM,cAAc,OAAO,EAAE,IAAI,OAAO,gBAAgB,KAAK,CAAC;AAC9D,YAAM,eAAe,OAAO,EAAE,IAAI,QAAQ,IAAI,gBAAgB,KAAK,CAAC;AACpE,YAAM,mBAAmB,SAAS;AAClC,YAAM,SACJ,EAAE,IAAI,UAAU,OAAO,EAAE,IAAI,SAAS,MAClC,QACA,EAAE,IAAI,UAAU,OAAO,EAAE,IAAI,SAAS,MACpC,QACA,EAAE,IAAI,UAAU,OAAO,EAAE,IAAI,SAAS,MACpC,QACA;AAEV,aAAO,QAAQ,mCAAmC,IAAI,YAAY;AAClE,aAAO,QAAQ,sCAAsC;AAAA,QACnD,EAAE,GAAG,cAAc,OAAO;AAAA,QAC1B;AAAA,MACF;AACA,aAAO,QAAQ,uCAAuC;AAAA,QACpD,EAAE,GAAG,cAAc,OAAO;AAAA,QAC1B;AAAA,MACF;AACA,aAAO,QAAQ,uCAAuC;AAAA,QACpD,EAAE,GAAG,cAAc,OAAO;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,oBAAoB,CAACC,WACzB,WAAW;AAAA,IACT,QAAQ;AAAA,IACR,SAAS,MAAM;AACb,YAAM,YAAY,iBAAiB,EAAE,OAAO,cAAc,CAAC;AAC3D,aAAO,EAAE,OAAO,eAAe,UAAU;AAAA,IAC3C;AAAA,IACA,iBAAiBA;AAAA,IACjB,cAAc,QAAQ,IAAI,aAAa;AAAA,IACvC,SAAS;AAAA,IACT,UAAU;AAAA,IACV,0BAA0B;AAAA,IAC1B,SAAS;AAAA,MACP,gBAAgB,EAAE,GAAG,OAAO,QAAQ,0BAA0B,CAAC;AAAA,MAC/D,eAAe;AAAA,QACb,GAAG,OAAO,QAAQ;AAAA,QAClB,qBAAqB;AAAA,MACvB,CAAC;AAAA,MACD,iBAAiB;AAAA,QACf,GAAG,OAAO,QAAQ;AAAA,QAClB,WAAW,CAAC;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AAEH,QAAM,WAAW,kBAAkB,GAAG;AACtC,QAAM,eAAe,aAAa,GAAG;AAErC,QAAM,WAAW,kBAAkB,UAAU;AAC7C,QAAM,eAAe,aAAa,UAAU;AAE5C,OACG,IAAI,KAAK,CAAC,EACV,IAAI,iBAAiB,EACrB,IAAI,YAAY,OAAO,MAAM;AAC5B,QAAI;AACF,YAAM,UAAU,MAAM,OAAO,QAAQ,WAAW;AAChD,aAAO,EAAE,KAAK,OAAO;AAAA,IACvB,SAAS,OAAO;AACd,aAAO,EAAE,KAAK,OAAO,GAAG;AAAA,IAC1B;AAAA,EACF,CAAC,EACA,IAAI,WAAW,OAAO,MAAM;AAC3B,QAAI,WAAW;AACb,aAAO,EAAE,KAAK,IAAI,GAAG;AAAA,IACvB;AAEA,UAAM,WAAW,KAAK,IAAI,IAAI,aAAa;AAC3C,UAAM,MAAM,OAAO,QAAQ;AAE3B,QAAI,UAAU,KAAK;AACjB,aAAO,OAAO,KAAK;AAAA,QACjB,SAAS;AAAA,QACT,KAAK,6EAA6E,GAAG,sBAAsB,OAAO;AAAA,MACpH,CAAC;AACD,aAAO,EAAE,KAAK,IAAI,GAAG;AAAA,IACvB;AAEA,WAAO,EAAE,KAAK,wCAAwC,GAAG;AAAA,EAC3D,CAAC,EAEA,IAAI,YAAY,CAAC,MAAM,EAAE,KAAK,YAAY,CAAC,EAE3C,KAAK,YAAY,CAAC,MAAM;AACvB,QAAI,cAAc,OAAO;AACvB,aAAO,EAAE;AAAA,QACP,EAAE,QAAQ,CAAC,IAAI,aAAa,qCAAqC,CAAC,EAAE;AAAA,QACpE;AAAA,MACF;AAAA,IACF;AAEA,WAAO,SAAS,OAAO,EAAE,IAAI,GAAG;AAAA,EAClC,CAAC,EAEA,IAAI,KAAK,CAAC,MAAM,EAAE,KAAK,YAAY,CAAC,EAEpC,KAAK,KAAK,CAAC,MAAM,SAAS,OAAO,EAAE,IAAI,GAAG,CAAC;AAE9C,QAAM,oCAA8D,IAC/D,SACA;AACH,UAAMC,cAAa,KAAK,aAAa,GAAG,IAAI;AAE5C,UAAM,eAAe,CAAC,UAAoC;AACxD,UAAI,MAAM,SAAS,cAAc;AAC/B,eAAO,OAAO,KAAK;AAAA,UACjB,SAAS;AAAA,UACT,KAAK,QAAQ,IAAI,4BAA4B,OAAO,CAAC;AAAA,QACvD,CAAC;AACD,gBAAQ;AACR,mBAAW,MAAM;AACf,UAAAA,YAAW,MAAM;AACjB,UAAAA,YAAW,OAAO,MAAM,OAAO,QAAQ,QAAQ;AAAA,QACjD,GAAG,CAAC;AAAA,MACN;AAAA,IACF;AAEA,UAAM,kBAAkB,MAAM;AAC5B,aAAO,QAAQ,wBAAwB,IAAI,IAAI;AAC/C,aAAO,OAAO,KAAK;AAAA,QACjB,SAAS;AAAA,QACT,KAAK,6BAA6B,IAAI;AAAA,MACxC,CAAC;AACD,MAAAA,YAAW,IAAI,SAAS,YAAY;AAAA,IACtC;AAEA,IAAAA,YAAW,GAAG,SAAS,YAAY;AACnC,IAAAA,YAAW,GAAG,aAAa,eAAe;AAE1C,WAAOA;AAAA,EACT;AAEA,QAAM,aAAa,MAAM,IAAI,QAAqB,CAACC,UAAS,WAAW;AACrE,UAAM,UAAU,WAAW,MAAM;AAC/B,aAAO,IAAI,MAAM,+CAA+C,CAAC;AAAA,IACnE,GAAG,GAAK;AAER,UAAMD,cAAa;AAAA,MACjB;AAAA,QACE,OAAO,KAAK;AAAA,QACZ,cAAc;AAAA,QACd;AAAA;AAAA;AAAA;AAAA,QAIA,UAAU,OAAO,QAAQ;AAAA,MAC3B;AAAA,MACA,MAAM;AACJ,qBAAa,OAAO;AACpB,QAAAC,SAAQD,WAAyB;AAAA,MACnC;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,aAAa,qBAAqB;AAAA,IACtC,QAAQ;AAAA,IACR,4BAA4B;AAAA,EAC9B,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,YAAY,MAAM;AAChB,kBAAY;AAAA,IACd;AAAA,IACA,MAAM,MAAM,WAAW,UAAU;AAAA,EACnC;AACF;;;AGpNO,SAAS,wBAAwB;AAAA,EACtC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAEG;AACD,SAAO,kBAAkB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,YAAY,CAAC,UAAU,SAAS,SAAS,SAAS,YAChD,GAAG,OAAO,IAAI,QAAQ,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,IAChE,6BAA6B,IAAI,CACnC;AAAA,EACJ,CAAC;AACH;AAQO,SAAS,yBAAyB;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAEG;AACD,QAAM,YAAY,kBAAkB;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,YAAY,CAAC,UAAU,SAAS,SAAS,SAAS,YAChD,GAAG,OAAO,IAAI,QAAQ,IAAI,aAAa,IAAI,oBAAoB,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,IACzG,6BAA6B,IAAI,CACnC;AAAA,EACJ,CAAC;AAED,SAAO;AACT;AAEA,SAAS,kBAAkB;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,GAAG;AACL,GASG;AACD,QAAM,YASA,CAAC;AAEP,QAAM,EAAE,QAAQ,QAAQ,QAAQ,OAAO,IAAI,YAAY,MAAM;AAE7D,aAAW,YAAY,MAAM,QAAQ,OAAO,IAAI,UAAU,CAAC,WAAW,IAAI,GAAG;AAC3E,eAAW,WAAW,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,GAAG;AAC/D,iBAAW,WAAW,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,GAAG;AAC/D,mBAAW,WAAW,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,GAAG;AAC/D,qBAAW,WAAW,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,GAAG;AAC/D,sBAAU,KAAK;AAAA,cACb,IAAI,WAAW,UAAU,SAAS,SAAS,SAAS,OAAO;AAAA,cAC3D,GAAG;AAAA,cACH;AAAA,cACA,SAAS;AAAA,cACT,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,4BAA4B,6BAA6B,IAAI;AAAA,YAC/D,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,YAAY,QAA4C;AAC/D,SAAO;AAAA,IACL,QAAQ,SAAS,CAAC,KAAK;AAAA,IACvB,QAAQ,SAAS,CAAC,KAAK;AAAA,IACvB,QAAQ,SAAS,CAAC,KAAK;AAAA,IACvB,QAAQ,SAAS,CAAC,KAAK;AAAA,EACzB;AAMF;AAEO,SAAS,oBAAoB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AACF,GAEG;AACD,QAAM,YAKA,CAAC;AAEP,aAAW,gBAAgB,MAAM,QAAQ,WAAW,IAChD,cACA,CAAC,IAAI,GAAG;AACV,eAAW,cAAc,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,IAAI,GAAG;AACtE,gBAAU,KAAK;AAAA,QACb,IAAI,GAAG,OAAO,IAAI,YAAY,IAAI,UAAU;AAAA,QAC5C;AAAA,QACA,aAAa;AAAA,QACb,WAAW;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,2BAA2B;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAEG;AACD,QAAM,YAIwB,CAAC;AAE/B,aAAW,gBAAgB,MAAM,QAAQ,WAAW,IAChD,cACA,CAAC,IAAI,GAAG;AACV,cAAU,KAAK;AAAA,MACb,IAAI,GAAG,OAAO,IAAI,OAAO,IAAI,aAAa,IAAI,oBAAoB,IAAI,YAAY;AAAA,MAClF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;AC7LO,SAAS,YAAY,WAA+B;AACzD,MAAI,WAAW;AAEf,aAAW,CAACE,QAAO,GAAG,KAAK,WAAW;AACpC,gBAAY,MAAMA,SAAQ;AAAA,EAC5B;AAEA,SAAO;AACT;AAQO,SAAS,cAAc,YAAgC;AAC5D,MAAI,WAAW,WAAW;AAAG,WAAO,CAAC;AAGrC,QAAM,YAAY,WAAW;AAAA,IAC3B,CAAC,aAAa,CAAC,GAAG,QAAQ;AAAA,EAC5B;AAEA,YAAU,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAEpC,QAAM,SAA6B,CAAC;AACpC,MAAI,kBAAkB,UAAU,CAAC;AAEjC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAM,eAAe,UAAU,CAAC;AAEhC,QAAI,gBAAgB,CAAC,KAAK,aAAa,CAAC,IAAI,GAAG;AAE7C,sBAAgB,CAAC,IAAI,KAAK,IAAI,gBAAgB,CAAC,GAAG,aAAa,CAAC,CAAC;AAAA,IACnE,OAAO;AAEL,aAAO,KAAK,eAAe;AAC3B,wBAAkB;AAAA,IACpB;AAAA,EACF;AAEA,SAAO,KAAK,eAAe;AAC3B,SAAO;AACT;AASO,SAAS,qBACd,OACA,OACA;AACA,QAAM,SAA6B,CAAC;AACpC,MAAI,IAAI;AACR,MAAI,IAAI;AAER,SAAO,IAAI,MAAM,UAAU,IAAI,MAAM,QAAQ;AAC3C,UAAM,CAAC,QAAQ,IAAI,IAAI,MAAM,CAAC;AAC9B,UAAM,CAACC,SAAQ,IAAI,IAAI,MAAM,CAAC;AAE9B,UAAM,oBAAoB,KAAK,IAAI,QAAQA,OAAM;AACjD,UAAM,kBAAkB,KAAK,IAAI,MAAM,IAAI;AAE3C,QAAI,qBAAqB,iBAAiB;AACxC,aAAO,KAAK,CAAC,mBAAmB,eAAe,CAAC;AAAA,IAClD;AAEA,QAAI,OAAO,MAAM;AACf;AAAA,IACF,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAGA,SAAO,cAAc,MAAM;AAC7B;AASO,SAAS,yBAAyB,OAA6B;AACpE,MAAI,MAAM,WAAW;AAAG,WAAO,CAAC;AAChC,MAAI,MAAM,WAAW;AAAG,WAAO,MAAM,CAAC;AAEtC,MAAI,SAA6B,MAAM,CAAC;AAExC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,aAAS,qBAAqB,QAAQ,MAAM,CAAC,CAAC;AAAA,EAChD;AAEA,SAAO,cAAc,MAAM;AAC7B;AASO,SAAS,mBACd,SACA,QACA;AAEA,QAAM,WAAW,QAAQ,IAAI,CAAC,aAAa,CAAC,GAAG,QAAQ,CAAqB;AAC5E,QAAM,UAAU,OAAO,IAAI,CAAC,aAAa,CAAC,GAAG,QAAQ,CAAqB;AAE1E,QAAM,SAA6B,CAAC;AAEpC,MAAI,IAAI;AACR,MAAI,IAAI;AAER,SAAO,IAAI,QAAQ,UAAU,IAAI,OAAO,QAAQ;AAC9C,UAAM,YAAY,SAAS,CAAC;AAC5B,UAAM,YAAY,QAAQ,CAAC;AAE3B,QAAI,UAAU,CAAC,IAAI,UAAU,CAAC,GAAG;AAE/B,aAAO,KAAK,SAAS;AACrB;AAAA,IACF,WAAW,UAAU,CAAC,IAAI,UAAU,CAAC,GAAG;AAEtC;AAAA,IACF,OAAO;AAEL,UAAI,UAAU,CAAC,IAAI,UAAU,CAAC,GAAG;AAE/B,eAAO,KAAK,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;AAAA,MAC9C;AACA,UAAI,UAAU,CAAC,IAAI,UAAU,CAAC,GAAG;AAE/B,kBAAU,CAAC,IAAI,UAAU,CAAC,IAAI;AAC9B;AAAA,MACF,OAAO;AAEL;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,SAAO,IAAI,SAAS,QAAQ;AAC1B,WAAO,KAAK,SAAS,CAAC,CAAC;AACvB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,UAAU;AAAA,EACxB;AAAA,EACA;AACF,GAGG;AACD,QAAM,UAA8B,CAAC;AAErC,aAAW,YAAY,WAAW;AAChC,UAAM,CAAC,YAAY,QAAQ,IAAI;AAE/B,QAAI,YAAY;AAChB,QAAI,UAAU,KAAK,IAAI,YAAY,eAAe,GAAG,QAAQ;AAE7D,WAAO,aAAa,UAAU;AAC5B,cAAQ,KAAK,CAAC,WAAW,OAAO,CAAC;AAEjC,kBAAY,UAAU;AACtB,gBAAU,KAAK,IAAI,YAAY,eAAe,GAAG,QAAQ;AAAA,IAC3D;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,kBAAN,MAAsB;AAAA,EAC3B;AAAA,EACQ;AAAA,EACA,YAAuC;AAAA,EACvC,cAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOrC,YAAY;AAAA,IACV;AAAA,IACA;AAAA,EACF,GAGG;AACD,QAAI,OAAO,CAAC,IAAI,OAAO,CAAC;AACtB,YAAM,IAAI;AAAA,QACR,4BAA4B,OAAO,CAAC,CAAC,0BAA0B,OAAO,CAAC,CAAC;AAAA,MAC1E;AAEF,SAAK,SAAS;AACd,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB,UAA4B;AAC/C,QAAI,SAAS,CAAC,IAAI,SAAS,CAAC;AAC1B,YAAM,IAAI;AAAA,QACR,4BAA4B,SAAS,CAAC,CAAC,0BAA0B,SAAS,CAAC,CAAC;AAAA,MAC9E;AAEF,UAAM,iBAAiB,KAAK,cAAc;AAC1C,SAAK,aAAa,cAAc,CAAC,GAAG,KAAK,YAAY,QAAQ,CAAC;AAC9D,SAAK,gBAAgB;AACrB,UAAM,gBAAgB,KAAK,cAAc;AAEzC,WAAO;AAAA,MACL,WAAW,gBAAgB;AAAA,MAC3B;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,QAAI,KAAK,cAAc,MAAM;AAC3B,WAAK,YAAY,mBAAmB,CAAC,KAAK,MAAM,GAAG,KAAK,UAAU;AAAA,IACpE;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB;AACd,QAAI,KAAK,gBAAgB;AAAM,aAAO,KAAK;AAE3C,UAAM,wCAAwC,KAAK,WAChD,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAC1B,KAAK,CAAC,MAAM,EAAE,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK,EAAE,CAAC,KAAK,KAAK,OAAO,CAAC,CAAC;AAE/D,QAAI,uCAAuC;AACzC,WAAK,cAAc,sCAAsC,CAAC;AAAA,IAC5D,OAAO;AACL,WAAK,cAAc,KAAK,OAAO,CAAC,IAAI;AAAA,IACtC;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,kBAAkB;AACxB,SAAK,YAAY;AACjB,SAAK,cAAc;AAAA,EACrB;AACF;AAMO,IAAM,uBAAN,MAA2B;AAAA,EACxB,gBAA0B,CAAC;AAAA,EAC3B,kBAGF,CAAC;AAAA,EAEP,aAAqE;AAAA,EAErE,iBAAiB,EAAE,aAAa,GAAqC;AACnE,QAAI,aAAa,WAAW;AAAG;AAE/B,UAAM,kBAAkB,KAAK,cAAc,KAAK,cAAc,SAAS,CAAC;AAExE,UAAM,SAAS,aAAa,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAChD,UAAM,qBAAqB,OAAO,CAAC;AAEnC,QACE,KAAK,cAAc,SAAS,KAC5B,sBAAsB,iBACtB;AACA,YAAM,IAAI;AAAA,QACR,4BAA4B,kBAAkB,uDAAuD,eAAe;AAAA,MACtH;AAAA,IACF;AAEA,WAAO,QAAQ,CAAC,gBAAgB;AAC9B,WAAK,cAAc,KAAK,WAAW;AAAA,IACrC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB;AAAA,IAChB;AAAA,IACA;AAAA,EACF,GAGG;AAED,UAAM,oBAAoB,KAAK,cAAc;AAAA,MAC3C,CAAC,iBAAiB,iBAAiB;AAAA,IACrC;AACA,QAAI,sBAAsB,IAAI;AAC5B,YAAM,IAAI;AAAA,QACR,gBAAgB,WAAW;AAAA,MAC7B;AAAA,IACF;AACA,SAAK,cAAc,OAAO,mBAAmB,CAAC;AAI9C,SAAK,gBAAgB,KAAK,EAAE,aAAa,eAAe,CAAC;AACzD,SAAK,gBAAgB,KAAK,CAAC,GAAG,MAAM,EAAE,cAAc,EAAE,WAAW;AAIjE,QAAI,KAAK,cAAc,WAAW,GAAG;AACnC,WAAK,aAAa,KAAK,gBAAgB,KAAK,gBAAgB,SAAS,CAAC;AACtE,aAAO,KAAK;AAAA,IACd;AAIA,UAAM,sBAAsB,KAAK,gBAAgB;AAAA,MAC/C,CAAC,EAAE,aAAAC,aAAY,MAAMA,eAAc,KAAK,cAAc,CAAC;AAAA,IACzD;AAGA,QAAI,oBAAoB,WAAW;AAAG,aAAO;AAE7C,UAAM,4BACJ,oBAAoB,oBAAoB,SAAS,CAAC;AAIpD,SAAK,kBAAkB,KAAK,gBAAgB;AAAA,MAC1C,CAAC,EAAE,aAAAA,aAAY,MAAMA,gBAAe,0BAA0B;AAAA,IAChE;AAIA,QACE,CAAC,KAAK,cACN,0BAA0B,cAAc,KAAK,WAAW,aACxD;AACA,WAAK,aAAa;AAClB,aAAO,KAAK;AAAA,IACd;AAGA,WAAO;AAAA,EACT;AACF;;;ACpXO,IAAM,QAAQ,CAACC,QAAe,SACnC,MAAM,KAAK,EAAE,QAAQ,OAAOA,OAAM,GAAG,CAAC,GAAG,MAAMA,SAAQ,CAAC;;;AC8B1D;AAAA,EAKE,OAAAC;AAAA,OACK;AACP;AAAA,EAME,mBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,eAAAC;AAAA,OACK;;;AClDP;AAAA,EAKE;AAAA,OACK;AACP;AAAA,EAIE;AAAA,OACK;AA6BA,SAAS,mBACd,OACiD;AACjD,SAAO;AAAA,IACL,eAAe,MAAM,gBAAgB,OAAO,MAAM,aAAa,IAAI;AAAA,IACnE,YAAY,OAAO,MAAM,UAAU;AAAA,IACnC,WAAW,MAAM;AAAA,IACjB,UAAU,OAAO,MAAM,QAAQ;AAAA,IAC/B,SAAS,OAAO,MAAM,OAAO;AAAA,IAC7B,MAAM,MAAM;AAAA,IACZ,WAAW,MAAM;AAAA,IACjB,OAAO,YAAY,MAAM,KAAK;AAAA,IAC9B,SAAS,MAAM,WAAW;AAAA,IAC1B,OAAO,MAAM,SAAS;AAAA,IACtB,QAAQ,OAAO,MAAM,MAAO;AAAA,IAC5B,YAAY,MAAM;AAAA,IAClB,cAAc,MAAM;AAAA,IACpB,YAAY,MAAM,cAAc;AAAA,IAChC,MAAM,OAAO,MAAM,IAAI;AAAA,IACvB,WAAW,MAAM;AAAA,IACjB,WAAW,OAAO,MAAM,SAAS;AAAA,IACjC,iBAAiB,MAAM,kBACnB,OAAO,MAAM,eAAe,IAC5B;AAAA,IACJ,kBAAkB,MAAM;AAAA,EAC1B;AACF;AA4BO,SAAS,yBACd,aACwC;AACxC,SAAO;AAAA,IACL,YAAY,YAAY,aACpB,KAAK,UAAU,YAAY,UAAU,IACrC;AAAA,IACJ,WAAW,YAAY;AAAA,IACvB,aAAa,OAAO,YAAY,WAAY;AAAA,IAC5C,MAAM,YAAY,YAAY,IAAI;AAAA,IAClC,KAAK,OAAO,YAAY,GAAG;AAAA,IAC3B,UAAU,YAAY,WAAW,OAAO,YAAY,QAAQ,IAAI;AAAA,IAChE,MAAM,YAAY;AAAA,IAClB,OAAO,YAAY;AAAA,IACnB,cAAc,YAAY,eACtB,OAAO,YAAY,YAAY,IAC/B;AAAA,IACJ,sBAAsB,YAAY,uBAC9B,OAAO,YAAY,oBAAoB,IACvC;AAAA,IACJ,OAAO,YAAY,YAAY,KAAK;AAAA,IACpC,GAAG,YAAY,KAAK;AAAA,IACpB,GAAG,YAAY,KAAK;AAAA,IACpB,IAAI,YAAY,KAAK,YAAY,YAAY,EAAE,IAAI;AAAA,IACnD,kBAAkB,OAAO,YAAY,gBAAgB;AAAA,IACrD,MAAM,YAAY,QAAQ;AAAA,IAC1B,OAAO,OAAO,YAAY,KAAK;AAAA,IAC/B,GAAG,YAAY,IAAI,OAAO,YAAY,CAAC,IAAI;AAAA,EAC7C;AACF;AAwBO,SAAS,gCACd,oBAC2C;AAC3C,SAAO;AAAA,IACL,WAAW,mBAAmB;AAAA,IAC9B,aAAa,OAAO,mBAAmB,WAAW;AAAA,IAClD,iBAAiB,mBAAmB,kBAChC,YAAY,mBAAmB,eAAe,IAC9C;AAAA,IACJ,mBAAmB,OAAO,mBAAmB,iBAAiB;AAAA,IAC9D,mBAAmB,OAAO,mBAAmB,iBAAiB;AAAA,IAC9D,MAAM,YAAY,mBAAmB,IAAI;AAAA,IACzC,SAAS,OAAO,mBAAmB,OAAO;AAAA,IAC1C,MAAM,KAAK,UAAU,mBAAmB,IAAI;AAAA,IAC5C,WAAW,mBAAmB;AAAA,IAC9B,QAAQ,mBAAmB;AAAA,IAC3B,IAAI,mBAAmB,KAAK,YAAY,mBAAmB,EAAE,IAAI;AAAA,IACjE,iBAAiB,mBAAmB;AAAA,IACpC,kBAAkB,OAAO,mBAAmB,gBAAgB;AAAA,IAC5D,MAAM,mBAAmB;AAAA,EAC3B;AACF;AAuBO,SAAS,iBAAiB,KAA6C;AAC5E,SAAO;AAAA,IACL,SAAS,YAAY,IAAI,OAAO;AAAA,IAChC,WAAW,IAAI;AAAA,IACf,aAAa,OAAO,IAAI,WAAY;AAAA,IACpC,MAAM,IAAI;AAAA,IACV,IAAI,GAAG,IAAI,SAAS,IAAI,IAAI,QAAQ;AAAA,IACpC,UAAU,OAAO,IAAI,QAAS;AAAA,IAC9B,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,iBAAiB,IAAI;AAAA,IACrB,kBAAkB,OAAO,IAAI,gBAAiB;AAAA,EAChD;AACF;AA0BO,SAAS,mBACd,OACqD;AACrD,SAAO;AAAA,IACL,IAAI,GAAG,MAAM,eAAe,IAAI,KAAK,UAAU,MAAM,YAAY,CAAC;AAAA,IAClE,UAAU,MAAM,OAAO;AAAA,IACvB,MAAM,YAAY,MAAM,OAAO,IAAI;AAAA,IACnC,KAAK,YAAY,MAAM,OAAO,GAAG;AAAA,IACjC,OAAO,MAAM,OAAO;AAAA,IACpB,IAAI,YAAY,MAAM,OAAO,EAAE;AAAA,IAC/B,OAAO,YAAY,MAAM,OAAO,KAAK;AAAA,IACrC,WAAW,MAAM;AAAA,IACjB,aAAa,YAAY,MAAM,WAAW;AAAA,IAC1C,OAAO,MAAM,SAAS;AAAA,IACtB,SAAS,MAAM,SAAS,YAAY,MAAM,OAAO,OAAO,IAAI;AAAA,IAC5D,QAAQ,MAAM,SAAS,MAAM,OAAO,SAAS;AAAA,IAC7C,WAAW,MAAM;AAAA,IACjB,cAAc,KAAK,UAAU,MAAM,YAAY;AAAA,IAC/C,iBAAiB,MAAM;AAAA,IACvB,qBAAqB,MAAM;AAAA,IAC3B,kBAAkB,MAAM,OAAO,MAAM,MAAM,GAAG,EAAE,EAAE,YAAY;AAAA,EAChE;AACF;;;ADjMO,IAAM,oBAAN,MAA6C;AAAA,EAClD,OAAO;AAAA,EACP;AAAA,EAEA,YAAY,EAAE,GAAG,GAA4C;AAC3D,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,mBAAmB,QAAQ;AAAA,UAC9B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,iBAAiB;AAAA,YACzD,GAAG,yBAAyB,WAAW;AAAA,YACvC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,gCAAgC,qBAAqB;AAAA,cACxD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,QACb;AAEA,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,iBAAiB,MAAM;AAAA,YAC1B;AAAA,YACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,UAChE,EAAE;AACF,gBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,cACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,YAC1C,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,yBAAyB;AAAA,UAClC;AAAA,UACA;AAAA,UACA,YAAY,CAAC,SAAS;AAAA,UACtB;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,wBAAwB,OAAO;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,wBAAwB,GAAG,YAAY;AACnE,YAAM,YAAY,wBAAwB,EAAE,GAAG,WAAW,QAAQ,CAAC;AAGnE,YAAM,QAAQ;AAAA,QACZ,UAAU,IAAI,OAAO,aAAa;AAChC,iBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,kBAAM,EAAE,IAAI,YAAY,IAAI,MAAM,GAC/B,WAAW,YAAY,EACvB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,kBAAM,uBAAuB,MAAM,GAChC,WAAW,oBAAoB,EAC/B,MAAM,eAAe,KAAK,WAAW,EACrC,aAAa,EACb,QAAQ;AAEX,kBAAM,kBAAkB;AAAA,cACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,gBAC9B,OAAO,EAAE,UAAU;AAAA,gBACnB,OAAO,EAAE,QAAQ;AAAA,cACnB,CAAC;AAAA,YACH;AAEA,kBAAM,qBAAqB,gBAAgB;AAAA,cACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,gBAC3B;AAAA,gBACA,YAAY,OAAO,UAAU;AAAA,gBAC7B,UAAU,OAAO,QAAQ;AAAA,cAC3B;AAAA,YACF;AAEA,gBAAI,mBAAmB,SAAS,GAAG;AACjC,oBAAM,GACH,WAAW,oBAAoB,EAC/B,OAAO,kBAAkB,EACzB,QAAQ;AAAA,YACb;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,YAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,QACC;AAAA,QACA,MACEC,gBAAeA,KAAI;AAAA,UACjB,UAAU;AAAA,YACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,cACnD,EAAE;AAAA,YACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI;AAAA,cACpD,EAAE;AAAA,YACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,0BAA0B,CAAC;AAAA,UAC/C;AAAA,QACF,CAAC;AAAA,MACL,EACC,WAAW,oBAAoB,EAC/B,UAAU,cAAc,eAAe,eAAe,EACtD,UAAU,sBAAsB,CAAC,SAAS;AACzC,YAAI,WAAW,KAAK;AAAA,UAAG,CAAC,OACtB,GAAG,GAAG;AAAA,YACJ,GAAG,WAAW,MAAM,IAAI;AAAA,YACxB,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,UAC/C,CAAC;AAAA,QACH;AACA,mBAAW,SAAS;AAAA,UAAG,CAAC,OACtB;AAAA,YACE;AAAA,YACA;AAAA,YACAA,KAAI,IAAI,4BAA4B;AAAA,UACtC;AAAA,QACF;AACA,mBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,qBAAW,SAAS,GAAG,CAAC,OAAO;AAC7B,kBAAM,MAAM;AACZ,mBAAO,GAAG,GAAG;AAAA,cACX,GAAG,QAAQ,GAAG,IAAI,MAAM,IAAI;AAAA,cAC5B,GAAG,gBAAgB,GAAG,IAAI,KAAKA,KAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AAAA,YACvD,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,eAAO;AAAA,MACT,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAM,wBAAwB,UAAU;AAAA,QACtC,CAAC,KAAK,QAAQ;AACZ,gBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,WAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO,UAAU,GAAG,OAAO,QAAQ,CAAC,CAAC;AACpE,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAEA,YAAM,2BAA2B,UAAU;AAAA,QAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,MACjD;AACA,aAAO,yBAAyB,wBAAwB;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,gCAAgC,OAAO;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,EACR,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,gCAAgC;AAAA,MAC1C,YAAY;AACV,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,iBAAiB,MAAM;AAAA,YAC1B;AAAA,UACF,EAAE;AACF,gBAAM,KAAK,GACR,WAAW,MAAM,EACjB,OAAO,IAAI,EACX,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,yBAAyB;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW;AAAA,EACb,GAMG;AACD,UAAM,EAAE,SAAS,eAAe,qBAAqB,IAAI;AACzD,UAAM,+BACJ,yCAAyC,EAAE,qBAAqB,CAAC;AAEnE,UAAM,YAAY,KAAK,GACpB,WAAW,MAAM,EACjB,OAAO,CAAC,MAAM,6BAA6B,GAAG,cAAc,CAAC,CAAC,EAC9D,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,UAAU,KAAK,aAAa,EAClC,MAAM,eAAe,MAAM,SAAS,EACpC,MAAM,eAAe,MAAM,OAAO,EAClC,QAAQ,MAAM,KAAK,EACnB,MAAM,QAAQ;AAEjB,QAAI,SAA6B;AAEjC,WAAO,MAAM;AACX,UAAIC,SAAQ;AACZ,UAAI,WAAW;AAAW,QAAAA,SAAQA,OAAM,MAAM,MAAM,KAAK,MAAM;AAE/D,YAAM,QAAQ,MAAM,KAAK,GAAG;AAAA,QAC1B,EAAE,QAAQ,2BAA2B;AAAA,QACrC,MAAMA,OAAM,QAAQ;AAAA,MACtB;AAEA,UAAI,MAAM,SAAS,GAAG;AACpB,cAAM,MAAM,IAAI,CAAC,MAAM,EAAE,YAAY;AAAA,MACvC;AAGA,UAAI,MAAM,SAAS;AAAU;AAE7B,eAAS,MAAM,MAAM,SAAS,CAAC,EAAE;AAAA,IACnC;AAAA,EACF;AAAA,EAEA,iCAAiC,OAAO;AAAA,IACtC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,iCAAiC;AAAA,MAC3C,YAAY;AACV,cAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,mBAAmB,QAAQ;AAAA,YAC9B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,cAAI,gBAAgB,SAAS,GAAG;AAC9B,kBAAM,eAAe,gBAAgB,IAAI,CAAC,iBAAiB;AAAA,cACzD,GAAG,yBAAyB,WAAW;AAAA,cACvC;AAAA,YACF,EAAE;AACF,kBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,UACb;AAEA,cAAI,uBAAuB,SAAS,GAAG;AACrC,kBAAM,sBAAsB,uBAAuB;AAAA,cACjD,CAAC,2BAA2B;AAAA,gBAC1B,GAAG,gCAAgC,qBAAqB;AAAA,gBACxD;AAAA,cACF;AAAA,YACF;AACA,kBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,UACb;AAEA,cAAI,QAAQ,SAAS,GAAG;AACtB,kBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,cACpC,GAAG,iBAAiB,MAAM;AAAA,cAC1B;AAAA,cACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,YAChE,EAAE;AAEF,kBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,cAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,gBACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,cAC1C,EAAE;AAAA,YACJ,EACC,QAAQ;AAAA,UACb;AAEA,gBAAM,KAAK,gCAAgC;AAAA,YACzC;AAAA,YACA;AAAA,YACA,mBAAmB,CAAC,OAAO;AAAA,YAC3B;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,+BAA+B,OAAO;AAAA,IACpC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,+BAA+B;AAAA,MACzC,YAAY;AACV,cAAM,YAAY,yBAAyB,EAAE,GAAG,SAAS,QAAQ,CAAC;AAElE,cAAM,QAAQ;AAAA,UACZ,UAAU,IAAI,OAAO,aAAa;AAChC,kBAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,oBAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,mBAAmB,EAC9B,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,oBAAM,oBAAoB,MAAM,GAC7B,WAAW,2BAA2B,EACtC,MAAM,aAAa,KAAK,SAAS,EACjC,aAAa,EACb,QAAQ;AAEX,oBAAM,kBAAkB;AAAA,gBACtB,kBAAkB,IAAI,CAAC,MAAM;AAAA,kBAC3B,OAAO,EAAE,UAAU;AAAA,kBACnB,OAAO,EAAE,QAAQ;AAAA,gBACnB,CAAC;AAAA,cACH;AAEA,oBAAM,qBAAqB,gBAAgB;AAAA,gBACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,kBAC3B;AAAA,kBACA,YAAY,OAAO,UAAU;AAAA,kBAC7B,UAAU,OAAO,QAAQ;AAAA,gBAC3B;AAAA,cACF;AAEA,kBAAI,mBAAmB,SAAS,GAAG;AACjC,sBAAM,GACH,WAAW,2BAA2B,EACtC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,cACb;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,cAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,UACC;AAAA,UACA,MACED,gBAAeA,KAAI;AAAA,YACjB,UAAU;AAAA,cACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,gBACnD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,oBAAoB,CAAC,KAAKA,KAAI;AAAA,gBAC5C,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI;AAAA,gBACpD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,0BAA0B,CAAC;AAAA,YAC/C;AAAA,UACF,CAAC;AAAA,QACL,EACC,WAAW,2BAA2B,EACtC,UAAU,qBAAqB,aAAa,sBAAsB,EAClE,UAAU,0BAA0B,CAAC,SAAS;AAC7C,cAAI,WAAW,KAAK;AAAA,YAAG,CAAC,OACtB,GAAG,IAAI;AAAA,cACL,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,cAC7C,GAAG,yBAAyB,KAAKA,KAAI,IAAI,eAAe,CAAC;AAAA,cACzD;AAAA,gBACE;AAAA,gBACA;AAAA,gBACAA,KAAI,IAAI,sBAAsB;AAAA,cAChC;AAAA,YACF,CAAC;AAAA,UACH;AACA,qBAAW,SAAS;AAAA,YAAG,CAAC,OACtB;AAAA,cACE;AAAA,cACA;AAAA,cACAA,KAAI,IAAI,4BAA4B;AAAA,YACtC;AAAA,UACF;AACA,qBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,uBAAW,SAAS,GAAG,CAAC,OAAO;AAC7B,oBAAM,MAAM;AACZ,qBAAO,GAAG,GAAG;AAAA,gBACX,GAAG,QAAQ,GAAG,IAAI,MAAM,IAAI;AAAA,gBAC5B,GAAG,gBAAgB,GAAG,IAAI,KAAKA,KAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AAAA,cACvD,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAEA,iBAAO;AAAA,QACT,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,cAAM,wBAAwB,UAAU;AAAA,UACtC,CAAC,KAAK,QAAQ;AACZ,kBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,aAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK;AAAA,cAC5B,OAAO,UAAU;AAAA,cACjB,OAAO,QAAQ;AAAA,YACjB,CAAC;AACD,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,2BAA2B,UAAU;AAAA,UAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,QACjD;AACA,eAAO,yBAAyB,wBAAwB;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,4BAA4B,OAAO;AAAA,IACjC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP;AAAA,EACF,MAKqB;AACnB,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACvE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,YAAI,aAAa,QAAW;AAC1B,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,mBAAmB,QAAQ;AAAA,YAC9B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA,cAAc,CAAC,WAAW;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,WAAW;AAAA,QACf,IAAI,GAAG,OAAO,IAAI,YAAY,QAAQ,IAAI,YAAY,MAAM;AAAA,QAC5D;AAAA,QACA,UAAU,YAAY;AAAA,QACtB,QAAQ,YAAY;AAAA,MACtB;AAGA,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,cAAM,uBAAuB,MAAM,GAChC,WAAW,sBAAsB,EACjC,MAAM,iBAAiB,KAAK,aAAa,EACzC,aAAa,EACb,QAAQ;AAEX,cAAM,kBAAkB;AAAA,UACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,YAC9B,OAAO,EAAE,UAAU;AAAA,YACnB,OAAO,EAAE,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAEA,cAAM,qBAAqB,gBAAgB;AAAA,UACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,YAC3B;AAAA,YACA,YAAY,OAAO,UAAU;AAAA,YAC7B,UAAU,OAAO,QAAQ;AAAA,UAC3B;AAAA,QACF;AAEA,YAAI,mBAAmB,SAAS,GAAG;AACjC,gBAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAED,YAAM,YAAY,MAAM,KAAK,GAC1B,WAAW,sBAAsB,EACjC,UAAU,gBAAgB,iBAAiB,iBAAiB,EAC5D,OAAO;AAAA,QACN;AAAA,QACA;AAAA,MACF,CAAC,EACA,MAAM,iBAAiB,KAAK,SAAS,EAAE,EACvC,QAAQ;AAEX,aAAO,UAAU;AAAA,QACf,CAAC,EAAE,YAAY,SAAS,MACtB,CAAC,OAAO,UAAU,GAAG,OAAO,QAAQ,CAAC;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,OAAO;AAAA,IAChB;AAAA,IACA;AAAA,EACF,MAGwB;AACtB,UAAM,WAAW,MAAM,KAAK,GACzB,WAAW,QAAQ,EACnB,OAAO,MAAM,EACb,MAAM,UAAU,KAAK,OAAO,WAAW,CAAC,EACxC,MAAM,WAAW,KAAK,OAAO,EAC7B,iBAAiB;AAEpB,WAAO,aAAa;AAAA,EACtB;AAAA,EAEA,4BAA4B,OAAO;AAAA,IACjC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACvE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,mBAAmB,QAAQ;AAAA,UAC9B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,iBAAiB;AAAA,YACzD,GAAG,yBAAyB,WAAW;AAAA,YACvC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,gCAAgC,qBAAqB;AAAA,cACxD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,QACb;AAIA,cAAM,yBAEF,CAAC;AACL,mBAAW,SAAS,WAAW;AAC7B,cAAI,uBAAuB,MAAM,eAAe,MAAM,QAAW;AAC/D,mCAAuB,MAAM,eAAe,IAAI,CAAC;AAAA,UACnD;AACA,iCAAuB,MAAM,eAAe,EAAE,KAAK,KAAK;AAAA,QAC1D;AAEA,mBAAW,mBAAmB,OAAO,KAAK,sBAAsB,GAAG;AACjE,gBAAM,SAAS,MAAM,GAClB,WAAW,YAAY,EACvB,aAAa,EACb,MAAM,mBAAmB,KAAK,eAAsB,EACpD,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,UAAC,OAAqD;AAAA,YACpD,GAAG,uBAAuB,eAAsB,EAAE,IAAI,CAAC,WAAW;AAAA,cAChE,GAAG,mBAAmB,KAAK;AAAA,cAC3B;AAAA,YACF,EAAE;AAAA,UACJ;AAGA,iBAAO,KAAK,CAAC,GAAG,MAAM;AACpB,mBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,UAChD,CAAC;AAED,mBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,kBAAM,QAAQ,OAAO,CAAC;AACtB,kBAAM,aAAa,iBAAiB;AAAA,cAClC,gBAAgBE,aAAY,SAAS,SAAS;AAAA,cAC9C,SAAS,OAAO,OAAO;AAAA,cACvB,aAAa,MAAM;AAAA,cACnB,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,cAClD,WAAW,YAAY;AAAA,cACvB,YAAY,OAAO,CAAC;AAAA,YACtB,CAAC;AAED,kBAAM,aAAa;AAAA,UACrB;AAEA,gBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA,cAAc,CAAC,WAAW;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,YAAY,oBAAoB,EAAE,GAAG,aAAa,QAAQ,CAAC;AAGjE,YAAM,QAAQ;AAAA,QACZ,UAAU,IAAI,OAAO,aAAa;AAChC,iBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,kBAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,kBAAM,uBAAuB,MAAM,GAChC,WAAW,sBAAsB,EACjC,MAAM,iBAAiB,KAAK,aAAa,EACzC,aAAa,EACb,QAAQ;AAEX,kBAAM,kBAAkB;AAAA,cACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,gBAC9B,OAAO,EAAE,UAAU;AAAA,gBACnB,OAAO,EAAE,QAAQ;AAAA,cACnB,CAAC;AAAA,YACH;AAEA,kBAAM,qBAAqB,gBAAgB;AAAA,cACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,gBAC3B;AAAA,gBACA,YAAY,OAAO,UAAU;AAAA,gBAC7B,UAAU,OAAO,QAAQ;AAAA,cAC3B;AAAA,YACF;AAEA,gBAAI,mBAAmB,SAAS,GAAG;AACjC,oBAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,YACb;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,YAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,QACC;AAAA,QACA,MACEF,gBAAeA,KAAI;AAAA,UACjB,UAAU;AAAA,YACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,WAAW,CAAC,KAAKA,KAAI;AAAA,cACvD,EAAE;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACF,CAAC;AAAA,MACL,EACC,WAAW,sBAAsB,EACjC,UAAU,gBAAgB,iBAAiB,iBAAiB,EAC5D,UAAU,wBAAwB,CAAC,SAAS;AAC3C,eAAO,KAAK;AAAA,UAAG,CAAC,OACd,GAAG,IAAI;AAAA,YACL,GAAG,GAAG;AAAA,cACJ,GAAG,eAAe,MAAM,IAAI;AAAA,cAC5B,GAAG,uBAAuB,KAAKA,KAAI,IAAI,aAAa,CAAC;AAAA,YACvD,CAAC;AAAA,YACD,GAAG,GAAG;AAAA,cACJ,GAAG,aAAa,MAAM,IAAI;AAAA,cAC1B,GAAG,qBAAqB,KAAKA,KAAI,IAAI,WAAW,CAAC;AAAA,YACnD,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAM,wBAAwB,UAAU;AAAA,QACtC,CAAC,KAAK,QAAQ;AACZ,gBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,WAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO,UAAU,GAAG,OAAO,QAAQ,CAAC,CAAC;AACpE,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAEA,YAAM,2BAA2B,UAAU;AAAA,QAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,MACjD;AACA,aAAO,yBAAyB,wBAAwB;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,mCAAmC,OAAO;AAAA,IACxC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,mCAAmC;AAAA,MAC7C,YAAY;AACV,cAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,mBAAmB,QAAQ;AAAA,YAC9B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,cAAI,gBAAgB,SAAS,GAAG;AAC9B,kBAAM,eAAe,gBAAgB,IAAI,CAAC,oBAAoB;AAAA,cAC5D,GAAG,yBAAyB,cAAc;AAAA,cAC1C;AAAA,YACF,EAAE;AACF,kBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,UACb;AAEA,cAAI,uBAAuB,SAAS,GAAG;AACrC,kBAAM,sBAAsB,uBAAuB;AAAA,cACjD,CAAC,2BAA2B;AAAA,gBAC1B,GAAG,gCAAgC,qBAAqB;AAAA,gBACxD;AAAA,cACF;AAAA,YACF;AACA,kBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,UACb;AAIA,gBAAM,yBAEF,CAAC;AACL,qBAAW,SAAS,WAAW;AAC7B,gBAAI,uBAAuB,MAAM,eAAe,MAAM,QAAW;AAC/D,qCAAuB,MAAM,eAAe,IAAI,CAAC;AAAA,YACnD;AACA,mCAAuB,MAAM,eAAe,EAAE,KAAK,KAAK;AAAA,UAC1D;AAEA,qBAAW,mBAAmB,OAAO,KAAK,sBAAsB,GAAG;AACjE,kBAAM,SAAS,MAAM,GAClB,WAAW,YAAY,EACvB,aAAa,EACb,MAAM,mBAAmB,KAAK,eAAsB,EACpD,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAC,OAAqD;AAAA,cACpD,GAAG,uBAAuB,eAAsB,EAAE;AAAA,gBAChD,CAAC,WAAW;AAAA,kBACV,GAAG,mBAAmB,KAAK;AAAA,kBAC3B;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAGA,mBAAO,KAAK,CAAC,GAAG,MAAM;AACpB,qBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,YAChD,CAAC;AAED,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,oBAAM,QAAQ,OAAO,CAAC;AACtB,oBAAM,aAAa,iBAAiB;AAAA,gBAClC,gBAAgBE,aAAY,SAAS,SAAS;AAAA,gBAC9C,SAAS,OAAO,OAAO;AAAA,gBACvB,aAAa,MAAM;AAAA,gBACnB,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,gBAClD,WAAW,YAAY;AAAA,gBACvB,YAAY,OAAO,CAAC;AAAA,cACtB,CAAC;AAED,oBAAM,aAAa;AAAA,YACrB;AAEA,kBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,UACb;AAEA,gBAAM,KAAK,kCAAkC;AAAA,YAC3C;AAAA,YACA;AAAA,YACA,qBAAqB,CAAC,OAAO;AAAA,YAC7B;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,iCAAiC,OAAO;AAAA,IACtC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,+BAA+B;AAAA,MACzC,YAAY;AACV,cAAM,YAAY,2BAA2B,EAAE,GAAG,SAAS,QAAQ,CAAC;AAEpE,cAAM,QAAQ;AAAA,UACZ,UAAU,IAAI,OAAO,aAAa;AAChC,mBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,oBAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,qBAAqB,EAChC,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,oBAAM,oBAAoB,MAAM,GAC7B,WAAW,6BAA6B,EACxC,MAAM,aAAa,KAAK,SAAS,EACjC,aAAa,EACb,QAAQ;AAEX,oBAAM,kBAAkB;AAAA,gBACtB,kBAAkB,IAAI,CAAC,MAAM;AAAA,kBAC3B,OAAO,EAAE,UAAU;AAAA,kBACnB,OAAO,EAAE,QAAQ;AAAA,gBACnB,CAAC;AAAA,cACH;AAEA,oBAAM,qBAAqB,gBAAgB;AAAA,gBACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,kBAC3B;AAAA,kBACA,YAAY,OAAO,UAAU;AAAA,kBAC7B,UAAU,OAAO,QAAQ;AAAA,gBAC3B;AAAA,cACF;AAEA,kBAAI,mBAAmB,SAAS,GAAG;AACjC,sBAAM,GACH,WAAW,6BAA6B,EACxC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,cACb;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,cAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,UACC;AAAA,UACA,MACEF,gBAAeA,KAAI;AAAA,YACjB,UAAU;AAAA,cACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,gBACnD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,oBAAoB,CAAC,KAAKA,KAAI;AAAA,gBAC5C,EAAE;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACF,CAAC;AAAA,QACL,EACC,WAAW,6BAA6B,EACxC;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,QACF,EACC;AAAA,UAAU;AAAA,UAA0B,CAAC,SACpC,KAAK;AAAA,YAAG,CAAC,OACP,GAAG,IAAI;AAAA,cACL,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,cAC7C,GAAG,yBAAyB,KAAKA,KAAI,IAAI,eAAe,CAAC;AAAA,cACzD;AAAA,gBACE;AAAA,gBACA;AAAA,gBACAA,KAAI,IAAI,sBAAsB;AAAA,cAChC;AAAA,cACA,GAAG,GAAG;AAAA,gBACJ,GAAG,eAAe,MAAM,IAAI;AAAA,gBAC5B,GAAG,uBAAuB,KAAKA,KAAI,IAAI,aAAa,CAAC;AAAA,cACvD,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF,EACC,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,cAAM,wBAAwB,UAAU;AAAA,UACtC,CAAC,KAAK,QAAQ;AACZ,kBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,aAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK;AAAA,cAC5B,OAAO,UAAU;AAAA,cACjB,OAAO,QAAQ;AAAA,YACjB,CAAC;AACD,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,2BAA2B,UAAU;AAAA,UAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,QACjD;AACA,eAAO,yBAAyB,wBAAwB;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,sBAAsB,CAC5B,QACA,OACA,YACG;AACH,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AACA,QAAI,OAAO,qBAAqB,MAAM;AACpC,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,OAAO,aAAa,MAAM;AAC5B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AACA,WAAO,iBAAiB;AAAA,MACtB,gBAAgB,OAAO,OAAO,MAAM,SAAS,CAAC;AAAA,MAC9C,SAAS,OAAO,OAAO;AAAA,MACvB,aAAaG,aAAY,MAAM,MAAM;AAAA,MACrC,kBAAkBA,aAAY,OAAO,gBAAgB;AAAA,MACrD,WAAW,YAAY;AAAA,MACvB,YAAYA,aAAY,OAAO,QAAQ;AAAA,IACzC,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAwB,CAAC,OAAiB,YAAoB;AACpE,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAEA,WAAO,iBAAiB;AAAA,MACtB,gBAAgBD,aAAY,MAAM,SAAS;AAAA,MAC3C,SAAS,OAAO,OAAO;AAAA,MACvB,aAAaC,aAAY,MAAM,MAAM;AAAA,MACrC,kBAAkB,cAAc;AAAA,MAChC,WAAW,YAAY;AAAA,MACvB,YAAY,eAAe;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,sBAAsB,OAAO;AAAA,IAC3B;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN,QAAQ;AAAA,EACV,MAOM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,sBAAsB,GAAG,YAAY;AACjE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,mBAAmB,QAAQ;AAAA,UAC9B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,iBAAiB;AAAA,YACzD,GAAG,yBAAyB,WAAW;AAAA,YACvC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,MAAM,EAAE,YAAY,CAAC,QAAQ;AAAA,cACrC,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,aAAa,GAAG,IAAI,sBAAsB;AAAA,cAC1C,kBAAkB,GAAG,IAAI,2BAA2B;AAAA,YACtD,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,gCAAgC,qBAAqB;AAAA,cACxD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,iBAAiB,EAAE,YAAY,CAAC,QAAQ;AAAA,cAChD,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,aAAa,GAAG,IAAI,sBAAsB;AAAA,cAC1C,iBAAiB,GAAG,IAAI,0BAA0B;AAAA,cAClD,mBAAmB,GAAG,IAAI,4BAA4B;AAAA,cACtD,mBAAmB,GAAG,IAAI,4BAA4B;AAAA,cACtD,SAAS,GAAG,IAAI,kBAAkB;AAAA,cAClC,MAAM,GAAG,IAAI,eAAe;AAAA,cAC5B,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,kBAAkB,GAAG,IAAI,2BAA2B;AAAA,YACtD,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,iBAAiB,MAAM;AAAA,YAC1B;AAAA,YACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,UAChE,EAAE;AACF,gBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,cACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,YAC1C,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,SAAS,UACZ,IAAI,CAAC,OAAO,OAAO;AAAA,YAClB,GAAG,mBAAmB,KAAK;AAAA,YAC3B;AAAA,YACA,YAAY,iBAAiB;AAAA,cAC3B,gBAAgBD,aAAY,SAAS,SAAS;AAAA,cAC9C,SAAS,OAAO,OAAO;AAAA,cACvB,aAAaC,aAAY,MAAM,WAAW;AAAA,cAC1C,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,cAClD,WAAW,YAAY;AAAA,cACvB,YAAY,OAAO,CAAC;AAAA,YACtB,CAAC;AAAA,UACH,EAAE,EACD,KAAK,CAAC,GAAG,MAAM;AACd,gBAAI,EAAE,kBAAkB,EAAE;AAAiB,qBAAO;AAClD,gBAAI,EAAE,kBAAkB,EAAE;AAAiB,qBAAO;AAClD,mBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,UAChD,CAAC;AAEH,gBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,yBAAyB,OAAO;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,KAAK,yBAAyB;AAAA,UAClC;AAAA,UACA;AAAA,UACA,YAAY;AAAA,YACV,GAAG;AAAA,YACH,GAAG,kBAAkB,IAAI,CAAC,OAAO;AAAA,cAC/B,SAAS,EAAE;AAAA,cACX,QAAQ,CAAC,EAAE,aAAa;AAAA,cACxB,4BAA4B,EAAE;AAAA,YAChC,EAAE;AAAA,YACF,GAAG,oBAAoB,IAAI,CAAC,OAAO;AAAA,cACjC,SAAS,EAAE;AAAA,cACX,QAAQ,CAAC,EAAE,aAAa;AAAA,cACxB,4BAA4B,EAAE;AAAA,YAChC,EAAE;AAAA,UACJ;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,gCAAgC;AAAA,UACzC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,kCAAkC;AAAA,UAC3C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,qBAAqB,OAAO;AAAA,IAC1B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,qBAAqB,GAAG,YAAY;AAChE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,MAAM,EACjB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AACX,cAAM,GACH,WAAW,QAAQ,EACnB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,UAAU,KAAK,SAAS,EAC9B,QAAQ;AACX,cAAM,GACH,WAAW,mBAAmB,EAC9B,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AACX,cAAM,GACH,WAAW,YAAY,EACvB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AAAA,MACb,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA,EAIQ,2BAA2B,OAAO;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,qBAAqB,WAAW;AAAA,MAAQ,CAAC,cAC7C,wBAAwB,EAAE,GAAG,WAAW,QAAQ,CAAC;AAAA,IACnD;AAEA,UAAM,QAAQ;AAAA,MACZ,mBAAmB,IAAI,OAAO,sBAAsB;AAClD,cAAM,EAAE,IAAI,YAAY,IAAI,MAAM,GAC/B,WAAW,YAAY,EACvB,OAAO,iBAAiB,EACxB,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,iBAAiB,CAAC,EACjE,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,oBAAoB,EAC/B,OAAO,EAAE,aAAa,YAAY,SAAS,CAAC,EAC5C,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,kCAAkC,OAAO;AAAA,IAC/C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,mBAAmB,kBAAkB;AAAA,MAAQ,CAAC,YAClD,yBAAyB,EAAE,GAAG,SAAS,QAAQ,CAAC;AAAA,IAClD;AAEA,UAAM,QAAQ;AAAA,MACZ,iBAAiB,IAAI,OAAO,aAAa;AACvC,cAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,mBAAmB,EAC9B,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,2BAA2B,EACtC,OAAO,EAAE,WAAW,YAAY,SAAS,CAAC,EAC1C,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,6BAA6B,OAAO;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,uBAAuB,aAAa,IAAI,CAAC,gBAAgB;AAC7D,aAAO;AAAA,QACL,IAAI,GAAG,OAAO,IAAI,YAAY,QAAQ,IAAI,YAAY,MAAM;AAAA,QAC5D;AAAA,QACA,UAAU,YAAY;AAAA,QACtB,QAAQ,YAAY;AAAA,MACtB;AAAA,IACF,CAAC;AAED,UAAM,QAAQ;AAAA,MACZ,qBAAqB,IAAI,OAAO,wBAAwB;AACtD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,mBAAmB,CAAC,EACnE,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,EAAE,eAAe,YAAY,SAAS,CAAC,EAC9C,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,6BAA6B,OAAO;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,uBAAuB,aAAa;AAAA,MAAQ,CAAC,gBACjD,oBAAoB,EAAE,GAAG,aAAa,QAAQ,CAAC;AAAA,IACjD;AAEA,UAAM,QAAQ;AAAA,MACZ,qBAAqB,IAAI,OAAO,wBAAwB;AACtD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,mBAAmB,CAAC,EACnE,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,EAAE,eAAe,YAAY,SAAS,CAAC,EAC9C,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,oCAAoC,OAAO;AAAA,IACjD;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,mBAAmB,oBAAoB;AAAA,MAAQ,CAAC,YACpD,2BAA2B,EAAE,GAAG,SAAS,QAAQ,CAAC;AAAA,IACpD;AAEA,UAAM,QAAQ;AAAA,MACZ,iBAAiB,IAAI,OAAO,aAAa;AACvC,cAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,qBAAqB,EAChC,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,6BAA6B,EACxC,OAAO;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,yBAAyB,OAAO;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAKM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,KAAK,GACR,WAAW,mBAAmB,EAC9B,OAAO,EAAE,SAAS,aAAa,SAAS,OAAO,CAAC,EAChD;AAAA,QAAW,CAAC,OACX,GAAG,WAAW,4BAA4B,EAAE,YAAY,EAAE,OAAO,CAAC;AAAA,MACpE,EACC,QAAQ;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EAEA,sBAAsB,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAIM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,sBAAsB,GAAG,YAAY;AACjE,YAAM,qBAAqB,MAAM,KAAK,GACnC,WAAW,mBAAmB,EAC9B,UAAU,EACV,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,WAAW,EACrC,MAAM,WAAW,KAAK,OAAO,EAC7B,iBAAiB;AAEpB,aAAO,sBAAsB;AAAA,IAC/B,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,UAAU;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,QAAI,SAAS,iBAAiB,cAAc;AAC5C,UAAM,sBAAsB,iBAAiB,YAAY;AAEzD,UAAM,cAAc,QAAQ,OAEzB,CAAC,KAAK,QAAQ;AACf,UAAI,IAAI,EAAE,IAAI;AACd,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAGL,UAAM,aAAa,QAAQ;AAAA,MACzB,CAAC,MACC,YAAY,CAAC,KAAK,mBAAmB,CAAC;AAAA,IAC1C;AACA,UAAM,mBAAmB,QAAQ;AAAA,MAC/B,CAAC,MACC,kBAAkB,CAAC,KAAK,yBAAyB,CAAC;AAAA,IACtD;AACA,UAAM,eAAe,QAAQ,OAAO,aAAa;AAEjD,UAAM,iBAAiB,WAAW,WAAW;AAC7C,UAAM,yBACJ,WAAW,WAAW,KAAK,iBAAiB,WAAW;AACzD,UAAM,mBAAmB,iBAAiB,WAAW;AACrD,UAAM,qBACJ,WAAW,KAAK,CAAC,WAAW,OAAO,SAAS,0BAA0B,KACtE,iBAAiB;AAAA,MACf,CAAC,WAAW,OAAO,SAAS;AAAA,IAC9B;AAEF,WAAO,MAAM;AACX,YAAM,SAAS,MAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,YAAY,GAAG,YAAY;AAErE,cAAM,gBAAgB,MAAM,KAAK,GAC9B;AAAA,UACC;AAAA,UACA,MACEH,gBACE,WAAW,WAAW,IAClBA,iBACAA,KAAI;AAAA,YACF,WAAW;AAAA,cACT,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UACC;AAAA,UACA,MACEA,gBACE,aAAa,WAAW,IACpBA,iBACAA,KAAI;AAAA,YACF,aAAa;AAAA,cACX,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UACC;AAAA,UACA,MACEA,gBACE,iBAAiB,WAAW,IACxBA,iBACAA,KAAI;AAAA,YACF,iBAAiB;AAAA,cACf,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UAAK;AAAA,UAAmB,CAAC,OACxB,GACG,WAAW,MAAM,EACjB,MAAM,mBAAmB,KAAK,MAAM,EACpC,MAAM,mBAAmB,MAAM,mBAAmB,EAClD,QAAQ,mBAAmB,KAAK,EAChC,MAAM,KAAK,EACX,OAAO,iBAAiB;AAAA,QAC7B,EACC;AAAA,UAAK;AAAA,UAAqB,CAAC,OAC1B,GACG,WAAW,QAAQ,EACnB,MAAM,qBAAqB,KAAK,MAAM,EACtC,MAAM,qBAAqB,MAAM,mBAAmB,EACpD,QAAQ,qBAAqB,KAAK,EAClC,MAAM,KAAK,EACX,OAAO,mBAAmB;AAAA,QAC/B,EACC;AAAA,UAAK;AAAA,UAA0B,CAAC,OAC/B,GACG,WAAW,YAAY,EACvB,MAAM,yBAAyB,KAAK,MAAM,EAC1C,MAAM,yBAAyB,MAAM,mBAAmB,EACxD,QAAQ,yBAAyB,KAAK,EACtC,MAAM,KAAK,EACX,OAAO,uBAAuB;AAAA,QACnC,EACC;AAAA,UAAK;AAAA,UAAkB,CAAC,OACvB,GACG;AAAA,YACC,GACG,WAAW,iBAAiB,EAC5B,OAAO,YAAY,EACnB;AAAA,cACC,GAAG,WAAW,mBAAmB,EAAE,OAAO,YAAY;AAAA,YACxD,EACC;AAAA,cACC,GACG,WAAW,wBAAwB,EACnC,OAAO,YAAY;AAAA,YACxB,EACC,GAAG,iBAAiB;AAAA,UACzB,EACC;AAAA,YACCA,iCAAgC,mBAAmB,IAAI;AAAA,cACrD;AAAA,YACF;AAAA,UACF;AAAA,QACJ,EACC;AAAA,UAAK;AAAA,UAAU,CAAC,OACf,GACG,WAAW,MAAM,EACjB,UAAU,eAAe,CAAC,SAAS,KAAK,OAAO,CAAC,EAChD,MAAM,CAAC,OAAO;AACb,kBAAM,iBAAiB,QACpB,OAAO,WAAW,EAClB,IAAI,CAAC,cAAc;AAClB,oBAAM,QAAQ,KAAK,oBAAoB;AAAA,gBACrC;AAAA,gBACA;AAAA,cACF,CAAC;AACD,oBAAM,KAAK,GAAG,aAAa,KAAK,UAAU,EAAE,CAAC;AAC7C,qBAAO,GAAG,IAAI,KAAK;AAAA,YACrB,CAAC;AAEH,kBAAM,eAAe,QAClB,OAAO,kBAAkB,EACzB,IAAI,CAAC,YAAY;AAChB,oBAAM,QAAQ,KAAK,2BAA2B;AAAA,gBAC5C;AAAA,gBACA;AAAA,cACF,CAAC;AACD,oBAAM,KAAK,GAAG,aAAa,KAAK,QAAQ,EAAE,CAAC;AAC3C,qBAAO,GAAG,IAAI,KAAK;AAAA,YACrB,CAAC;AAEH,mBAAO,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,YAAY,CAAC;AAAA,UACnD,CAAC,EACA,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YAEA;AAAA,YACAA,WAAU,GAAG,cAAc;AAAA,UAC7B,CAAC,EACA;AAAA;AAAA,YAEC,GACG,WAAW,QAAQ,EACnB,UAAU,iBAAiB,CAAC,SAAS,KAAK,OAAO,CAAC,EAClD,MAAM,CAAC,OAAO;AACb,oBAAM,QAAQ,CAAC;AACf,yBAAW,eAAe,cAAc;AACtC,sBAAM;AAAA,kBACJ,GAAG,IAAI;AAAA,oBACL,GAAG,WAAW,KAAK,YAAY,OAAO;AAAA,oBACtC,GAAG,UAAU,MAAM,OAAO,YAAY,UAAU,CAAC;AAAA,oBACjD,GAAI,YAAY,aAAa,SACzB,CAAC,GAAG,UAAU,MAAM,OAAO,YAAY,QAAQ,CAAC,CAAC,IACjD,CAAC;AAAA,oBACLA,iBAAgBA,KAAI;AAAA,sBAClB,YAAY,SAAS;AAAA,oBACvB,CAAC,OAAOA,KAAI,IAAI,YAAY,SAAS,QAAQ,CAAC;AAAA,oBAC9C,GAAG,aAAa,KAAK,YAAY,EAAE;AAAA,kBACrC,CAAC;AAAA,gBACH;AAAA,cACF;AACA,qBAAO,GAAG,GAAG,KAAK;AAAA,YACpB,CAAC,EACA,OAAO;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACAA,WAAU,GAAG,iBAAiB;AAAA,cAE9BA,WAAU,GAAG,QAAQ;AAAA,cACrBA,WAAU,GAAG,cAAc;AAAA,YAC7B,CAAC;AAAA,UACL,EACC;AAAA;AAAA,YAEC,GACG,WAAW,YAAY,EACvB,UAAU,sBAAsB,CAAC,SAAS,KAAK,OAAO,CAAC,EACvD,MAAM,CAAC,OAAO;AACb,oBAAM,mBAAmB,QACtB,OAAO,iBAAiB,EACxB,IAAI,CAAC,oBAAoB;AACxB,sBAAM,QAAQ,KAAK,sBAAsB;AAAA,kBACvC;AAAA,kBACA;AAAA,gBACF,CAAC;AACD,sBAAM,KAAK,GAAG,aAAa,KAAK,gBAAgB,EAAE,CAAC;AACnD,uBAAO,GAAG,IAAI,KAAK;AAAA,cACrB,CAAC;AACH,oBAAM,0BAA0B,QAC7B,OAAO,wBAAwB,EAC/B,IAAI,CAAC,YAAY;AAChB,sBAAM,QAAQ,KAAK,6BAA6B;AAAA,kBAC9C;AAAA,kBACA;AAAA,gBACF,CAAC;AACD,sBAAM,KAAK,GAAG,aAAa,KAAK,QAAQ,EAAE,CAAC;AAC3C,uBAAO,GAAG,IAAI,KAAK;AAAA,cACrB,CAAC;AAEH,qBAAO,GAAG,GAAG;AAAA,gBACX,GAAG;AAAA,gBACH,GAAG;AAAA,cACL,CAAC;AAAA,YACH,CAAC,EAEA,OAAO;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cAEAA,WAAU,GAAG,QAAQ;AAAA,cACrB;AAAA,YACF,CAAC;AAAA,UACL;AAAA,QACJ,EACC,WAAW,QAAQ,EACnB,UAAU,UAAU,eAAe,kBAAkB,EACrD,OAAO;AAAA,UACN;AAAA,UACA;AAAA,UAEA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC,EACA;AAAA,UAAI;AAAA,UAAgB,CAAC,OACpB,GACG,SAAS,QAAQ,WAAW,eAAe,EAC3C,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAwB,CAAC,OAC5B,GACG;AAAA,YACC;AAAA,YACA;AAAA,YACA;AAAA,UACF,EACC,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAkB,CAAC,OACtB,GACG,SAAS,cAAc,iBAAiB,qBAAqB,EAC7D,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAoB,CAAC,OACxB,GACG;AAAA,YACC;AAAA,YACA;AAAA,YACA;AAAA,UACF,EACC,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC,MAAM,qBAAqB,KAAK,MAAM,EACtC;AAAA,UACC;AAAA,UACA;AAAA;AAAA,UAEAA;AAAA;AAAA;AAAA;AAAA,QAIF,EACC,QAAQ,qBAAqB,KAAK,EAClC,MAAM,QAAQ,CAAC,EACf,QAAQ;AAEX,eAAO,cAAc,IAAI,CAAC,SAAS;AAIjC,gBAAM,MAAM;AAEZ,gBAAM,SAAS,YAAY,IAAI,SAAS;AAExC,gBAAM,mBACJ,YAAY,MAAM,KAAK,mBAAmB,MAAM;AAClD,gBAAM,2BACJ,YAAY,MAAM,KAClB,mBAAmB,MAAM,KACzB,kBAAkB,MAAM,KACxB,yBAAyB,MAAM;AACjC,gBAAM,qBACJ,kBAAkB,MAAM,KAAK,yBAAyB,MAAM;AAC9D,gBAAM,kCACH,YAAY,MAAM,KACjB,OAAO,SAAS,8BACjB,mBAAmB,MAAM,KACxB,OAAO,SAAS;AACpB,iBAAO;AAAA,YACL,SAAS,OAAO;AAAA,YAChB,UAAU,IAAI;AAAA,YACd,mBAAmB,IAAI;AAAA,YACvB,KAAK,mBACD;AAAA,cACE,SAASI,iBAAgB,IAAI,WAAW;AAAA,cACxC,WAAW,IAAI;AAAA,cACf,aAAa,IAAI;AAAA,cACjB,MAAM,IAAI;AAAA,cACV,IAAI,IAAI;AAAA,cACR,UAAU,OAAO,IAAI,YAAY;AAAA,cACjC,SAAS;AAAA,cACT,QAAQ;AAAA,gBACN,IAAI;AAAA,gBACJ,IAAI;AAAA,gBACJ,IAAI;AAAA,gBACJ,IAAI;AAAA,cACN,EAAE,OAAO,CAAC,MAAgB,MAAM,IAAI;AAAA,cACpC,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,OAAO,IAAI,oBAAoB;AAAA,YACnD,IACA;AAAA,YACJ,OAAO;AAAA,cACL,eAAe,IAAI;AAAA,cACnB,YAAY,IAAI;AAAA,cAChB,WAAW,IAAI;AAAA,cACf,UAAU,IAAI;AAAA,cACd,SAAS,IAAI;AAAA,cACb,MAAM,IAAI;AAAA,cACV,WAAW,IAAI;AAAA,cACf,OAAOA,iBAAgB,IAAI,WAAW;AAAA,cACtC,SAAS,IAAI;AAAA,cACb,OAAO,IAAI;AAAA,cACX,QAAQ,IAAI;AAAA,cACZ,YAAY,IAAI;AAAA,cAChB,cAAc,IAAI;AAAA,cAClB,YAAY,IAAI;AAAA,cAChB,MAAM,IAAI;AAAA,cACV,WAAW,IAAI;AAAA,cACf,WAAW,IAAI;AAAA,cACf,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,IAAI;AAAA,YACxB;AAAA,YACA,aAAa,2BACT;AAAA,cACE,WAAW,IAAI;AAAA,cACf,aAAa,IAAI;AAAA,cACjB,MAAMA,iBAAgB,IAAI,OAAO;AAAA,cACjC,KAAK,IAAI;AAAA,cACT,MAAM,IAAI;AAAA,cACV,OAAO,IAAI;AAAA,cACX,OAAO,OAAO,IAAI,QAAQ;AAAA,cAC1B,GAAG,IAAI;AAAA,cACP,GAAG,IAAI;AAAA,cACP,IAAI,IAAI,QAAQA,iBAAgB,IAAI,KAAK,IAAI,IAAI;AAAA,cACjD,kBAAkB,OAAO,IAAI,mBAAmB;AAAA,cAChD,OAAO,IAAI;AAAA,cACX,GAAG,IAAI;AAAA,cACP,GAAI,IAAI,YAAY,QAChB,EAAE,MAAM,UAAU,UAAU,IAAI,YAAY,IAC5C,IAAI,YAAY,QACd;AAAA,gBACE,MAAM;AAAA,gBACN,UAAU,IAAI;AAAA,gBACd,YAAY,KAAK,MAAM,IAAI,aAAa;AAAA,cAC1C,IACA,IAAI,YAAY,QACd;AAAA,gBACE,MAAM;AAAA,gBACN,cAAc,IAAI;AAAA,gBAClB,sBAAsB,IAAI;AAAA,cAC5B,IACA,IAAI,YAAY,SACd;AAAA,gBACE,MAAM;AAAA,gBACN,cAAc,IAAI,mBAAmB;AAAA,gBACrC,sBACE,IAAI,2BAA2B;AAAA,cACnC,IACA,EAAE,MAAM,IAAI,QAAQ;AAAA,YAChC,IACA;AAAA,YACJ,OAAO,qBACH;AAAA,cACE,IAAI,IAAI;AAAA,cACR,MAAMA,iBAAgB,IAAI,cAAc;AAAA,cACxC,IAAIA,iBAAgB,IAAI,YAAY;AAAA,cACpC,KAAK,IAAI;AAAA,cACT,OAAO,IAAI;AAAA,cACX,OAAO,IAAI;AAAA,cACX,QAAQ,IAAI;AAAA,cACZ,SAAS,IAAI;AAAA,cACb,WAAW,IAAI;AAAA,cACf,cAAc,KAAK,MAAM,IAAI,sBAAsB;AAAA,cACnD,WAAW,IAAI;AAAA,cACf,aAAa,IAAI;AAAA,cACjB,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,IAAI;AAAA,cACtB,UAAU,IAAI;AAAA,YAChB,IACA;AAAA,YACJ,oBAAoB,kCAChB;AAAA,cACE,WAAW,IAAI;AAAA,cACf,aAAa,IAAI;AAAA,cACjB,iBAAiB,IAAI,sBACjBA,iBAAgB,IAAI,mBAAmB,IACvC;AAAA,cACJ,mBAAmB,IAAI;AAAA,cACvB,mBAAmB,IAAI;AAAA,cACvB,MAAMA,iBAAgB,IAAI,QAAQ;AAAA,cAClC,SAAS,IAAI;AAAA,cACb,MAAM,KAAK,MAAM,IAAI,QAAQ,EAAE,IAAI,CAAC,SAAkB;AAAA,gBACpD,SAASA,iBAAgB,IAAI,OAAO;AAAA,gBACpC,WAAW,IAAI;AAAA,gBACf,aAAaD,aAAY,IAAI,WAAW;AAAA,gBACxC,MAAM,IAAI;AAAA,gBACV,UAAUD,aAAY,IAAI,QAAQ;AAAA,gBAClC,SAAS;AAAA,gBACT,QAAQ;AAAA,kBACN,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,gBACnB,EAAE,OAAO,CAAC,MAAgB,MAAM,IAAI;AAAA,gBAGpC,iBAAiB,IAAI;AAAA,gBACrB,kBAAkBA,aAAY,IAAI,gBAAgB;AAAA,cACpD,EAAE;AAAA,cACF,WAAW,IAAI;AAAA,cACf,QACE,IAAI,eAAe,QACf,YACA,IAAI,eAAe,QACjB,aACC,IAAI;AAAA,cACb,IAAI,IAAI,SAASE,iBAAgB,IAAI,MAAM,IAAI;AAAA,cAC/C,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,OAAO,IAAI,oBAAoB;AAAA,cACjD,MACE,IAAI,aAAa,QACb,WACA,IAAI,aAAa,QACf,YACA,IAAI,YAAY,QACd,YACA,IAAI,YAAY,SACd,YACA,IAAI;AAAA,YAClB,IACA;AAAA,UACN;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,YAAM,cAAc,OAAO,WAAW,QAAQ;AAE9C,UAAI,CAAC,aAAa;AAChB,cAAM;AACN;AAAA,MACF,OAAO;AACL,eAAO,IAAI;AACX,iBAAS,OAAO,OAAO,SAAS,CAAC,EAAE;AACnC,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIoC;AAClC,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,aAAa,MAAM,KAAK,GAC3B,WAAW,MAAM,EACjB,MAAM,CAAC,OAAO;AACb,cAAM,iBAAiB,QACpB,OAAO,WAAW,EAClB,IAAI,CAAC,cAAc;AAClB,gBAAM,QAAQ,KAAK,oBAAoB,EAAE,IAAI,UAAU,CAAC;AACxD,iBAAO,GAAG,IAAI,KAAK;AAAA,QACrB,CAAC;AAEH,cAAM,eAAe,QAClB,OAAO,kBAAkB,EACzB,IAAI,CAAC,YAAY;AAChB,gBAAM,QAAQ,KAAK,2BAA2B,EAAE,IAAI,QAAQ,CAAC;AAC7D,iBAAO,GAAG,IAAI,KAAK;AAAA,QACrB,CAAC;AAEH,eAAO,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,YAAY,CAAC;AAAA,MACnD,CAAC,EACA,OAAO,YAAY,EACnB;AAAA,QACC,KAAK,GACF,WAAW,QAAQ,EACnB,MAAM,CAAC,OAAO;AACb,gBAAM,QAAQ,CAAC;AACf,gBAAM,eAAe,QAAQ,OAAO,aAAa;AACjD,qBAAW,eAAe,cAAc;AACtC,kBAAM;AAAA,cACJ,GAAG,IAAI;AAAA,gBACL,GAAG,WAAW,KAAK,YAAY,OAAO;AAAA,gBACtC,GAAG,UAAU,MAAM,OAAO,YAAY,UAAU,CAAC;AAAA,gBACjD,GAAI,YAAY,aAAa,SACzB,CAAC,GAAG,UAAU,MAAM,OAAO,YAAY,QAAQ,CAAC,CAAC,IACjD,CAAC;AAAA,gBACLJ,iBAAgBA,KAAI;AAAA,kBAClB,OAAO,YAAY,SAAS,MAAM;AAAA,gBACpC,CAAC,OAAOA,KAAI;AAAA,kBACV,OAAO,YAAY,SAAS,QAAQ;AAAA,gBACtC,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AAAA,UACF;AACA,iBAAO,GAAG,GAAG,KAAK;AAAA,QACpB,CAAC,EACA,OAAO,YAAY;AAAA,MACxB,EACC;AAAA,QACC,KAAK,GACF,WAAW,YAAY,EACvB,MAAM,CAAC,OAAO;AACb,gBAAM,mBAAmB,QACtB,OAAO,iBAAiB,EACxB,IAAI,CAAC,oBAAoB;AACxB,kBAAM,QAAQ,KAAK,sBAAsB;AAAA,cACvC;AAAA,cACA;AAAA,YACF,CAAC;AACD,mBAAO,GAAG,IAAI,KAAK;AAAA,UACrB,CAAC;AAEH,gBAAM,wBAAwB,QAC3B,OAAO,wBAAwB,EAC/B,IAAI,CAAC,YAAY;AAChB,kBAAM,QAAQ,KAAK,6BAA6B;AAAA,cAC9C;AAAA,cACA;AAAA,YACF,CAAC;AACD,mBAAO,GAAG,IAAI,KAAK;AAAA,UACrB,CAAC;AAEH,iBAAO,GAAG,GAAG,CAAC,GAAG,kBAAkB,GAAG,qBAAqB,CAAC;AAAA,QAC9D,CAAC,EACA,OAAO,YAAY;AAAA,MACxB,EACC,MAAM,cAAc,KAAK,iBAAiB,cAAc,CAAC,EACzD,MAAM,cAAc,MAAM,iBAAiB,YAAY,CAAC,EACxD,QAAQ,cAAc,MAAM,EAC5B,iBAAiB;AAEpB,aAAO,aACH,WAAW,aACT,iBAAiB,WAAW,UAAU,IACtC,SACF;AAAA,IACN,CAAC;AAAA,EACH;AAAA,EAEQ,sBAAsB,CAAC;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACAA,aAAYA,KAAI,IAAI,UAAU,OAAO,CAAC;AAAA,MACxC;AAAA,IACF;AAEA,QAAI,UAAU,SAAS,SAAS;AAE9B,YAAM,UACJ,MAAM,QAAQ,UAAU,SAAS,OAAO,KACxC,UAAU,SAAS,QAAQ,WAAW,IAClC,UAAU,SAAS,QAAQ,CAAC,IAC5B,UAAU,SAAS;AACzB,UAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,cAAM,KAAK,GAAG,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG,gBAAgB,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,MAClE,OAAO;AACL,cAAM,KAAK,GAAG,gBAAgB,KAAK,OAAO,CAAC;AAAA,MAC7C;AAAA,IACF;AAEA,QAAI,UAAU,SAAS,QAAQ;AAC7B,iBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,cAAM,MAAM;AAEZ,cAAM,MAAM,UAAU,SAAS,OAAO,GAAG,KAAK;AAC9C,YAAI,QAAQ;AAAM;AAClB,cAAM,QAAQ,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW,IAAI,IAAI,CAAC,IAAI;AAChE,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG,aAAa,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,QACpE,OAAO;AACL,gBAAM,KAAK,GAAG,aAAa,GAAG,IAAI,KAAK,KAAK,CAAC;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEA,QAAI,UAAU,eAAe,UAAa,UAAU,eAAe;AACjE,YAAM,KAAK,GAAG,oBAAoB,MAAM,OAAO,UAAU,UAAU,CAAC,CAAC;AACvE,QAAI,UAAU;AACZ,YAAM,KAAK,GAAG,oBAAoB,MAAM,OAAO,UAAU,QAAQ,CAAC,CAAC;AAErE,WAAO;AAAA,EACT;AAAA,EAEQ,6BAA6B,CAAC;AAAA,IACpC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACAA,aAAYA,KAAI,IAAI,QAAQ,OAAO,CAAC;AAAA,MACtC;AAAA,IACF;AAEA,UAAM,+BACJ,yCAAyC;AAAA,MACvC,sBAAsB,QAAQ,SAAS;AAAA,IACzC,CAAC;AAEH,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACA,GACG,WAAW,MAAM,EACjB,OAAO,6BAA6B,GAAG,cAAc,CAAC,EACtD,MAAM,WAAW,KAAK,QAAQ,OAAO,EACrC,MAAM,WAAW,KAAK,QAAQ,SAAS,OAAO,EAC9C,MAAM,UAAU,KAAK,QAAQ,SAAS,aAAa;AAAA,MACxD;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,QAAQ;AAC3B,iBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,cAAM,MAAM;AAEZ,cAAM,MAAM,QAAQ,SAAS,OAAO,GAAG,KAAK;AAC5C,YAAI,QAAQ;AAAM;AAClB,cAAM,QAAQ,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW,IAAI,IAAI,CAAC,IAAI;AAChE,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG,aAAa,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,QACpE,OAAO;AACL,gBAAM,KAAK,GAAG,aAAa,GAAG,IAAI,KAAK,KAAK,CAAC;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEA,QAAI,QAAQ,eAAe,UAAa,QAAQ,eAAe;AAC7D,YAAM,KAAK,GAAG,oBAAoB,MAAM,OAAO,QAAQ,UAAU,CAAC,CAAC;AACrE,QAAI,QAAQ;AACV,YAAM,KAAK,GAAG,oBAAoB,MAAM,OAAO,QAAQ,QAAQ,CAAC,CAAC;AAEnE,WAAO;AAAA,EACT;AAAA,EAEQ,wBAAwB,CAAC;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACAA,aAAYA,KAAI,IAAI,gBAAgB,OAAO,CAAC;AAAA,MAC9C;AAAA,IACF;AAEA,QAAI,gBAAgB,SAAS,aAAa;AAExC,YAAM,cACJ,MAAM,QAAQ,gBAAgB,SAAS,WAAW,KAClD,gBAAgB,SAAS,YAAY,WAAW,IAC5C,gBAAgB,SAAS,YAAY,CAAC,IACtC,gBAAgB,SAAS;AAC/B,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM;AAAA,UACJ,GAAG,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG,mBAAmB,KAAK,CAAC,CAAC,CAAC;AAAA,QAC7D;AAAA,MACF,OAAO;AACL,cAAM,KAAK,GAAG,mBAAmB,KAAK,WAAW,CAAC;AAAA,MACpD;AAAA,IACF;AAEA,QAAI,gBAAgB,SAAS,WAAW;AAEtC,YAAM,YACJ,MAAM,QAAQ,gBAAgB,SAAS,SAAS,KAChD,gBAAgB,SAAS,UAAU,WAAW,IAC1C,gBAAgB,SAAS,UAAU,CAAC,IACpC,gBAAgB,SAAS;AAC/B,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC5B,cAAM,KAAK,GAAG,GAAG,UAAU,IAAI,CAAC,MAAM,GAAG,iBAAiB,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,MACrE,OAAO;AACL,cAAM,KAAK,GAAG,iBAAiB,KAAK,SAAS,CAAC;AAAA,MAChD;AAAA,IACF;AAGA,UAAM;AAAA,MACJ,GAAG;AAAA,QACD,gBAAgB,SAAS,kBAAkB;AAAA,UAAI,CAAC,OAC9C,GAAG,+BAA+B,KAAK,EAAE;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAGA,UAAM;AAAA,MACJA,OAAMA,KAAI,IAAI,kBAAkB,CAAC;AAAA,IACnC;AAEA,QACE,gBAAgB,eAAe,UAC/B,gBAAgB,eAAe;AAE/B,YAAM;AAAA,QACJ,GAAG,0BAA0B,MAAM,OAAO,gBAAgB,UAAU,CAAC;AAAA,MACvE;AACF,QAAI,gBAAgB;AAClB,YAAM;AAAA,QACJ,GAAG,0BAA0B,MAAM,OAAO,gBAAgB,QAAQ,CAAC;AAAA,MACrE;AAEF,WAAO;AAAA,EACT;AAAA,EAEQ,+BAA+B,CAAC;AAAA,IACtC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACAA,aAAYA,KAAI,IAAI,QAAQ,OAAO,CAAC;AAAA,MACtC;AAAA,IACF;AACA,UAAM,+BACJ,yCAAyC;AAAA,MACvC,sBAAsB,QAAQ,SAAS;AAAA,IACzC,CAAC;AAEH,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACA,GACG,WAAW,MAAM,EACjB,OAAO,6BAA6B,GAAG,cAAc,CAAC,EACtD,MAAM,WAAW,KAAK,QAAQ,OAAO,EACrC,MAAM,WAAW,KAAK,QAAQ,SAAS,OAAO,EAC9C,MAAM,UAAU,KAAK,QAAQ,SAAS,aAAa;AAAA,MACxD;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,aAAa;AAEhC,YAAM,cACJ,MAAM,QAAQ,QAAQ,SAAS,WAAW,KAC1C,QAAQ,SAAS,YAAY,WAAW,IACpC,QAAQ,SAAS,YAAY,CAAC,IAC9B,QAAQ,SAAS;AACvB,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM;AAAA,UACJ,GAAG,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG,mBAAmB,KAAK,CAAC,CAAC,CAAC;AAAA,QAC7D;AAAA,MACF,OAAO;AACL,cAAM,KAAK,GAAG,mBAAmB,KAAK,WAAW,CAAC;AAAA,MACpD;AAAA,IACF;AAGA,UAAM;AAAA,MACJ,GAAG;AAAA,QACD,QAAQ,SAAS,kBAAkB;AAAA,UAAI,CAAC,OACtC,GAAG,+BAA+B,KAAK,EAAE;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAGA,UAAM;AAAA,MACJA,OAAMA,KAAI,IAAI,kBAAkB,CAAC;AAAA,IACnC;AAEA,QAAI,QAAQ,eAAe,UAAa,QAAQ,eAAe;AAC7D,YAAM;AAAA,QACJ,GAAG,0BAA0B,MAAM,OAAO,QAAQ,UAAU,CAAC;AAAA,MAC/D;AACF,QAAI,QAAQ;AACV,YAAM,KAAK,GAAG,0BAA0B,MAAM,OAAO,QAAQ,QAAQ,CAAC,CAAC;AAEzE,WAAO;AAAA,EACT;AACF;AAEA,SAAS,yCAAyC;AAAA,EAChD;AACF,GAEG;AACD,MAAI,qBAAqB,WAAW,QAAQ,GAAG;AAC7C,UAAM,qBAAqB,OAAO,qBAAqB,UAAU,CAAC,CAAC;AACnE,UAAMK,SAAQ,IAAI,KAAK,IAAI,qBAAqB,IAAI;AACpD,UAAM,SAAS,KAAK;AACpB,WAAOL,mCAAuCK,MAAK,aAAa,MAAM;AAAA,EACxE,OAAO;AACL,UAAMA,SAAQ,IAAI,KAAK,IAAI;AAC3B,UAAM,SAAS,KAAK;AACpB,WAAOL,yBAA6BA,KAAI;AAAA,MACtC;AAAA,IACF,CAAC,SAASK,MAAK,iBAAiB,MAAM;AAAA,EACxC;AACF;;;AE99EA;AAAA,EAKE,OAAAC;AAAA,OACK;AACP;AAAA,EAOE,mBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,eAAAC;AAAA,OACK;;;AClDP;AAAA,EAIE,eAAAC;AAAA,OACK;AA+BA,SAAS,iBACd,OACiD;AACjD,SAAO;AAAA,IACL,eAAe,MAAM,gBACjB,aAAa,MAAM,aAAa,IAChC;AAAA,IACJ,YAAY,aAAa,MAAM,UAAU;AAAA,IACzC,WAAW,MAAM;AAAA,IACjB,UAAU,aAAa,MAAM,QAAQ;AAAA,IACrC,SAAS,aAAa,MAAM,OAAO;AAAA,IACnC,MAAM,MAAM;AAAA,IACZ,WAAW,MAAM;AAAA,IACjB,OAAO,YAAY,MAAM,KAAK;AAAA,IAC9B,SAAS,MAAM,WAAW;AAAA,IAC1B,OAAO,MAAM,SAAS;AAAA,IACtB,QAAQ,aAAa,MAAM,MAAO;AAAA,IAClC,YAAY,MAAM;AAAA,IAClB,cAAc,MAAM;AAAA,IACpB,YAAY,MAAM,cAAc;AAAA,IAChC,MAAM,aAAa,MAAM,IAAI;AAAA,IAC7B,WAAW,MAAM;AAAA,IACjB,WAAW,aAAa,MAAM,SAAS;AAAA,IACvC,iBAAiB,MAAM,kBACnB,aAAa,MAAM,eAAe,IAClC;AAAA,IACJ,kBAAkB,MAAM;AAAA,EAC1B;AACF;AA4BO,SAAS,uBACd,aACwC;AACxC,SAAO;AAAA,IACL,YAAY,YAAY,aACpB,KAAK,UAAU,YAAY,UAAU,IACrC;AAAA,IACJ,WAAW,YAAY;AAAA,IACvB,aAAa,aAAa,YAAY,WAAY;AAAA,IAClD,MAAM,YAAY,YAAY,IAAI;AAAA,IAClC,KAAK,aAAa,YAAY,GAAG;AAAA,IACjC,UAAU,YAAY,WAAW,aAAa,YAAY,QAAQ,IAAI;AAAA,IACtE,MAAM,YAAY;AAAA,IAClB,OAAO,YAAY;AAAA,IACnB,cAAc,YAAY,eACtB,aAAa,YAAY,YAAY,IACrC;AAAA,IACJ,sBAAsB,YAAY,uBAC9B,aAAa,YAAY,oBAAoB,IAC7C;AAAA,IACJ,OAAOA,aAAY,YAAY,KAAK;AAAA,IACpC,GAAG,YAAY,KAAK;AAAA,IACpB,GAAG,YAAY,KAAK;AAAA,IACpB,IAAI,YAAY,KAAK,YAAY,YAAY,EAAE,IAAI;AAAA,IACnD,kBAAkB,OAAO,YAAY,gBAAgB;AAAA,IACrD,MAAM,YAAY,QAAQ;AAAA,IAC1B,OAAO,aAAa,YAAY,KAAK;AAAA,IACrC,GAAG,YAAY,IAAI,aAAa,YAAY,CAAC,IAAI;AAAA,EACnD;AACF;AAwBO,SAAS,8BACd,oBAC2C;AAC3C,SAAO;AAAA,IACL,WAAW,mBAAmB;AAAA,IAC9B,aAAa,aAAa,mBAAmB,WAAW;AAAA,IACxD,iBAAiB,mBAAmB,kBAChC,YAAY,mBAAmB,eAAe,IAC9C;AAAA,IACJ,mBAAmB,aAAa,mBAAmB,iBAAiB;AAAA,IACpE,mBAAmB,aAAa,mBAAmB,iBAAiB;AAAA,IACpE,MAAM,YAAY,mBAAmB,IAAI;AAAA,IACzC,SAAS,aAAa,mBAAmB,OAAO;AAAA,IAChD,MAAM,KAAK,UAAU,mBAAmB,IAAI;AAAA,IAC5C,WAAW,mBAAmB;AAAA,IAC9B,QAAQ,mBAAmB;AAAA,IAC3B,IAAI,mBAAmB,KAAK,YAAY,mBAAmB,EAAE,IAAI;AAAA,IACjE,iBAAiB,mBAAmB;AAAA,IACpC,kBAAkB,OAAO,mBAAmB,gBAAgB;AAAA,IAC5D,MAAM,mBAAmB;AAAA,EAC3B;AACF;AAuBO,SAAS,eAAe,KAA6C;AAC1E,SAAO;AAAA,IACL,SAAS,YAAY,IAAI,OAAO;AAAA,IAChC,WAAW,IAAI;AAAA,IACf,aAAa,aAAa,IAAI,WAAY;AAAA,IAC1C,MAAM,IAAI;AAAA,IACV,IAAI,GAAG,IAAI,SAAS,IAAI,IAAI,QAAQ;AAAA,IACpC,UAAU,OAAO,IAAI,QAAS;AAAA,IAC9B,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,QAAQ,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI;AAAA,IACxC,iBAAiB,IAAI;AAAA,IACrB,kBAAkB,OAAO,IAAI,gBAAiB;AAAA,EAChD;AACF;AA0BO,SAAS,iBACd,OACqD;AACrD,SAAO;AAAA,IACL,IAAI,GAAG,MAAM,eAAe,IAAI,KAAK,UAAU,MAAM,YAAY,CAAC;AAAA,IAClE,UAAU,MAAM,OAAO;AAAA,IACvB,MAAM,YAAY,MAAM,OAAO,IAAI;AAAA,IACnC,KAAK,aAAa,MAAM,OAAO,GAAG;AAAA,IAClC,OAAO,MAAM,OAAO;AAAA,IACpB,IAAI,YAAY,MAAM,OAAO,EAAE;AAAA,IAC/B,OAAO,aAAa,MAAM,OAAO,KAAK;AAAA,IACtC,WAAW,MAAM;AAAA,IACjB,aAAa,aAAa,MAAM,WAAW;AAAA,IAC3C,OAAO,MAAM,SAAS;AAAA,IACtB,SAAS,MAAM,SAAS,aAAa,MAAM,OAAO,OAAO,IAAI;AAAA,IAC7D,QAAQ,MAAM,SAAS,MAAM,OAAO,SAAS;AAAA,IAC7C,WAAW,MAAM;AAAA,IACjB,cAAc,KAAK,UAAU,MAAM,YAAY;AAAA,IAC/C,iBAAiB,MAAM;AAAA,IACvB,qBAAqB,MAAM;AAAA,IAC3B,kBAAkB,MAAM,OAAO,MAAM,MAAM,GAAG,EAAE,EAAE,YAAY;AAAA,EAChE;AACF;;;AD5LO,IAAM,kBAAN,MAA2C;AAAA,EAChD,OAAO;AAAA,EACP;AAAA,EAEA,YAAY,EAAE,GAAG,GAA4C;AAC3D,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,iBAAiB,QAAQ;AAAA,UAC5B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,oBAAoB;AAAA,YAC5D,GAAG,uBAAuB,cAAc;AAAA,YACxC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,8BAA8B,qBAAqB;AAAA,cACtD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,QACb;AAEA,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,eAAe,MAAM;AAAA,YACxB;AAAA,YACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,UAChE,EAAE;AACF,gBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,cACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,YAC1C,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,yBAAyB;AAAA,UAClC;AAAA,UACA;AAAA,UACA,YAAY,CAAC,SAAS;AAAA,UACtB;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,wBAAwB,OAAO;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,wBAAwB,GAAG,YAAY;AACnE,YAAM,YAAY,wBAAwB,EAAE,GAAG,WAAW,QAAQ,CAAC;AAGnE,YAAM,QAAQ;AAAA,QACZ,UAAU,IAAI,OAAO,aAAa;AAChC,iBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,kBAAM,EAAE,IAAI,YAAY,IAAI,MAAM,GAC/B,WAAW,YAAY,EACvB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,YAAY,QAAQ,CAAC,EAC3C,aAAa,EACb,wBAAwB;AAE3B,kBAAM,uBAAuB,MAAM,GAChC,WAAW,oBAAoB,EAC/B,MAAM,eAAe,KAAK,WAAW,EACrC,aAAa,EACb,QAAQ;AAEX,kBAAM,kBAAkB;AAAA,cACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,gBAC9B,OAAO,eAAe,EAAE,UAAU,CAAC;AAAA,gBACnC,OAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,cACnC,CAAC;AAAA,YACH;AAEA,kBAAM,qBAAqB,gBAAgB;AAAA,cACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,gBAC3B;AAAA,gBACA,YAAY,aAAa,UAAU;AAAA,gBACnC,UAAU,aAAa,QAAQ;AAAA,cACjC;AAAA,YACF;AAEA,gBAAI,mBAAmB,SAAS,GAAG;AACjC,oBAAM,GACH,WAAW,oBAAoB,EAC/B,OAAO,kBAAkB,EACzB,QAAQ;AAAA,YACb;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,YAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,QACC;AAAA,QACA,MACEC,gBAAeA,KAAI;AAAA,UACjB,UAAU;AAAA,YACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,cACnD,EAAE;AAAA,YACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI;AAAA,cACpD,EAAE;AAAA,YACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,0BAA0B,CAAC;AAAA,UAC/C;AAAA,QACF,CAAC;AAAA,MACL,EACC,WAAW,oBAAoB,EAC/B,UAAU,cAAc,eAAe,eAAe,EACtD,UAAU,sBAAsB,CAAC,SAAS;AACzC,YAAI,WAAW,KAAK;AAAA,UAAG,CAAC,OACtB,GAAG,GAAG;AAAA,YACJ,GAAG,WAAW,MAAM,IAAI;AAAA,YACxB,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,UAC/C,CAAC;AAAA,QACH;AACA,mBAAW,SAAS;AAAA,UAAG,CAAC,OACtB;AAAA,YACE;AAAA,YACA;AAAA,YACAA,KAAI,IAAI,4BAA4B;AAAA,UACtC;AAAA,QACF;AACA,mBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,qBAAW,SAAS,GAAG,CAAC,OAAO;AAC7B,kBAAM,MAAM;AACZ,mBAAO,GAAG,GAAG;AAAA,cACX,GAAG,QAAQ,GAAG,IAAI,MAAM,IAAI;AAAA,cAC5B,GAAG,gBAAgB,GAAG,IAAI,KAAKA,KAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AAAA,YACvD,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,eAAO;AAAA,MACT,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAM,wBAAwB,UAAU;AAAA,QACtC,CAAC,KAAK,QAAQ;AACZ,gBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,WAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK;AAAA,YAC5B,OAAO,eAAe,UAAU,CAAC;AAAA,YACjC,OAAO,eAAe,QAAQ,CAAC;AAAA,UACjC,CAAC;AACD,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAEA,YAAM,2BAA2B,UAAU;AAAA,QAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,MACjD;AACA,aAAO,yBAAyB,wBAAwB;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,gCAAgC,OAAO;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,EACR,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,gCAAgC;AAAA,MAC1C,YAAY;AACV,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,eAAe,MAAM;AAAA,YACxB;AAAA,UACF,EAAE;AACF,gBAAM,KAAK,GACR,WAAW,MAAM,EACjB,OAAO,IAAI,EACX,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,yBAAyB;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW;AAAA,EACb,GAMG;AACD,UAAM,EAAE,SAAS,eAAe,qBAAqB,IAAI;AACzD,UAAM,+BACJC,0CAAyC,EAAE,qBAAqB,CAAC;AAEnE,UAAM,YAAY,KAAK,GACpB,WAAW,MAAM,EACjB,OAAO,CAAC,MAAM,6BAA6B,GAAG,cAAc,CAAC,CAAC,EAC9D,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,UAAU,KAAK,aAAa,EAClC,MAAM,eAAe,MAAM,aAAa,SAAS,CAAC,EAClD,MAAM,eAAe,MAAM,aAAa,OAAO,CAAC,EAChD,QAAQ,MAAM,KAAK,EACnB,MAAM,QAAQ;AAEjB,QAAI,SAA6B;AAEjC,WAAO,MAAM;AACX,UAAIC,SAAQ;AACZ,UAAI,WAAW;AAAW,QAAAA,SAAQA,OAAM,MAAM,MAAM,KAAK,MAAM;AAE/D,YAAM,QAAQ,MAAM,KAAK,GAAG;AAAA,QAC1B,EAAE,QAAQ,2BAA2B;AAAA,QACrC,MAAMA,OAAM,QAAQ;AAAA,MACtB;AAEA,UAAI,MAAM,SAAS,GAAG;AACpB,cAAM,MAAM,IAAI,CAAC,MAAM,EAAE,YAAY;AAAA,MACvC;AAGA,UAAI,MAAM,SAAS;AAAU;AAE7B,eAAS,MAAM,MAAM,SAAS,CAAC,EAAE;AAAA,IACnC;AAAA,EACF;AAAA,EAEA,iCAAiC,OAAO;AAAA,IACtC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,iCAAiC;AAAA,MAC3C,YAAY;AACV,cAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,iBAAiB,QAAQ;AAAA,YAC5B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,cAAI,gBAAgB,SAAS,GAAG;AAC9B,kBAAM,eAAe,gBAAgB,IAAI,CAAC,oBAAoB;AAAA,cAC5D,GAAG,uBAAuB,cAAc;AAAA,cACxC;AAAA,YACF,EAAE;AACF,kBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,UACb;AAEA,cAAI,uBAAuB,SAAS,GAAG;AACrC,kBAAM,sBAAsB,uBAAuB;AAAA,cACjD,CAAC,2BAA2B;AAAA,gBAC1B,GAAG,8BAA8B,qBAAqB;AAAA,gBACtD;AAAA,cACF;AAAA,YACF;AACA,kBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,UACb;AAEA,cAAI,QAAQ,SAAS,GAAG;AACtB,kBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,cACpC,GAAG,eAAe,MAAM;AAAA,cACxB;AAAA,cACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,YAChE,EAAE;AACF,kBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,cAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,gBACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,cAC1C,EAAE;AAAA,YACJ,EACC,QAAQ;AAAA,UACb;AAEA,gBAAM,KAAK,gCAAgC;AAAA,YACzC;AAAA,YACA;AAAA,YACA,mBAAmB,CAAC,OAAO;AAAA,YAC3B;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,+BAA+B,OAAO;AAAA,IACpC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,+BAA+B;AAAA,MACzC,YAAY;AACV,cAAM,YAAY,yBAAyB,EAAE,GAAG,SAAS,QAAQ,CAAC;AAElE,cAAM,QAAQ;AAAA,UACZ,UAAU,IAAI,OAAO,aAAa;AAChC,mBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,oBAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,mBAAmB,EAC9B,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,YAAY,QAAQ,CAAC,EAC3C,aAAa,EACb,wBAAwB;AAE3B,oBAAM,oBAAoB,MAAM,GAC7B,WAAW,2BAA2B,EACtC,MAAM,aAAa,KAAK,SAAS,EACjC,aAAa,EACb,QAAQ;AAEX,oBAAM,kBAAkB;AAAA,gBACtB,kBAAkB,IAAI,CAAC,MAAM;AAAA,kBAC3B,OAAO,eAAe,EAAE,UAAU,CAAC;AAAA,kBACnC,OAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,gBACnC,CAAC;AAAA,cACH;AAEA,oBAAM,qBAAqB,gBAAgB;AAAA,gBACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,kBAC3B;AAAA,kBACA,YAAY,aAAa,UAAU;AAAA,kBACnC,UAAU,aAAa,QAAQ;AAAA,gBACjC;AAAA,cACF;AAEA,kBAAI,mBAAmB,SAAS,GAAG;AACjC,sBAAM,GACH,WAAW,2BAA2B,EACtC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,cACb;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,cAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,UACC;AAAA,UACA,MACEF,gBAAeA,KAAI;AAAA,YACjB,UAAU;AAAA,cACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,gBACnD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,oBAAoB,CAAC,KAAKA,KAAI;AAAA,gBAC5C,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI,IAAI,EAAE,MAAM,CAAC,KAAKA,KAAI;AAAA,gBACpD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,0BAA0B,CAAC;AAAA,YAC/C;AAAA,UACF,CAAC;AAAA,QACL,EACC,WAAW,2BAA2B,EACtC,UAAU,qBAAqB,aAAa,sBAAsB,EAClE,UAAU,0BAA0B,CAAC,SAAS;AAC7C,cAAI,WAAW,KAAK;AAAA,YAAG,CAAC,OACtB,GAAG,IAAI;AAAA,cACL,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,cAC7C,GAAG,yBAAyB,KAAKA,KAAI,IAAI,eAAe,CAAC;AAAA,cACzD;AAAA,gBACE;AAAA,gBACA;AAAA,gBACAA,KAAI,IAAI,sBAAsB;AAAA,cAChC;AAAA,YACF,CAAC;AAAA,UACH;AACA,qBAAW,SAAS;AAAA,YAAG,CAAC,OACtB;AAAA,cACE;AAAA,cACA;AAAA,cACAA,KAAI,IAAI,4BAA4B;AAAA,YACtC;AAAA,UACF;AACA,qBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,uBAAW,SAAS,GAAG,CAAC,OAAO;AAC7B,oBAAM,MAAM;AACZ,qBAAO,GAAG,GAAG;AAAA,gBACX,GAAG,QAAQ,GAAG,IAAI,MAAM,IAAI;AAAA,gBAC5B,GAAG,gBAAgB,GAAG,IAAI,KAAKA,KAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AAAA,cACvD,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAEA,iBAAO;AAAA,QACT,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,cAAM,wBAAwB,UAAU;AAAA,UACtC,CAAC,KAAK,QAAQ;AACZ,kBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,aAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK;AAAA,cAC5B,OAAO,UAAU;AAAA,cACjB,OAAO,QAAQ;AAAA,YACjB,CAAC;AACD,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,2BAA2B,UAAU;AAAA,UAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,QACjD;AACA,eAAO,yBAAyB,wBAAwB;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,4BAA4B,OAAO;AAAA,IACjC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP;AAAA,EACF,MAKqB;AACnB,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACvE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,YAAI,aAAa,QAAW;AAC1B,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,iBAAiB,QAAQ;AAAA,YAC5B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA,cAAc,CAAC,WAAW;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,WAAW;AAAA,QACf,IAAI,GAAG,OAAO,IAAI,YAAY,QAAQ,IAAI,YAAY,MAAM;AAAA,QAC5D;AAAA,QACA,UAAU,YAAY;AAAA,QACtB,QAAQ,YAAY;AAAA,MACtB;AAGA,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,YAAY,QAAQ,CAAC,EAC3C,aAAa,EACb,wBAAwB;AAE3B,cAAM,uBAAuB,MAAM,GAChC,WAAW,sBAAsB,EACjC,MAAM,iBAAiB,KAAK,aAAa,EACzC,aAAa,EACb,QAAQ;AAEX,cAAM,kBAAkB;AAAA,UACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,YAC9B,OAAO,eAAe,EAAE,UAAU,CAAC;AAAA,YACnC,OAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,UACnC,CAAC;AAAA,QACH;AAEA,cAAM,qBAAqB,gBAAgB;AAAA,UACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,YAC3B;AAAA,YACA,YAAY,aAAa,UAAU;AAAA,YACnC,UAAU,aAAa,QAAQ;AAAA,UACjC;AAAA,QACF;AAEA,YAAI,mBAAmB,SAAS,GAAG;AACjC,gBAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAED,YAAM,YAAY,MAAM,KAAK,GAC1B,WAAW,sBAAsB,EACjC,UAAU,gBAAgB,iBAAiB,iBAAiB,EAC5D,OAAO;AAAA,QACN;AAAA,QACA;AAAA,MACF,CAAC,EACA,MAAM,iBAAiB,KAAK,SAAS,EAAE,EACvC,QAAQ;AAEX,aAAO,UAAU;AAAA,QACf,CAAC,EAAE,YAAY,SAAS,MACtB,CAAC,OAAO,UAAU,GAAG,OAAO,QAAQ,CAAC;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,OAAO;AAAA,IAChB;AAAA,IACA;AAAA,EACF,MAGwB;AACtB,UAAM,WAAW,MAAM,KAAK,GACzB,WAAW,QAAQ,EACnB,OAAO,MAAM,EACb,MAAM,UAAU,KAAK,aAAa,WAAW,CAAC,EAC9C,MAAM,WAAW,KAAK,OAAO,EAC7B,iBAAiB;AAEpB,WAAO,aAAa;AAAA,EACtB;AAAA,EAEA,4BAA4B,OAAO;AAAA,IACjC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,4BAA4B,GAAG,YAAY;AACvE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,iBAAiB,QAAQ;AAAA,UAC5B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,iBAAiB;AAAA,YACzD,GAAG,uBAAuB,WAAW;AAAA,YACrC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,8BAA8B,qBAAqB;AAAA,cACtD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,QACb;AAIA,cAAM,yBAEF,CAAC;AACL,mBAAW,SAAS,WAAW;AAC7B,cAAI,uBAAuB,MAAM,eAAe,MAAM,QAAW;AAC/D,mCAAuB,MAAM,eAAe,IAAI,CAAC;AAAA,UACnD;AACA,iCAAuB,MAAM,eAAe,EAAE,KAAK,KAAK;AAAA,QAC1D;AAEA,mBAAW,mBAAmB,OAAO,KAAK,sBAAsB,GAAG;AACjE,gBAAM,SAAS,MAAM,GAClB,WAAW,YAAY,EACvB,aAAa,EACb,MAAM,mBAAmB,KAAK,eAAsB,EACpD,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,UAAC,OAAqD;AAAA,YACpD,GAAG,uBAAuB,eAAsB,EAAE,IAAI,CAAC,WAAW;AAAA,cAChE,GAAG,iBAAiB,KAAK;AAAA,cACzB;AAAA,YACF,EAAE;AAAA,UACJ;AAGA,iBAAO,KAAK,CAAC,GAAG,MAAM;AACpB,mBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,UAChD,CAAC;AAED,mBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,kBAAM,QAAQ,OAAO,CAAC;AACtB,kBAAM,aAAa,iBAAiB;AAAA,cAClC,gBAAgBG,aAAY,SAAS,SAAS;AAAA,cAC9C,SAAS,OAAO,OAAO;AAAA,cACvB,aAAa,eAAe,MAAM,WAAW;AAAA,cAC7C,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,cAClD,WAAW,YAAY;AAAA,cACvB,YAAY,OAAO,CAAC;AAAA,YACtB,CAAC;AAED,kBAAM,aAAa;AAAA,UACrB;AAEA,gBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,UAAU,CAAC,EACjC,QAAQ;AAAA,QACb;AAEA,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA,cAAc,CAAC,WAAW;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,0BAA0B,OAAO;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,0BAA0B,GAAG,YAAY;AACrE,YAAM,YAAY,oBAAoB,EAAE,GAAG,aAAa,QAAQ,CAAC;AAGjE,YAAM,QAAQ;AAAA,QACZ,UAAU,IAAI,OAAO,aAAa;AAChC,iBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,kBAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,kBAAM,uBAAuB,MAAM,GAChC,WAAW,sBAAsB,EACjC,MAAM,iBAAiB,KAAK,aAAa,EACzC,aAAa,EACb,QAAQ;AAEX,kBAAM,kBAAkB;AAAA,cACtB,qBAAqB,IAAI,CAAC,MAAM;AAAA,gBAC9B,OAAO,eAAe,EAAE,UAAU,CAAC;AAAA,gBACnC,OAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,cACnC,CAAC;AAAA,YACH;AAEA,kBAAM,qBAAqB,gBAAgB;AAAA,cACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,gBAC3B;AAAA,gBACA,YAAY,aAAa,UAAU;AAAA,gBACnC,UAAU,aAAa,QAAQ;AAAA,cACjC;AAAA,YACF;AAEA,gBAAI,mBAAmB,SAAS,GAAG;AACjC,oBAAM,GACH,WAAW,sBAAsB,EACjC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,YACb;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,YAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,QACC;AAAA,QACA,MACEH,gBAAeA,KAAI;AAAA,UACjB,UAAU;AAAA,YACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,WAAW,CAAC,KAAKA,KAAI;AAAA,cACvD,EAAE;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACF,CAAC;AAAA,MACL,EACC,WAAW,sBAAsB,EACjC,UAAU,gBAAgB,iBAAiB,iBAAiB,EAC5D,UAAU,wBAAwB,CAAC,SAAS;AAC3C,eAAO,KAAK;AAAA,UAAG,CAAC,OACd,GAAG,IAAI;AAAA,YACL,GAAG,GAAG;AAAA,cACJ,GAAG,eAAe,MAAM,IAAI;AAAA,cAC5B,GAAG,uBAAuB,KAAKA,KAAI,IAAI,aAAa,CAAC;AAAA,YACvD,CAAC;AAAA,YACD,GAAG,GAAG;AAAA,cACJ,GAAG,aAAa,MAAM,IAAI;AAAA,cAC1B,GAAG,qBAAqB,KAAKA,KAAI,IAAI,WAAW,CAAC;AAAA,YACnD,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF,CAAC,EACA,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAM,wBAAwB,UAAU;AAAA,QACtC,CAAC,KAAK,QAAQ;AACZ,gBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,WAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO,UAAU,GAAG,OAAO,QAAQ,CAAC,CAAC;AACpE,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAEA,YAAM,2BAA2B,UAAU;AAAA,QAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,MACjD;AACA,aAAO,yBAAyB,wBAAwB;AAAA,IAC1D,CAAC;AAAA,EACH;AAAA,EAEA,mCAAmC,OAAO;AAAA,IACxC;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,mCAAmC;AAAA,MAC7C,YAAY;AACV,cAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,gBAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,YACN,GAAG,iBAAiB,QAAQ;AAAA,YAC5B;AAAA,YACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,UAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,cAAI,gBAAgB,SAAS,GAAG;AAC9B,kBAAM,eAAe,gBAAgB,IAAI,CAAC,oBAAoB;AAAA,cAC5D,GAAG,uBAAuB,cAAc;AAAA,cACxC;AAAA,YACF,EAAE;AACF,kBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAAA,UACb;AAEA,cAAI,uBAAuB,SAAS,GAAG;AACrC,kBAAM,sBAAsB,uBAAuB;AAAA,cACjD,CAAC,2BAA2B;AAAA,gBAC1B,GAAG,8BAA8B,qBAAqB;AAAA,gBACtD;AAAA,cACF;AAAA,YACF;AACA,kBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,iBAAiB,EAAE,UAAU,CAAC,EAC3D,QAAQ;AAAA,UACb;AAIA,gBAAM,yBAEF,CAAC;AACL,qBAAW,SAAS,WAAW;AAC7B,gBAAI,uBAAuB,MAAM,eAAe,MAAM,QAAW;AAC/D,qCAAuB,MAAM,eAAe,IAAI,CAAC;AAAA,YACnD;AACA,mCAAuB,MAAM,eAAe,EAAE,KAAK,KAAK;AAAA,UAC1D;AAEA,qBAAW,mBAAmB,OAAO,KAAK,sBAAsB,GAAG;AACjE,kBAAM,SAAS,MAAM,GAClB,WAAW,YAAY,EACvB,aAAa,EACb,MAAM,mBAAmB,KAAK,eAAsB,EACpD,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,YAAC,OAAqD;AAAA,cACpD,GAAG,uBAAuB,eAAsB,EAAE;AAAA,gBAChD,CAAC,WAAW;AAAA,kBACV,GAAG,iBAAiB,KAAK;AAAA,kBACzB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAGA,mBAAO,KAAK,CAAC,GAAG,MAAM;AACpB,qBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,YAChD,CAAC;AAED,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,oBAAM,QAAQ,OAAO,CAAC;AACtB,oBAAM,aAAa,iBAAiB;AAAA,gBAClC,gBAAgBG,aAAY,SAAS,SAAS;AAAA,gBAC9C,SAAS,OAAO,OAAO;AAAA,gBACvB,aAAa,eAAe,MAAM,WAAW;AAAA,gBAC7C,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,gBAClD,WAAW,YAAY;AAAA,gBACvB,YAAY,OAAO,CAAC;AAAA,cACtB,CAAC;AAED,oBAAM,aAAa;AAAA,YACrB;AAEA,kBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,UACb;AAEA,gBAAM,KAAK,kCAAkC;AAAA,YAC3C;AAAA,YACA;AAAA,YACA,qBAAqB,CAAC,OAAO;AAAA,YAC7B;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,iCAAiC,OAAO;AAAA,IACtC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,WAAO,KAAK,GAAG;AAAA,MACb,EAAE,QAAQ,iCAAiC;AAAA,MAC3C,YAAY;AACV,cAAM,YAAY,2BAA2B,EAAE,GAAG,SAAS,QAAQ,CAAC;AAEpE,cAAM,QAAQ;AAAA,UACZ,UAAU,IAAI,OAAO,aAAa;AAChC,mBAAO,MAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AACvD,oBAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,qBAAqB,EAChC,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,YAAY,QAAQ,CAAC,EAC3C,aAAa,EACb,wBAAwB;AAE3B,oBAAM,oBAAoB,MAAM,GAC7B,WAAW,6BAA6B,EACxC,MAAM,aAAa,KAAK,SAAS,EACjC,aAAa,EACb,QAAQ;AAEX,oBAAM,kBAAkB;AAAA,gBACtB,kBAAkB,IAAI,CAAC,MAAM;AAAA,kBAC3B,OAAO,eAAe,EAAE,UAAU,CAAC;AAAA,kBACnC,OAAO,eAAe,EAAE,QAAQ,CAAC;AAAA,gBACnC,CAAC;AAAA,cACH;AAEA,oBAAM,qBAAqB,gBAAgB;AAAA,gBACzC,CAAC,CAAC,YAAY,QAAQ,OAAO;AAAA,kBAC3B;AAAA,kBACA,YAAY,aAAa,UAAU;AAAA,kBACnC,UAAU,aAAa,QAAQ;AAAA,gBACjC;AAAA,cACF;AAEA,kBAAI,mBAAmB,SAAS,GAAG;AACjC,sBAAM,GACH,WAAW,6BAA6B,EACxC,OAAO,kBAAkB,EACzB,QAAQ;AAAA,cACb;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAEA,cAAM,YAAY,MAAM,KAAK,GAC1B;AAAA,UACC;AAAA,UACA,MACEH,gBAAeA,KAAI;AAAA,YACjB,UAAU;AAAA,cACR,CAAC,MACCA,SAAQA,KAAI,IAAI,EAAE,EAAE,CAAC,KAAKA,KAAI,IAAI,EAAE,OAAO,CAAC,KAAKA,KAAI;AAAA,gBACnD,EAAE;AAAA,cACJ,CAAC,KAAKA,KAAI,IAAI,EAAE,oBAAoB,CAAC,KAAKA,KAAI;AAAA,gBAC5C,EAAE;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACF,CAAC;AAAA,QACL,EACC,WAAW,6BAA6B,EACxC;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,QACF,EACC;AAAA,UAAU;AAAA,UAA0B,CAAC,SACpC,KAAK;AAAA,YAAG,CAAC,OACP,GAAG,IAAI;AAAA,cACL,GAAG,mBAAmB,KAAKA,KAAI,IAAI,SAAS,CAAC;AAAA,cAC7C,GAAG,yBAAyB,KAAKA,KAAI,IAAI,eAAe,CAAC;AAAA,cACzD;AAAA,gBACE;AAAA,gBACA;AAAA,gBACAA,KAAI,IAAI,sBAAsB;AAAA,cAChC;AAAA,cACA,GAAG,GAAG;AAAA,gBACJ,GAAG,eAAe,MAAM,IAAI;AAAA,gBAC5B,GAAG,uBAAuB,KAAKA,KAAI,IAAI,aAAa,CAAC;AAAA,cACvD,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF,EACC,OAAO,CAAC,cAAc,cAAc,UAAU,CAAC,EAC/C,MAAM,WAAW,KAAK,OAAO,EAC7B,QAAQ;AAEX,cAAM,wBAAwB,UAAU;AAAA,UACtC,CAAC,KAAK,QAAQ;AACZ,kBAAM,EAAE,YAAY,YAAY,SAAS,IAAI;AAC7C,aAAC,IAAI,UAAU,MAAM,CAAC,GAAG,KAAK;AAAA,cAC5B,OAAO,UAAU;AAAA,cACjB,OAAO,QAAQ;AAAA,YACjB,CAAC;AACD,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,2BAA2B,UAAU;AAAA,UAAI,CAAC,MAC9C,cAAc,sBAAsB,EAAE,EAAE,KAAK,CAAC,CAAC;AAAA,QACjD;AACA,eAAO,yBAAyB,wBAAwB;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,sBAAsB,OAAO;AAAA,IAC3B;AAAA,IACA,OAAO;AAAA,IACP,cAAc;AAAA,IACd,qBAAqB;AAAA,IACrB,MAAM;AAAA,IACN,QAAQ;AAAA,EACV,MAOM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,sBAAsB,GAAG,YAAY;AACjE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,GACH,WAAW,QAAQ,EACnB,OAAO;AAAA,UACN,GAAG,iBAAiB,QAAQ;AAAA,UAC5B;AAAA,UACA,YAAY,KAAK,sBAAsB,UAAU,OAAO;AAAA,QAC1D,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,OAAO,MAAM,EAAE,UAAU,CAAC,EAChD,QAAQ;AAEX,YAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAM,eAAe,gBAAgB,IAAI,CAAC,oBAAoB;AAAA,YAC5D,GAAG,uBAAuB,cAAc;AAAA,YACxC;AAAA,UACF,EAAE;AACF,gBAAM,GACH,WAAW,cAAc,EACzB,OAAO,YAAY,EACnB;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,MAAM,EAAE,YAAY,CAAC,QAAQ;AAAA,cACrC,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,aAAa,GAAG,IAAI,sBAAsB;AAAA,cAC1C,kBAAkB,GAAG,IAAI,2BAA2B;AAAA,YACtD,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,uBAAuB,SAAS,GAAG;AACrC,gBAAM,sBAAsB,uBAAuB;AAAA,YACjD,CAAC,2BAA2B;AAAA,cAC1B,GAAG,8BAA8B,qBAAqB;AAAA,cACtD;AAAA,YACF;AAAA,UACF;AACA,gBAAM,GACH,WAAW,qBAAqB,EAChC,OAAO,mBAAmB,EAC1B;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,iBAAiB,EAAE,YAAY,CAAC,QAAQ;AAAA,cAChD,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,aAAa,GAAG,IAAI,sBAAsB;AAAA,cAC1C,iBAAiB,GAAG,IAAI,0BAA0B;AAAA,cAClD,mBAAmB,GAAG,IAAI,4BAA4B;AAAA,cACtD,mBAAmB,GAAG,IAAI,4BAA4B;AAAA,cACtD,SAAS,GAAG,IAAI,kBAAkB;AAAA,cAClC,MAAM,GAAG,IAAI,eAAe;AAAA,cAC5B,WAAW,GAAG,IAAI,oBAAoB;AAAA,cACtC,kBAAkB,GAAG,IAAI,2BAA2B;AAAA,YACtD,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,YACpC,GAAG,eAAe,MAAM;AAAA,YACxB;AAAA,YACA,YAAY,KAAK,oBAAoB,QAAQ,UAAU,OAAO;AAAA,UAChE,EAAE;AACF,gBAAM,GACH,WAAW,MAAM,EACjB,OAAO,IAAI,EACX;AAAA,YAAW,CAAC,OACX,GAAG,OAAO,IAAI,EAAE,YAAY,CAAC,QAAQ;AAAA,cACnC,YAAY,GAAG,IAAI,qBAAqB;AAAA,YAC1C,EAAE;AAAA,UACJ,EACC,QAAQ;AAAA,QACb;AAEA,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,SAAS,UACZ,IAAI,CAAC,OAAO,OAAO;AAAA,YAClB,GAAG,iBAAiB,KAAK;AAAA,YACzB;AAAA,YACA,YAAY,iBAAiB;AAAA,cAC3B,gBAAgBG,aAAY,SAAS,SAAS;AAAA,cAC9C,SAAS,OAAO,OAAO;AAAA,cACvB,aAAaC,aAAY,MAAM,WAAW;AAAA,cAC1C,kBAAkB,OAAO,MAAM,mBAAmB;AAAA,cAClD,WAAW,YAAY;AAAA,cACvB,YAAY,OAAO,CAAC;AAAA,YACtB,CAAC;AAAA,UACH,EAAE,EACD,KAAK,CAAC,GAAG,MAAM;AACd,gBAAI,EAAE,kBAAkB,EAAE;AAAiB,qBAAO;AAClD,gBAAI,EAAE,kBAAkB,EAAE;AAAiB,qBAAO;AAClD,mBAAO,EAAE,eAAe,EAAE,eAAe,KAAK;AAAA,UAChD,CAAC;AAEH,gBAAM,GACH,WAAW,YAAY,EACvB,OAAO,MAAM,EACb,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,UAAU,CAAC,EAC9C,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEQ,sBAAsB,CAC5B,QACA,OACA,YACG;AACH,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AACA,QAAI,OAAO,qBAAqB,MAAM;AACpC,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,OAAO,aAAa,MAAM;AAC5B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AACA,WAAO,iBAAiB;AAAA,MACtB,gBAAgB,OAAO,OAAO,MAAM,SAAS,CAAC;AAAA,MAC9C,SAAS,OAAO,OAAO;AAAA,MACvB,aAAaA,aAAY,MAAM,MAAM;AAAA,MACrC,kBAAkBA,aAAY,OAAO,gBAAgB;AAAA,MACrD,WAAW,YAAY;AAAA,MACvB,YAAYA,aAAY,OAAO,QAAQ;AAAA,IACzC,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAwB,CAAC,OAAiB,YAAoB;AACpE,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAEA,WAAO,iBAAiB;AAAA,MACtB,gBAAgBD,aAAY,MAAM,SAAS;AAAA,MAC3C,SAAS,OAAO,OAAO;AAAA,MACvB,aAAaC,aAAY,MAAM,MAAM;AAAA,MACrC,kBAAkB,cAAc;AAAA,MAChC,WAAW,YAAY;AAAA,MACvB,YAAY,eAAe;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,yBAAyB,OAAO;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAQM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,KAAK,yBAAyB;AAAA,UAClC;AAAA,UACA;AAAA,UACA,YAAY;AAAA,YACV,GAAG;AAAA,YACH,GAAG,kBAAkB,IAAI,CAAC,OAAO;AAAA,cAC/B,SAAS,EAAE;AAAA,cACX,QAAQ,CAAC,EAAE,aAAa;AAAA,cACxB,4BAA4B,EAAE;AAAA,YAChC,EAAE;AAAA,YACF,GAAG,oBAAoB,IAAI,CAAC,OAAO;AAAA,cACjC,SAAS,EAAE;AAAA,cACX,QAAQ,CAAC,EAAE,aAAa;AAAA,cACxB,4BAA4B,EAAE;AAAA,YAChC,EAAE;AAAA,UACJ;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,gCAAgC;AAAA,UACzC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,2BAA2B;AAAA,UACpC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,KAAK,kCAAkC;AAAA,UAC3C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,qBAAqB,OAAO;AAAA,IAC1B;AAAA,IACA,WAAW;AAAA,EACb,MAGM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,qBAAqB,GAAG,YAAY;AAChE,YAAM,KAAK,GAAG,YAAY,EAAE,QAAQ,OAAO,OAAO;AAChD,cAAM,YAAY,aAAa,UAAU;AAEzC,cAAM,GACH,WAAW,MAAM,EACjB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AACX,cAAM,GACH,WAAW,QAAQ,EACnB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,UAAU,KAAK,SAAS,EAC9B,QAAQ;AACX,cAAM,GACH,WAAW,mBAAmB,EAC9B,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AACX,cAAM,GACH,WAAW,YAAY,EACvB,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,eAAe,KAAK,SAAS,EACnC,QAAQ;AAAA,MACb,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA,EAIQ,2BAA2B,OAAO;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,qBAAqB,WAAW;AAAA,MAAQ,CAAC,cAC7C,wBAAwB,EAAE,GAAG,WAAW,QAAQ,CAAC;AAAA,IACnD;AAEA,UAAM,QAAQ;AAAA,MACZ,mBAAmB,IAAI,OAAO,sBAAsB;AAClD,cAAM,EAAE,IAAI,YAAY,IAAI,MAAM,GAC/B,WAAW,YAAY,EACvB,OAAO,iBAAiB,EACxB,WAAW,CAAC,OAAO,GAAG,YAAY,iBAAiB,CAAC,EACpD,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,oBAAoB,EAC/B,OAAO;AAAA,UACN;AAAA,UACA,YAAY,aAAa,UAAU;AAAA,UACnC,UAAU,aAAa,QAAQ;AAAA,QACjC,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,kCAAkC,OAAO;AAAA,IAC/C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,mBAAmB,kBAAkB;AAAA,MAAQ,CAAC,YAClD,yBAAyB,EAAE,GAAG,SAAS,QAAQ,CAAC;AAAA,IAClD;AAEA,UAAM,QAAQ;AAAA,MACZ,iBAAiB,IAAI,OAAO,aAAa;AACvC,cAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,mBAAmB,EAC9B,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,YAAY,QAAQ,CAAC,EAC3C,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,2BAA2B,EACtC,OAAO;AAAA,UACN;AAAA,UACA,YAAY,aAAa,UAAU;AAAA,UACnC,UAAU,aAAa,QAAQ;AAAA,QACjC,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,6BAA6B,OAAO;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,uBAAuB,aAAa,QAAQ,CAAC,gBAAgB;AACjE,aAAO;AAAA,QACL,IAAI,GAAG,OAAO,IAAI,YAAY,QAAQ,IAAI,YAAY,MAAM;AAAA,QAC5D;AAAA,QACA,UAAU,YAAY;AAAA,QACtB,QAAQ,YAAY;AAAA,MACtB;AAAA,IACF,CAAC;AAED,UAAM,QAAQ;AAAA,MACZ,qBAAqB,IAAI,OAAO,wBAAwB;AACtD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,YAAY,mBAAmB,CAAC,EACtD,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,sBAAsB,EACjC,OAAO;AAAA,UACN;AAAA,UACA,YAAY,aAAa,UAAU;AAAA,UACnC,UAAU,aAAa,QAAQ;AAAA,QACjC,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,6BAA6B,OAAO;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,uBAAuB,aAAa;AAAA,MAAQ,CAAC,gBACjD,oBAAoB,EAAE,GAAG,aAAa,QAAQ,CAAC;AAAA,IACjD;AAEA,UAAM,QAAQ;AAAA,MACZ,qBAAqB,IAAI,OAAO,wBAAwB;AACtD,cAAM,EAAE,IAAI,cAAc,IAAI,MAAM,GACjC,WAAW,cAAc,EACzB,OAAO,mBAAmB,EAC1B,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,mBAAmB,CAAC,EACnE,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,sBAAsB,EACjC,OAAO;AAAA,UACN;AAAA,UACA,YAAY,aAAa,UAAU;AAAA,UACnC,UAAU,aAAa,QAAQ;AAAA,QACjC,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,oCAAoC,OAAO;AAAA,IACjD;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,EAAE,YAAY,SAAS;AAAA,EACnC,MAKM;AACJ,UAAM,mBAAmB,oBAAoB;AAAA,MAAQ,CAAC,YACpD,2BAA2B,EAAE,GAAG,SAAS,QAAQ,CAAC;AAAA,IACpD;AAEA,UAAM,QAAQ;AAAA,MACZ,iBAAiB,IAAI,OAAO,aAAa;AACvC,cAAM,EAAE,IAAI,UAAU,IAAI,MAAM,GAC7B,WAAW,qBAAqB,EAChC,OAAO,QAAQ,EACf,WAAW,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,YAAY,QAAQ,CAAC,EACxD,aAAa,EACb,wBAAwB;AAE3B,cAAM,GACH,WAAW,6BAA6B,EACxC,OAAO;AAAA,UACN;AAAA,UACA,YAAY,aAAa,UAAU;AAAA,UACnC,UAAU,aAAa,QAAQ;AAAA,QACjC,CAAC,EACA,QAAQ;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA,EAIA,yBAAyB,OAAO;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAKM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,KAAK,GACR,WAAW,mBAAmB,EAC9B,OAAO;AAAA,QACN;AAAA,QACA,aAAa,aAAa,WAAW;AAAA,QACrC;AAAA,QACA;AAAA,MACF,CAAC,EACA,WAAW,CAAC,OAAO,GAAG,YAAY,EAAE,OAAO,CAAC,CAAC,EAC7C,QAAQ;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EAEA,sBAAsB,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAIM;AACJ,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,sBAAsB,GAAG,YAAY;AACjE,YAAM,mBAAmB,MAAM,KAAK,GACjC,WAAW,mBAAmB,EAC9B,UAAU,EACV,MAAM,eAAe,KAAK,aAAa,WAAW,CAAC,EACnD,MAAM,WAAW,KAAK,OAAO,EAC7B,MAAM,WAAW,KAAK,OAAO,EAC7B,iBAAiB;AAEpB,aAAO,mBACH;AAAA,QACE,GAAG;AAAA,QACH,aAAa,eAAe,iBAAiB,WAAW;AAAA,MAC1D,IACA;AAAA,IACN,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,UAAU;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,QAAI,SAAS,iBAAiB,cAAc;AAC5C,UAAM,sBAAsB,iBAAiB,YAAY;AAEzD,UAAM,cAAc,QAAQ,OAEzB,CAAC,KAAK,QAAQ;AACf,UAAI,IAAI,EAAE,IAAI;AACd,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAGL,UAAM,aAAa,QAAQ;AAAA,MACzB,CAAC,MACC,YAAY,CAAC,KAAK,mBAAmB,CAAC;AAAA,IAC1C;AACA,UAAM,mBAAmB,QAAQ;AAAA,MAC/B,CAAC,MACC,kBAAkB,CAAC,KAAK,yBAAyB,CAAC;AAAA,IACtD;AACA,UAAM,eAAe,QAAQ,OAAO,aAAa;AAEjD,UAAM,iBAAiB,WAAW,WAAW;AAC7C,UAAM,yBACJ,WAAW,WAAW,KAAK,iBAAiB,WAAW;AACzD,UAAM,mBAAmB,iBAAiB,WAAW;AACrD,UAAM,qBACJ,WAAW,KAAK,CAAC,WAAW,OAAO,SAAS,0BAA0B,KACtE,iBAAiB;AAAA,MACf,CAAC,WAAW,OAAO,SAAS;AAAA,IAC9B;AAEF,WAAO,MAAM;AACX,YAAM,SAAS,MAAM,KAAK,GAAG,KAAK,EAAE,QAAQ,YAAY,GAAG,YAAY;AAErE,cAAM,gBAAgB,MAAM,KAAK,GAC9B;AAAA,UACC;AAAA,UACA,MACEJ,gBACE,WAAW,WAAW,IAClBA,iBACAA,KAAI;AAAA,YACF,WAAW;AAAA,cACT,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UACC;AAAA,UACA,MACEA,gBACE,aAAa,WAAW,IACpBA,iBACAA,KAAI;AAAA,YACF,aAAa;AAAA,cACX,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UACC;AAAA,UACA,MACEA,gBACE,iBAAiB,WAAW,IACxBA,iBACAA,KAAI;AAAA,YACF,iBAAiB;AAAA,cACf,CAAC,WAAWA,SAAQA,KAAI,IAAI,OAAO,EAAE,CAAC;AAAA,YACxC;AAAA,UACF,CACN;AAAA,QACJ,EACC;AAAA,UAAK;AAAA,UAAU,CAAC,OACf,GACG,WAAW,MAAM,EACjB,UAAU,eAAe,CAAC,SAAS,KAAK,OAAO,CAAC,EAChD,MAAM,CAAC,OAAO;AACb,kBAAM,iBAAiB,QACpB,OAAO,WAAW,EAClB,IAAI,CAAC,cAAc;AAClB,oBAAM,QAAQ,KAAK,oBAAoB,EAAE,IAAI,UAAU,CAAC;AACxD,oBAAM,KAAK,GAAG,aAAa,KAAK,UAAU,EAAE,CAAC;AAC7C,qBAAO,GAAG,IAAI,KAAK;AAAA,YACrB,CAAC;AAEH,kBAAM,eAAe,QAClB,OAAO,kBAAkB,EACzB,IAAI,CAAC,YAAY;AAChB,oBAAM,QAAQ,KAAK,2BAA2B;AAAA,gBAC5C;AAAA,gBACA;AAAA,cACF,CAAC;AACD,oBAAM,KAAK,GAAG,aAAa,KAAK,QAAQ,EAAE,CAAC;AAC3C,qBAAO,GAAG,IAAI,KAAK;AAAA,YACrB,CAAC;AAEH,mBAAO,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,YAAY,CAAC;AAAA,UACnD,CAAC,EACA,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YAEA;AAAA,YACAA,WAAU,GAAG,cAAc;AAAA,UAC7B,CAAC,EACA;AAAA;AAAA,YAEC,GACG,WAAW,QAAQ,EACnB,UAAU,iBAAiB,CAAC,SAAS,KAAK,OAAO,CAAC,EAClD,MAAM,CAAC,OAAO;AACb,oBAAM,QAAQ,CAAC;AACf,oBAAM,eAAe,QAAQ,OAAO,aAAa;AACjD,yBAAW,eAAe,cAAc;AACtC,sBAAM;AAAA,kBACJ,GAAG,IAAI;AAAA,oBACL,GAAG,WAAW,KAAK,YAAY,OAAO;AAAA,oBACtC;AAAA,sBACE;AAAA,sBACA;AAAA,sBACA,aAAa,YAAY,UAAU;AAAA,oBACrC;AAAA,oBACA,GAAI,YAAY,aAAa,SACzB;AAAA,sBACE;AAAA,wBACE;AAAA,wBACA;AAAA,wBACA,aAAa,YAAY,QAAQ;AAAA,sBACnC;AAAA,oBACF,IACA,CAAC;AAAA,oBACLA,iBAAgB,YAAY,SAAS,MAAM,OAAO,YAAY,SAAS,QAAQ;AAAA,oBAC/E,GAAG,aAAa,KAAK,YAAY,EAAE;AAAA,kBACrC,CAAC;AAAA,gBACH;AAAA,cACF;AACA,qBAAO,GAAG,GAAG,KAAK;AAAA,YACpB,CAAC,EACA,OAAO;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACAA,WAAU,GAAG,iBAAiB;AAAA,cAE9BA,WAAU,GAAG,QAAQ;AAAA,cACrBA,WAAU,GAAG,cAAc;AAAA,YAC7B,CAAC;AAAA,UACL,EACC;AAAA;AAAA,YAEC,GACG,WAAW,YAAY,EACvB,UAAU,uBAAuB,CAAC,SAAS,KAAK,OAAO,CAAC,EACxD,MAAM,CAAC,OAAO;AACb,oBAAM,mBAAmB,QACtB,OAAO,iBAAiB,EACxB,IAAI,CAAC,oBAAoB;AACxB,sBAAM,QAAQ,KAAK,sBAAsB;AAAA,kBACvC;AAAA,kBACA;AAAA,gBACF,CAAC;AACD,sBAAM,KAAK,GAAG,aAAa,KAAK,gBAAgB,EAAE,CAAC;AACnD,uBAAO,GAAG,IAAI,KAAK;AAAA,cACrB,CAAC;AACH,oBAAM,0BAA0B,QAC7B,OAAO,wBAAwB,EAC/B,IAAI,CAAC,YAAY;AAChB,sBAAM,QAAQ,KAAK,6BAA6B;AAAA,kBAC9C;AAAA,kBACA;AAAA,gBACF,CAAC;AACD,sBAAM,KAAK,GAAG,aAAa,KAAK,QAAQ,EAAE,CAAC;AAC3C,uBAAO,GAAG,IAAI,KAAK;AAAA,cACrB,CAAC;AAEH,qBAAO,GAAG,GAAG;AAAA,gBACX,GAAG;AAAA,gBACH,GAAG;AAAA,cACL,CAAC;AAAA,YACH,CAAC,EACA,OAAO;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cAEAA,WAAU,GAAG,QAAQ;AAAA,cACrB;AAAA,YACF,CAAC;AAAA,UACL;AAAA,QACJ,EACC,WAAW,QAAQ,EACnB,UAAU,UAAU,eAAe,kBAAkB,EACrD,OAAO;AAAA,UACN;AAAA,UACA;AAAA,UAEA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC,EACA;AAAA,UAAI;AAAA,UAAgB,CAAC,OACpB,GACG,SAAS,QAAQ,WAAW,eAAe,EAC3C,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAwB,CAAC,OAC5B,GACG;AAAA,YACC;AAAA,YACA;AAAA,YACA;AAAA,UACF,EACC,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAkB,CAAC,OACtB,GACG,SAAS,cAAc,iBAAiB,qBAAqB,EAC7D,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC;AAAA,UAAI;AAAA,UAAoB,CAAC,OACxB,GACG;AAAA,YACC;AAAA,YACA;AAAA,YACA;AAAA,UACF,EACC,OAAO;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACL,EACC,MAAM,qBAAqB,KAAK,MAAM,EACtC,MAAM,qBAAqB,MAAM,mBAAmB,EACpD,QAAQ,qBAAqB,KAAK,EAClC,MAAM,QAAQ,CAAC,EACf,QAAQ;AAEX,eAAO,cAAc,IAAI,CAAC,SAAS;AAIjC,gBAAM,MAAM;AAEZ,gBAAM,SAAS,YAAY,IAAI,SAAS;AAExC,gBAAM,mBACJ,YAAY,MAAM,KAAK,mBAAmB,MAAM;AAClD,gBAAM,2BACJ,YAAY,MAAM,KAClB,mBAAmB,MAAM,KACzB,kBAAkB,MAAM,KACxB,yBAAyB,MAAM;AACjC,gBAAM,qBACJ,kBAAkB,MAAM,KAAK,yBAAyB,MAAM;AAC9D,gBAAM,kCACH,YAAY,MAAM,KACjB,OAAO,SAAS,8BACjB,mBAAmB,MAAM,KACxB,OAAO,SAAS;AACpB,iBAAO;AAAA,YACL,SAAS,OAAO;AAAA,YAChB,UAAU,IAAI;AAAA,YACd,mBAAmB,IAAI;AAAA,YACvB,KAAK,mBACD;AAAA,cACE,SAASK,iBAAgB,IAAI,WAAW;AAAA,cACxC,WAAW,IAAI;AAAA,cACf,aAAa,eAAe,IAAI,eAAe;AAAA,cAC/C,MAAM,IAAI;AAAA,cACV,IAAI,IAAI;AAAA,cACR,UAAU,OAAO,IAAI,YAAY;AAAA,cACjC,SAAS;AAAA,cACT,QAAQ;AAAA,gBACN,IAAI;AAAA,gBACJ,IAAI;AAAA,gBACJ,IAAI;AAAA,gBACJ,IAAI;AAAA,cACN,EAAE,OAAO,CAAC,MAAgB,MAAM,IAAI;AAAA,cACpC,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,OAAO,IAAI,oBAAoB;AAAA,YACnD,IACA;AAAA,YACJ,OAAO;AAAA,cACL,eAAe,IAAI,sBACf,eAAe,IAAI,mBAAmB,IACtC;AAAA,cACJ,YAAY,eAAe,IAAI,gBAAgB;AAAA,cAC/C,WAAW,IAAI;AAAA,cACf,UAAU,eAAe,IAAI,cAAc;AAAA,cAC3C,SAAS,eAAe,IAAI,aAAa;AAAA,cACzC,MAAM,IAAI;AAAA,cACV,WAAW,IAAI;AAAA,cACf,OAAOA,iBAAgB,IAAI,WAAW;AAAA,cACtC,SAAS,IAAI;AAAA,cACb,OAAO,IAAI;AAAA,cACX,QAAQ,eAAe,IAAI,YAAY;AAAA,cACvC,YAAY,IAAI;AAAA,cAChB,cAAc,IAAI;AAAA,cAClB,YAAY,IAAI;AAAA,cAChB,MAAM,eAAe,IAAI,UAAU;AAAA,cACnC,WAAW,IAAI;AAAA,cACf,WAAW,eAAe,IAAI,eAAe;AAAA,cAC7C,iBAAiB,IAAI,wBACjB,eAAe,IAAI,qBAAqB,IACxC;AAAA,cACJ,kBAAkB,IAAI;AAAA,YACxB;AAAA,YACA,aAAa,2BACT;AAAA,cACE,WAAW,IAAI;AAAA,cACf,aAAa,eAAe,IAAI,cAAc;AAAA,cAC9C,MAAMA,iBAAgB,IAAI,OAAO;AAAA,cACjC,KAAK,eAAe,IAAI,MAAM;AAAA,cAC9B,MAAM,IAAI;AAAA,cACV,OAAO,IAAI;AAAA,cACX,OAAO,OAAO,IAAI,QAAQ;AAAA,cAC1B,GAAG,IAAI;AAAA,cACP,GAAG,IAAI;AAAA,cACP,IAAI,IAAI,QAAQA,iBAAgB,IAAI,KAAK,IAAI,IAAI;AAAA,cACjD,kBAAkB,OAAO,IAAI,mBAAmB;AAAA,cAChD,OAAO,eAAe,IAAI,QAAQ;AAAA,cAClC,GAAG,IAAI,OAAO,eAAe,IAAI,IAAI,IAAI;AAAA,cACzC,GAAI,IAAI,YAAY,QAChB;AAAA,gBACE,MAAM;AAAA,gBACN,UAAU,eAAe,IAAI,WAAW;AAAA,cAC1C,IACA,IAAI,YAAY,QACd;AAAA,gBACE,MAAM;AAAA,gBACN,UAAU,eAAe,IAAI,WAAW;AAAA,gBACxC,YAAY,KAAK,MAAM,IAAI,aAAa;AAAA,cAC1C,IACA,IAAI,YAAY,QACd;AAAA,gBACE,MAAM;AAAA,gBACN,cAAc,eAAe,IAAI,eAAe;AAAA,gBAChD,sBAAsB;AAAA,kBACpB,IAAI;AAAA,gBACN;AAAA,cACF,IACA,IAAI,YAAY,SACd;AAAA,gBACE,MAAM;AAAA,gBACN,cAAc,IAAI,kBACd,eAAe,IAAI,eAAe,IAClC;AAAA,gBACJ,sBAAsB,IAAI,0BACtB,eAAe,IAAI,uBAAuB,IAC1C;AAAA,cACN,IACA;AAAA,gBACE,MAAM,IAAI;AAAA,cACZ;AAAA,YACZ,IACA;AAAA,YACJ,OAAO,qBACH;AAAA,cACE,IAAI,IAAI;AAAA,cACR,MAAMA,iBAAgB,IAAI,cAAc;AAAA,cACxC,IAAIA,iBAAgB,IAAI,YAAY;AAAA,cACpC,KAAK,eAAe,IAAI,aAAa;AAAA,cACrC,OAAO,eAAe,IAAI,eAAe;AAAA,cACzC,OAAO,IAAI;AAAA,cACX,QAAQ,IAAI;AAAA,cACZ,SAAS,eAAe,IAAI,iBAAiB;AAAA,cAC7C,WAAW,IAAI;AAAA,cACf,cAAc,KAAK,MAAM,IAAI,sBAAsB;AAAA,cACnD,WAAW,IAAI;AAAA,cACf,aAAa,eAAe,IAAI,qBAAqB;AAAA,cACrD,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,IAAI;AAAA,cACtB,UAAU,IAAI;AAAA,YAChB,IACA;AAAA,YACJ,oBAAoB,kCAChB;AAAA,cACE,WAAW,IAAI;AAAA,cACf,aAAa,eAAe,IAAI,eAAe;AAAA,cAC/C,iBAAiB,IAAI,sBACjBA,iBAAgB,IAAI,mBAAmB,IACvC;AAAA,cACJ,mBAAmB,eAAe,IAAI,qBAAqB;AAAA,cAC3D,mBAAmB,eAAe,IAAI,qBAAqB;AAAA,cAC3D,MAAMA,iBAAgB,IAAI,QAAQ;AAAA,cAClC,SAAS,eAAe,IAAI,WAAW;AAAA,cACvC,MAAM,KAAK,MAAM,IAAI,QAAQ,EAAE,IAAI,CAAC,SAAkB;AAAA,gBACpD,SAASA,iBAAgB,IAAI,OAAO;AAAA,gBACpC,WAAW,IAAI;AAAA,gBACf,aAAaD,aAAY,IAAI,WAAW;AAAA,gBACxC,MAAM,IAAI;AAAA,gBACV,UAAUD,aAAY,IAAI,QAAQ;AAAA,gBAClC,SAAS;AAAA,gBACT,QAAQ;AAAA,kBACN,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,kBACjB,IAAI,OAAO,CAAC,KAAK;AAAA,gBACnB,EAAE,OAAO,CAAC,MAAgB,MAAM,IAAI;AAAA,gBAGpC,iBAAiB,IAAI;AAAA,gBACrB,kBAAkBA,aAAY,IAAI,gBAAgB;AAAA,cACpD,EAAE;AAAA,cACF,WAAW,IAAI;AAAA,cACf,QACE,IAAI,eAAe,QACf,YACA,IAAI,eAAe,QACjB,aACC,IAAI;AAAA,cACb,IAAI,IAAI,SAASE,iBAAgB,IAAI,MAAM,IAAI;AAAA,cAC/C,iBAAiB,IAAI;AAAA,cACrB,kBAAkB,OAAO,IAAI,oBAAoB;AAAA,cACjD,MACE,IAAI,aAAa,QACb,WACA,IAAI,aAAa,QACf,YACA,IAAI,YAAY,QACd,YACA,IAAI,YAAY,SACd,YACA,IAAI;AAAA,YAClB,IACA;AAAA,UACN;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,YAAM,cAAc,OAAO,WAAW,QAAQ;AAE9C,UAAI,CAAC,aAAa;AAChB,cAAM;AACN;AAAA,MACF,OAAO;AACL,eAAO,IAAI;AACX,iBAAS,OAAO,OAAO,SAAS,CAAC,EAAE;AACnC,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIoC;AAClC,WAAO,KAAK,GAAG,KAAK,EAAE,QAAQ,yBAAyB,GAAG,YAAY;AACpE,YAAM,aAAa,MAAM,KAAK,GAC3B,WAAW,MAAM,EACjB,MAAM,CAAC,OAAO;AACb,cAAM,iBAAiB,QACpB,OAAO,WAAW,EAClB,IAAI,CAAC,cAAc;AAClB,gBAAM,QAAQ,KAAK,oBAAoB,EAAE,IAAI,UAAU,CAAC;AACxD,iBAAO,GAAG,IAAI,KAAK;AAAA,QACrB,CAAC;AAEH,cAAM,wBAAwB,QAC3B,OAAO,kBAAkB,EACzB,IAAI,CAAC,YAAY;AAChB,gBAAM,QAAQ,KAAK,2BAA2B,EAAE,IAAI,QAAQ,CAAC;AAC7D,iBAAO,GAAG,IAAI,KAAK;AAAA,QACrB,CAAC;AAEH,eAAO,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,qBAAqB,CAAC;AAAA,MAC5D,CAAC,EACA,OAAO,YAAY,EACnB;AAAA,QACC,KAAK,GACF,WAAW,QAAQ,EACnB,MAAM,CAAC,OAAO;AACb,gBAAM,QAAQ,CAAC;AACf,gBAAM,eAAe,QAAQ,OAAO,aAAa;AACjD,qBAAW,eAAe,cAAc;AACtC,kBAAM;AAAA,cACJ,GAAG,IAAI;AAAA,gBACL,GAAG,WAAW,KAAK,YAAY,OAAO;AAAA,gBACtC,GAAG,UAAU,MAAM,aAAa,YAAY,UAAU,CAAC;AAAA,gBACvD,GAAI,YAAY,aAAa,SACzB,CAAC,GAAG,UAAU,MAAM,aAAa,YAAY,QAAQ,CAAC,CAAC,IACvD,CAAC;AAAA,gBACLL,iBAAgB,YAAY,SAAS,MAAM,OAAO,YAAY,SAAS,QAAQ;AAAA,cACjF,CAAC;AAAA,YACH;AAAA,UACF;AACA,iBAAO,GAAG,GAAG,KAAK;AAAA,QACpB,CAAC,EACA,OAAO,YAAY;AAAA,MACxB,EACC;AAAA,QACC,KAAK,GACF,WAAW,YAAY,EACvB,MAAM,CAAC,OAAO;AACb,gBAAM,mBAAmB,QACtB,OAAO,iBAAiB,EACxB,IAAI,CAAC,oBAAoB;AACxB,kBAAM,QAAQ,KAAK,sBAAsB;AAAA,cACvC;AAAA,cACA;AAAA,YACF,CAAC;AACD,mBAAO,GAAG,IAAI,KAAK;AAAA,UACrB,CAAC;AAEH,gBAAM,wBAAwB,QAC3B,OAAO,wBAAwB,EAC/B,IAAI,CAAC,YAAY;AAChB,kBAAM,QAAQ,KAAK,6BAA6B;AAAA,cAC9C;AAAA,cACA;AAAA,YACF,CAAC;AACD,mBAAO,GAAG,IAAI,KAAK;AAAA,UACrB,CAAC;AAEH,iBAAO,GAAG,GAAG,CAAC,GAAG,kBAAkB,GAAG,qBAAqB,CAAC;AAAA,QAC9D,CAAC,EACA,OAAO,YAAY;AAAA,MACxB,EACC,MAAM,cAAc,KAAK,iBAAiB,cAAc,CAAC,EACzD,MAAM,cAAc,MAAM,iBAAiB,YAAY,CAAC,EACxD,QAAQ,cAAc,MAAM,EAC5B,iBAAiB;AAEpB,aAAO,aACH,WAAW,aACT,iBAAiB,WAAW,UAAU,IACtC,SACF;AAAA,IACN,CAAC;AAAA,EACH;AAAA,EAEQ,sBAAsB,CAAC;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM,KAAK,GAAG,gBAAgB,KAAK,UAAU,OAAO,CAAC;AAErD,QAAI,UAAU,SAAS,SAAS;AAE9B,YAAM,UACJ,MAAM,QAAQ,UAAU,SAAS,OAAO,KACxC,UAAU,SAAS,QAAQ,WAAW,IAClC,UAAU,SAAS,QAAQ,CAAC,IAC5B,UAAU,SAAS;AACzB,UAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,cAAM,KAAK,GAAG,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG,gBAAgB,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,MAClE,OAAO;AACL,cAAM,KAAK,GAAG,gBAAgB,KAAK,OAAO,CAAC;AAAA,MAC7C;AAAA,IACF;AAEA,QAAI,UAAU,SAAS,QAAQ;AAC7B,iBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,cAAM,MAAM;AAEZ,cAAM,MAAM,UAAU,SAAS,OAAO,GAAG,KAAK;AAC9C,YAAI,QAAQ;AAAM;AAClB,cAAM,QAAQ,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW,IAAI,IAAI,CAAC,IAAI;AAChE,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG,aAAa,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,QACpE,OAAO;AACL,gBAAM,KAAK,GAAG,aAAa,GAAG,IAAI,KAAK,KAAK,CAAC;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEA,QAAI,UAAU,eAAe,UAAa,UAAU,eAAe;AACjE,YAAM;AAAA,QACJ,GAAG,oBAAoB,MAAM,aAAa,UAAU,UAAU,CAAC;AAAA,MACjE;AACF,QAAI,UAAU;AACZ,YAAM;AAAA,QACJ,GAAG,oBAAoB,MAAM,aAAa,UAAU,QAAQ,CAAC;AAAA,MAC/D;AAEF,WAAO;AAAA,EACT;AAAA,EAEQ,6BAA6B,CAAC;AAAA,IACpC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM,KAAK,GAAG,gBAAgB,KAAK,QAAQ,OAAO,CAAC;AAEnD,UAAM,+BACJC,0CAAyC;AAAA,MACvC,sBAAsB,QAAQ,SAAS;AAAA,IACzC,CAAC;AAEH,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACA,GACG,WAAW,MAAM,EACjB,OAAO,6BAA6B,GAAG,cAAc,CAAC,EACtD,MAAM,WAAW,KAAK,QAAQ,OAAO,EACrC,MAAM,WAAW,KAAK,QAAQ,SAAS,OAAO,EAC9C,MAAM,UAAU,KAAK,QAAQ,SAAS,aAAa;AAAA,MACxD;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,QAAQ;AAC3B,iBAAW,QAAQ,MAAM,GAAG,CAAC,GAAG;AAC9B,cAAM,MAAM;AAEZ,cAAM,MAAM,QAAQ,SAAS,OAAO,GAAG,KAAK;AAC5C,YAAI,QAAQ;AAAM;AAClB,cAAM,QAAQ,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW,IAAI,IAAI,CAAC,IAAI;AAChE,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG,aAAa,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,QACpE,OAAO;AACL,gBAAM,KAAK,GAAG,aAAa,GAAG,IAAI,KAAK,KAAK,CAAC;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEA,QAAI,QAAQ,eAAe,UAAa,QAAQ,eAAe;AAC7D,YAAM;AAAA,QACJ,GAAG,oBAAoB,MAAM,aAAa,QAAQ,UAAU,CAAC;AAAA,MAC/D;AACF,QAAI,QAAQ;AACV,YAAM,KAAK,GAAG,oBAAoB,MAAM,aAAa,QAAQ,QAAQ,CAAC,CAAC;AAEzE,WAAO;AAAA,EACT;AAAA,EAEQ,wBAAwB,CAAC;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM,KAAK,GAAG,sBAAsB,KAAK,gBAAgB,OAAO,CAAC;AAEjE,QAAI,gBAAgB,SAAS,aAAa;AAExC,YAAM,cACJ,MAAM,QAAQ,gBAAgB,SAAS,WAAW,KAClD,gBAAgB,SAAS,YAAY,WAAW,IAC5C,gBAAgB,SAAS,YAAY,CAAC,IACtC,gBAAgB,SAAS;AAC/B,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM;AAAA,UACJ,GAAG,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG,mBAAmB,KAAK,CAAC,CAAC,CAAC;AAAA,QAC7D;AAAA,MACF,OAAO;AACL,cAAM,KAAK,GAAG,mBAAmB,KAAK,WAAW,CAAC;AAAA,MACpD;AAAA,IACF;AAEA,QAAI,gBAAgB,SAAS,WAAW;AAEtC,YAAM,YACJ,MAAM,QAAQ,gBAAgB,SAAS,SAAS,KAChD,gBAAgB,SAAS,UAAU,WAAW,IAC1C,gBAAgB,SAAS,UAAU,CAAC,IACpC,gBAAgB,SAAS;AAC/B,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC5B,cAAM,KAAK,GAAG,GAAG,UAAU,IAAI,CAAC,MAAM,GAAG,iBAAiB,KAAK,CAAC,CAAC,CAAC,CAAC;AAAA,MACrE,OAAO;AACL,cAAM,KAAK,GAAG,iBAAiB,KAAK,SAAS,CAAC;AAAA,MAChD;AAAA,IACF;AAGA,UAAM;AAAA,MACJ,GAAG;AAAA,QACD,gBAAgB,SAAS,kBAAkB;AAAA,UAAI,CAAC,OAC9C,GAAG,+BAA+B,KAAK,EAAE;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAGA,UAAM;AAAA,MACJD,OAAMA,KAAI,IAAI,kBAAkB,CAAC;AAAA,IACnC;AAEA,QACE,gBAAgB,eAAe,UAC/B,gBAAgB,eAAe;AAE/B,YAAM;AAAA,QACJ;AAAA,UACE;AAAA,UACA;AAAA,UACA,aAAa,gBAAgB,UAAU;AAAA,QACzC;AAAA,MACF;AACF,QAAI,gBAAgB;AAClB,YAAM;AAAA,QACJ;AAAA,UACE;AAAA,UACA;AAAA,UACA,aAAa,gBAAgB,QAAQ;AAAA,QACvC;AAAA,MACF;AAEF,WAAO;AAAA,EACT;AAAA,EAEQ,+BAA+B,CAAC;AAAA,IACtC;AAAA,IACA;AAAA,EACF,MAGM;AACJ,UAAM,QAAQ,CAAC;AAEf,UAAM,KAAK,GAAG,sBAAsB,KAAK,QAAQ,OAAO,CAAC;AAEzD,UAAM,+BACJC,0CAAyC;AAAA,MACvC,sBAAsB,QAAQ,SAAS;AAAA,IACzC,CAAC;AAEH,UAAM;AAAA,MACJ;AAAA,QACE;AAAA,QACA;AAAA,QACA,GACG,WAAW,MAAM,EACjB,OAAO,6BAA6B,GAAG,cAAc,CAAC,EACtD,MAAM,WAAW,KAAK,QAAQ,OAAO,EACrC,MAAM,WAAW,KAAK,QAAQ,SAAS,OAAO,EAC9C,MAAM,UAAU,KAAK,QAAQ,SAAS,aAAa;AAAA,MACxD;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,aAAa;AAEhC,YAAM,cACJ,MAAM,QAAQ,QAAQ,SAAS,WAAW,KAC1C,QAAQ,SAAS,YAAY,WAAW,IACpC,QAAQ,SAAS,YAAY,CAAC,IAC9B,QAAQ,SAAS;AACvB,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM;AAAA,UACJ,GAAG,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG,mBAAmB,KAAK,CAAC,CAAC,CAAC;AAAA,QAC7D;AAAA,MACF,OAAO;AACL,cAAM,KAAK,GAAG,mBAAmB,KAAK,WAAW,CAAC;AAAA,MACpD;AAAA,IACF;AAGA,UAAM;AAAA,MACJ,GAAG;AAAA,QACD,QAAQ,SAAS,kBAAkB;AAAA,UAAI,CAAC,OACtC,GAAG,+BAA+B,KAAK,EAAE;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAGA,UAAM;AAAA,MACJD,OAAMA,KAAI,IAAI,kBAAkB,CAAC;AAAA,IACnC;AAEA,QAAI,QAAQ,eAAe,UAAa,QAAQ,eAAe;AAC7D,YAAM;AAAA,QACJ,GAAG,0BAA0B,MAAM,aAAa,QAAQ,UAAU,CAAC;AAAA,MACrE;AACF,QAAI,QAAQ;AACV,YAAM;AAAA,QACJ,GAAG,0BAA0B,MAAM,aAAa,QAAQ,QAAQ,CAAC;AAAA,MACnE;AAEF,WAAO;AAAA,EACT;AACF;AAEA,SAASC,0CAAyC;AAAA,EAChD;AACF,GAEG;AACD,MAAI,qBAAqB,WAAW,QAAQ,GAAG;AAC7C,UAAM,qBAAqB,OAAO,qBAAqB,UAAU,CAAC,CAAC;AACnE,UAAMK,SAAQ,IAAI,KAAK,IAAI,qBAAqB,IAAI;AACpD,UAAM,SAAS,KAAK;AACpB,WAAON,+BAAmCM,MAAK,KAAK,MAAM;AAAA,EAC5D,OAAO;AACL,UAAMA,SAAQ,IAAI,KAAK,IAAI;AAC3B,UAAM,SAAS,KAAK;AACpB,WAAON,yBAA6BA,KAAI;AAAA,MACtC;AAAA,IACF,CAAC,KAAKM,MAAK,KAAK,MAAM;AAAA,EACxB;AACF;;;AE5+EA;AAAA,EAEE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAsDA,IAAM,eAAe,CAC1B,EAAE,QAAQ,WAAW,GACrB,cACY;AACZ,QAAM,SAAkB,CAAC;AAEzB,aAAW,SAAS,WAAW;AAC7B,UAAM,SAAS,WAAW,MAAM,QAAQ;AAExC,YAAQ,OAAO,MAAM;AAAA,MACnB,KAAK,SAAS;AACZ,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,SAAS,MAAM;AAAA,UACf,YAAY,OAAO;AAAA,UACnB,OAAO;AAAA,YACL,OAAO,MAAM;AAAA,UACf;AAAA,UACA,mBAAmB,MAAM;AAAA,QAC3B,CAAC;AACD;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK,oBAAoB;AACvB,YAAI;AACF,gBAAM,MAAM,OAAO;AAEnB,gBAAM,OAAO,mBAAmB;AAAA,YAC9B;AAAA,YACA,MAAM,MAAM,MAAO;AAAA,UACrB,CAAC;AAED,gBAAM,SAAS,qBAAqB;AAAA,YAClC;AAAA,YACA,MAAM,MAAM,MAAO;AAAA,YACnB,cAAc,KAAK;AAAA,UACrB,CAAC;AAED,gBAAM,WAAW,MAAM,MAAO,MAAM,MAAM,GAAG,EAAE;AAE/C,cAAI,OAAO,aAAa,WAAW,QAAQ,MAAM,QAAW;AAC1D,kBAAM,IAAI,MAAM;AAAA,UAClB;AAEA,gBAAM,eACJ,OAAO,aAAa,WAAW,QAAQ,EAAG;AAE5C,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,MAAM;AAAA,YACf,cAAc,OAAO;AAAA,YACrB;AAAA,YACA,OAAO;AAAA,cACL,MAAM,KAAK;AAAA,cACX;AAAA,cACA,OAAO,MAAM;AAAA,cACb,OAAO,MAAM;AAAA,cACb,aAAa,MAAM;AAAA,cACnB,oBAAoB,MAAM;AAAA,YAC5B;AAAA,YACA,mBAAmB,MAAM;AAAA,UAC3B,CAAC;AAAA,QACH,SAAS,KAAK;AACZ,iBAAO,OAAO,MAAM;AAAA,YAClB,SAAS;AAAA,YACT,KAAK,4CAA4C,MAAM,OAAO,EAAE,YAAY,MAAM,OAAO,KAAK,aAAa,MAAM,OAAO,MAAM;AAAA,UAChI,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK,cAAc;AACjB,YAAI;AACF,gBAAM,MAAM,OAAO;AAEnB,gBAAM,aAAa,eAAe;AAAA,YAChC;AAAA,YACA,MAAM,MAAM,IAAK;AAAA,YACjB,QAAQ,MAAM,IAAK;AAAA,UACrB,CAAC;AAED,cACE,MAAM,IAAK,OAAO,CAAC,MAAM,UACzB,OAAO,UAAU,WAAW,MAAM,IAAK,OAAO,CAAC,CAAC,MAAM,QACtD;AACA,kBAAM,IAAI,MAAM;AAAA,UAClB;AAEA,gBAAM,eACJ,OAAO,UAAU,WAAW,MAAM,IAAK,OAAO,CAAC,CAAC,EAAG;AAErD,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,MAAM;AAAA,YACf,cAAc,OAAO;AAAA,YACrB;AAAA,YACA,OAAO;AAAA,cACL,MAAM,WAAW;AAAA,cACjB,KAAK,MAAM;AAAA,cACX,OAAO,MAAM;AAAA,cACb,aAAa,MAAM;AAAA,cACnB,oBAAoB,MAAM;AAAA,YAC5B;AAAA,YACA,mBAAmB,MAAM;AAAA,UAC3B,CAAC;AAAA,QACH,SAAS,KAAK;AAEZ,iBAAO,OAAO,MAAM;AAAA,YAClB,SAAS;AAAA,YACT,KAAK,0CAA0C,MAAM,KAAK,EAAE,WAAW,MAAM,KAAK,IAAI,aAAa,MAAM,KAAK,MAAM;AAAA,UACtH,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAAA,MAEA;AACE,cAAM,MAAM;AAAA,IAChB;AAAA,EACF;AAEA,SAAO;AACT;;;AC1LA;AAAA,EAEE,sBAAAC;AAAA,EAQA;AAAA,EACA,eAAAC;AAAA,OACK;;;ACfP,OAAO,YAAY;AA8BZ,SAASC,aAAmC;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKiB;AACf,QAAM,QAAQ,IAAI,OAAO,OAAO;AAEhC,MAAI,QAAQ;AACV,UAAM,GAAG,QAAQ,MAAM,OAAO,CAAC;AAAA,EACjC;AAEA,QAAM,UAAU,OAAO,MAAM,gBAAgB;AAC3C,UAAM,WAAW,aAAa,YAAY;AAE1C,QAAI;AACF,YAAM,MAAM;AAAA,QACV,MAAM;AACJ,iBAAO,OAAO;AAAA,YACZ;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QACA;AAAA,UACE;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,QAAa;AACpB,YAAM,UAAU,EAAE,OAAO,QAAiB,MAAM,MAAM,CAAC;AAAA,IACzD;AAAA,EACF;AAEA,SAAO;AACT;;;ACrCA,OAAO,cAAc;AACrB;AAAA,EAIE,eAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACzCA,SAAS,6BAA6B;AAAA,EAC3C;AAAA,EACA,UAAU;AAAA,EACV;AAAA,EACA;AACF,GAKG;AACD,MAAI,aAAa,mBAAmB;AAClC,UAAM,IAAI;AAAA,MACR,uBAAuB,UAAU,iDAAiD,iBAAiB;AAAA;AAAA,IAErG;AAAA,EACF;AAEA,MAAI,aAAa,sBAAsB;AAGrC,WAAO;AAAA,MACL,0BAA0B;AAAA,MAC1B;AAAA,MACA,UAAU;AAAA,IACZ;AAAA,EACF;AAEA,MAAI,qBAAqB;AACvB,QAAI,sBAAsB,YAAY;AACpC,YAAM,IAAI;AAAA,QACR,qBAAqB,mBAAmB,6CAA6C,UAAU;AAAA;AAAA,MAEjG;AAAA,IACF;AAEA,QAAI,sBAAsB,mBAAmB;AAC3C,YAAM,IAAI;AAAA,QACR,qBAAqB,mBAAmB,iDAAiD,iBAAiB;AAAA;AAAA,MAE5G;AAAA,IACF;AAEA,QAAI,sBAAsB,sBAAsB;AAC9C,YAAM,IAAI;AAAA,QACR,qBAAqB,mBAAmB,oDAAoD,oBAAoB;AAAA;AAAA,MAElH;AAAA,IACF;AAAA,EACF;AAEA,QAAM,mBAAmB,uBAAuB;AAEhD,SAAO;AAAA,IACL,0BAA0B;AAAA,IAC1B;AAAA,IACA,UAAU;AAAA,EACZ;AACF;;;ADdA,IAAM,sCAAsC;AAC5C,IAAM,0BAA0B;AA0EzB,IAAM,wBAAN,cAAoC,SAA+B;AAAA,EAChE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAKA,4BAA6D,CAAC;AAAA,EAC9D,sCACN,CAAC;AAAA,EACK,mCACN,CAAC;AAAA,EACK,8BAA+D,CAAC;AAAA,EAChE,qCACN,CAAC;AAAA,EACK,8BAA+D,CAAC;AAAA,EAEhE,uBACN,IAAI,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnB,iBAGJ,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMG,+BAA+B;AAAA,EAE/B;AAAA;AAAA,EAGA,iBAAiB;AAAA,EACjB;AAAA,EAER,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,CAAC;AAAA,EACb,GAMG;AACD,UAAM;AAEN,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,UAAU;AAEf,SAAK,QAAQ,KAAK,WAAW;AAAA,EAC/B;AAAA,EAEA,MAAM,MAAM;AAAA,IACV;AAAA,IACA;AAAA,EACF,GAGG;AAED,SAAK,iBAAiB;AACtB,SAAK,+BAA+B;AAEpC,UAAM,QAAQ;AAAA,MACZ,KAAK,QAAQ,IAAI,OAAO,WAAW;AACjC,cAAM,EAAE,0BAA0B,YAAY,SAAS,IACrD,6BAA6B;AAAA,UAC3B,YAAY,OAAO;AAAA,UACnB,UAAU,OAAO;AAAA,UACjB;AAAA,UACA;AAAA,QACF,CAAC;AAEH,gBAAQ,OAAO,MAAM;AAAA,UACnB,KAAK;AAAO;AACV,kBAAI,CAAC,0BAA0B;AAC7B,qBAAK,0BAA0B,OAAO,EAAE,IAAI,IAAI,gBAAgB;AAAA,kBAC9D,QAAQ,CAAC,YAAY,oBAAoB;AAAA,kBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,gBAChD,CAAC;AACD,qBAAK,OAAO,QAAQ,+BAA+B;AAAA,kBACjD;AAAA,oBACE,SAAS,KAAK,QAAQ;AAAA,oBACtB,QAAQ,OAAO;AAAA,oBACf,MAAM;AAAA,kBACR;AAAA,kBACA;AAAA,gBACF;AACA,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,eAAe,OAAO,YAAY;AAAA,gBAC9E,CAAC;AACD;AAAA,cACF;AAEA,oBAAM,8BACJ,MAAM,KAAK,UAAU,sBAAsB;AAAA,gBACzC,SAAS,OAAO;AAAA,gBAChB,WAAW,OAAO;AAAA,cACpB,CAAC;AACH,oBAAM,2BAA2B,IAAI,gBAAgB;AAAA,gBACnD,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,0BAA0B,OAAO,EAAE,IACtC;AAEF,oBAAM,6BACJ,yBAAyB,YAAY;AAEvC,oBAAM,sBAAsB,UAAU;AAAA,gBACpC,WAAW;AAAA,gBACX,cACE,OAAO,iBAAiB,KAAK,QAAQ;AAAA,cACzC,CAAC;AAED,yBAAW,CAAC,WAAW,OAAO,KAAK,qBAAqB;AACtD,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,WAAW;AAAA,oBACX;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,oBAAoB,SAAS,GAAG;AAClC,sBAAM,QAAQ,YAAY,0BAA0B;AACpD,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,2BAA2B,OAAO,YAAY,YAAY,KAAK;AAAA,gBACjG,CAAC;AAAA,cACH;AAEA,oBAAM,mBAAmB,WAAW,aAAa;AACjD,oBAAM,mBACJ,mBAAmB,YAAY,0BAA0B;AAE3D,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,eACxC,OAAO,YACT,UAAU;AAAA,kBACR,KAAK,IAAI,GAAG,oBAAoB,oBAAoB,EAAE;AAAA,gBACxD,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AACA;AAAA,UAEA,KAAK;AAAc;AACjB,kBAAI,CAAC,0BAA0B;AAC7B,qBAAK,oCAAoC,OAAO,EAAE,IAChD,IAAI,gBAAgB;AAAA,kBAClB,QAAQ,CAAC,YAAY,oBAAoB;AAAA,kBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,gBAChD,CAAC;AACH,qBAAK,iCAAiC,OAAO,EAAE,IAC7C,IAAI,gBAAgB;AAAA,kBAClB,QAAQ,CAAC,YAAY,oBAAoB;AAAA,kBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,gBAChD,CAAC;AACH,qBAAK,OAAO,QAAQ,+BAA+B;AAAA,kBACjD;AAAA,oBACE,SAAS,KAAK,QAAQ;AAAA,oBACtB,QAAQ,OAAO;AAAA,oBACf,MAAM;AAAA,kBACR;AAAA,kBACA;AAAA,gBACF;AACA,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,eAAe,OAAO,YAAY;AAAA,gBAC9E,CAAC;AACD;AAAA,cACF;AAIA,oBAAM,wCACJ,MAAM,KAAK,UAAU,sBAAsB;AAAA,gBACzC,SAAS,OAAO;AAAA,gBAChB,WAAW;AAAA,kBACT,SAAS,OAAO,SAAS;AAAA,kBACzB,QAAQ,CAAC,OAAO,SAAS,aAAa;AAAA,kBACtC,4BAA4B;AAAA,gBAC9B;AAAA,cACF,CAAC;AACH,oBAAM,qCAAqC,IAAI,gBAAgB;AAAA,gBAC7D,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,oCAAoC,OAAO,EAAE,IAChD;AAEF,oBAAM,uCACJ,mCAAmC,YAAY;AACjD,oBAAM,gCAAgC,UAAU;AAAA,gBAC9C,WAAW;AAAA,gBACX,cACE,OAAO,iBAAiB,KAAK,QAAQ;AAAA,cACzC,CAAC;AAED,yBAAW,CAAC,WAAW,OAAO,KAAK,+BAA+B;AAChE,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,SAAS;AAAA,oBACT;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,8BAA8B,SAAS,GAAG;AAC5C,sBAAM,QAAQ,YAAY,oCAAoC;AAC9D,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,sCAAsC,OAAO,YAAY,YAAY,KAAK;AAAA,gBAC5G,CAAC;AAAA,cACH;AAEA,oBAAM,sCACJ,WAAW,aAAa;AAC1B,oBAAM,sCACJ,sCACA,YAAY,oCAAoC;AAElD,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,GAAG,OAAO,YAAY;AAAA,kBAC9B,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,GAAG,OAAO,YAAY;AAAA,kBAC9B,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAEA,oBAAM,qCACJ,MAAM,KAAK,UAAU,6BAA6B;AAAA,gBAChD,SAAS,OAAO;AAAA,gBAChB,SAAS,OAAO;AAAA,cAClB,CAAC;AACH,oBAAM,kCAAkC,IAAI,gBAAgB;AAAA,gBAC1D,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,iCAAiC,OAAO,EAAE,IAC7C;AAKF,oBAAM,oCACJ,gCAAgC,YAAY;AAC9C,oBAAM,mCAAmC;AAAA,gBACvC;AAAA,gBACA;AAAA,cACF;AAEA,oBAAM,oCAAoC,UAAU;AAAA,gBAClD,WAAW;AAAA,gBACX,cACE,OAAO,iBAAiB,KAAK,QAAQ;AAAA,cACzC,CAAC;AAED,yBAAW;AAAA,gBACT;AAAA,gBACA;AAAA,cACF,KAAK,mCAAmC;AACtC,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,kBAAkB;AAAA,oBAClB;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,kCAAkC,SAAS,GAAG;AAChD,sBAAM,QAAQ,YAAY,gCAAgC;AAC1D,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,mCAAmC,OAAO,YAAY,YAAY,KAAK;AAAA,gBACzG,CAAC;AAAA,cACH;AAEA,oBAAM,mCAAmC,WAAW,aAAa;AACjE,oBAAM,mCACJ,mCACA,YAAY,iCAAiC;AAE/C,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAIA,oBAAM,YAAY,KAAK;AAAA,gBACrB;AAAA,gBACA,oCACG,oCAAoC;AAAA,cACzC;AACA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,eACxC,OAAO,YACT,UAAU,iBAAiB,SAAS,CAAC;AAAA,cACvC,CAAC;AAAA,YACH;AACA;AAAA,UAEA,KAAK;AAAa;AAChB,kBAAI,CAAC,0BAA0B;AAC7B,qBAAK,4BAA4B,OAAO,EAAE,IAAI,IAAI;AAAA,kBAChD;AAAA,oBACE,QAAQ,CAAC,YAAY,oBAAoB;AAAA,oBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,kBAChD;AAAA,gBACF;AACA,qBAAK,OAAO,QAAQ,+BAA+B;AAAA,kBACjD;AAAA,oBACE,SAAS,KAAK,QAAQ;AAAA,oBACtB,QAAQ,OAAO;AAAA,oBACf,MAAM;AAAA,kBACR;AAAA,kBACA;AAAA,gBACF;AACA,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,sBAAsB,OAAO,YAAY;AAAA,gBACrF,CAAC;AACD;AAAA,cACF;AAEA,oBAAM,gCACJ,MAAM,KAAK,UAAU,wBAAwB;AAAA,gBAC3C,SAAS,OAAO;AAAA,gBAChB,aAAa,OAAO;AAAA,cACtB,CAAC;AACH,oBAAM,6BAA6B,IAAI,gBAAgB;AAAA,gBACrD,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,4BAA4B,OAAO,EAAE,IACxC;AAEF,oBAAM,+BACJ,2BAA2B,YAAY;AAEzC,oBAAM,wBAAwB,UAAU;AAAA,gBACtC,WAAW;AAAA,gBACX,cAAc;AAAA,cAChB,CAAC;AAED,yBAAW,CAAC,WAAW,OAAO,KAAK,uBAAuB;AACxD,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,aAAa;AAAA,oBACb;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,sBAAsB,SAAS,GAAG;AACpC,sBAAM,QAAQ,YAAY,4BAA4B;AACtD,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,6BAA6B,OAAO,YAAY,YAAY,KAAK;AAAA,gBACnG,CAAC;AAAA,cACH;AAEA,oBAAM,mBAAmB,WAAW,aAAa;AACjD,oBAAM,mBACJ,mBAAmB,YAAY,4BAA4B;AAE7D,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,sBACxC,OAAO,YACT,UAAU;AAAA,kBACR,KAAK,IAAI,GAAG,oBAAoB,oBAAoB,EAAE;AAAA,gBACxD,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AACA;AAAA,UAEA,KAAK;AAAoB;AACvB,kBAAI,CAAC,0BAA0B;AAC7B,qBAAK,oCAAoC,OAAO,EAAE,IAChD,IAAI,gBAAgB;AAAA,kBAClB,QAAQ,CAAC,YAAY,oBAAoB;AAAA,kBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,gBAChD,CAAC;AACH,qBAAK,mCAAmC,OAAO,EAAE,IAC/C,IAAI,gBAAgB;AAAA,kBAClB,QAAQ,CAAC,YAAY,oBAAoB;AAAA,kBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,gBAChD,CAAC;AACH,qBAAK,OAAO,QAAQ,+BAA+B;AAAA,kBACjD;AAAA,oBACE,SAAS,KAAK,QAAQ;AAAA,oBACtB,QAAQ,OAAO;AAAA,oBACf,MAAM;AAAA,kBACR;AAAA,kBACA;AAAA,gBACF;AACA,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,sBAAsB,OAAO,YAAY;AAAA,gBACrF,CAAC;AACD;AAAA,cACF;AAIA,oBAAM,wCACJ,MAAM,KAAK,UAAU,sBAAsB;AAAA,gBACzC,SAAS,OAAO;AAAA,gBAChB,WAAW;AAAA,kBACT,SAAS,OAAO,SAAS;AAAA,kBACzB,QAAQ,CAAC,OAAO,SAAS,aAAa;AAAA,kBACtC,4BAA4B;AAAA,gBAC9B;AAAA,cACF,CAAC;AACH,oBAAM,qCAAqC,IAAI,gBAAgB;AAAA,gBAC7D,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,oCAAoC,OAAO,EAAE,IAChD;AAEF,oBAAM,uCACJ,mCAAmC,YAAY;AACjD,oBAAM,gCAAgC,UAAU;AAAA,gBAC9C,WAAW;AAAA,gBACX,cACE,OAAO,iBAAiB,KAAK,QAAQ;AAAA,cACzC,CAAC;AAED,yBAAW,CAAC,WAAW,OAAO,KAAK,+BAA+B;AAChE,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,SAAS;AAAA,oBACT;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,8BAA8B,SAAS,GAAG;AAC5C,sBAAM,QAAQ,YAAY,oCAAoC;AAC9D,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,sCAAsC,OAAO,YAAY,YAAY,KAAK;AAAA,gBAC5G,CAAC;AAAA,cACH;AAEA,oBAAM,sCACJ,WAAW,aAAa;AAC1B,oBAAM,sCACJ,sCACA,YAAY,oCAAoC;AAElD,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,GAAG,OAAO,YAAY;AAAA,kBAC9B,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,GAAG,OAAO,YAAY;AAAA,kBAC9B,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAEA,oBAAM,uCACJ,MAAM,KAAK,UAAU,+BAA+B;AAAA,gBAClD,SAAS,OAAO;AAAA,gBAChB,SAAS,OAAO;AAAA,cAClB,CAAC;AACH,oBAAM,oCAAoC,IAAI,gBAAgB;AAAA,gBAC5D,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,mCAAmC,OAAO,EAAE,IAC/C;AAKF,oBAAM,sCACJ,kCAAkC,YAAY;AAChD,oBAAM,qCAAqC;AAAA,gBACzC;AAAA,gBACA;AAAA,cACF;AAEA,oBAAM,sCAAsC,UAAU;AAAA,gBACpD,WAAW;AAAA,gBACX,cAAc;AAAA,cAChB,CAAC;AAED,yBAAW;AAAA,gBACT;AAAA,gBACA;AAAA,cACF,KAAK,qCAAqC;AACxC,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,oBAAoB;AAAA,oBACpB;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,oCAAoC,SAAS,GAAG;AAClD,sBAAM,QAAQ,YAAY,kCAAkC;AAC5D,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,qCAAqC,OAAO,YAAY,YAAY,KAAK;AAAA,gBAC3G,CAAC;AAAA,cACH;AAEA,oBAAM,qCACJ,WAAW,aAAa;AAC1B,oBAAM,qCACJ,qCACA,YAAY,mCAAmC;AAEjD,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAIA,oBAAM,YAAY,KAAK;AAAA,gBACrB;AAAA,gBACA,sCACG,sCAAsC;AAAA,cAC3C;AACA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,sBACxC,OAAO,YACT,UAAU,iBAAiB,SAAS,CAAC;AAAA,cACvC,CAAC;AAAA,YACH;AACA;AAAA,UAEA,KAAK;AAAS;AACZ,kBAAI,CAAC,0BAA0B;AAC7B,qBAAK,4BAA4B,OAAO,EAAE,IAAI,IAAI;AAAA,kBAChD;AAAA,oBACE,QAAQ,CAAC,YAAY,oBAAoB;AAAA,oBACzC,WAAW,CAAC,CAAC,YAAY,oBAAoB,CAAC;AAAA,kBAChD;AAAA,gBACF;AACA,qBAAK,OAAO,QAAQ,+BAA+B;AAAA,kBACjD;AAAA,oBACE,SAAS,KAAK,QAAQ;AAAA,oBACtB,QAAQ,OAAO;AAAA,oBACf,MAAM;AAAA,kBACR;AAAA,kBACA;AAAA,gBACF;AACA,qBAAK,OAAO,OAAO,KAAK;AAAA,kBACtB,SAAS;AAAA,kBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,iBAAiB,OAAO,UAAU;AAAA,gBAC9E,CAAC;AACD;AAAA,cACF;AAEA,oBAAM,gCACJ,MAAM,KAAK,UAAU,wBAAwB;AAAA,gBAC3C,SAAS,OAAO;AAAA,gBAChB,aAAa,OAAO;AAAA,cACtB,CAAC;AACH,oBAAM,6BAA6B,IAAI,gBAAgB;AAAA,gBACrD,QAAQ,CAAC,YAAY,QAAQ;AAAA,gBAC7B,WAAW;AAAA,cACb,CAAC;AACD,mBAAK,4BAA4B,OAAO,EAAE,IACxC;AAEF,oBAAM,+BACJ,2BAA2B,YAAY;AAKzC,oBAAM,wBAAwB,UAAU;AAAA,gBACtC,WAAW;AAAA,gBACX,cAAc,KAAK,QAAQ;AAAA,cAC7B,CAAC;AAED,yBAAW,CAAC,WAAW,OAAO,KAAK,uBAAuB;AACxD,qBAAK,MAAM;AAAA,kBACT;AAAA,oBACE,MAAM;AAAA,oBACN,aAAa;AAAA,oBACb;AAAA,oBACA;AAAA,kBACF;AAAA,kBACA,EAAE,UAAU,OAAO,mBAAmB,UAAU;AAAA,gBAClD;AAAA,cACF;AACA,kBAAI,sBAAsB,SAAS,GAAG;AACpC,sBAAM,QAAQ,YAAY,4BAA4B;AACtD,qBAAK,OAAO,OAAO,MAAM;AAAA,kBACvB,SAAS;AAAA,kBACT,KAAK,UAAU,KAAK,QAAQ,IAAI,6BAA6B,OAAO,UAAU,YAAY,KAAK;AAAA,gBACjG,CAAC;AAAA,cACH;AAEA,oBAAM,mBAAmB,WAAW,aAAa;AACjD,oBAAM,mBACJ,mBAAmB,YAAY,4BAA4B;AAE7D,mBAAK,OAAO,QAAQ,+BAA+B;AAAA,gBACjD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AACA,mBAAK,OAAO,QAAQ,gCAAgC;AAAA,gBAClD;AAAA,kBACE,SAAS,KAAK,QAAQ;AAAA,kBACtB,QAAQ,OAAO;AAAA,kBACf,MAAM;AAAA,gBACR;AAAA,gBACA;AAAA,cACF;AAEA,mBAAK,OAAO,OAAO,KAAK;AAAA,gBACtB,SAAS;AAAA,gBACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI,iBACxC,OAAO,UACT,UAAU;AAAA,kBACR,KAAK,IAAI,GAAG,oBAAoB,oBAAoB,EAAE;AAAA,gBACxD,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AACA;AAAA,UAEA;AACE,kBAAM,MAAM;AAAA,QAChB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,QAAQ;AACN,SAAK,OAAO,QAAQ,kCAAkC,IAAI,KAAK,IAAI,CAAC;AAGpE,SAAK,sBAAsB,YAAY,YAAY;AACjD,YAAM,aAAa,MAAM,0BAA0B,KAAK,OAAO,OAAO;AAEtE,iBAAW,QAAQ;AAAA,QACjB,CAAC,EAAE,aAAa,YAAY,UAAU,IAAI,MAAM;AAC9C,cAAI,aAAa,KAAK,gBAAgB,KAAK,QAAQ;AAAM;AACzD,eAAK,OAAO,OAAO,KAAK;AAAA,YACtB,SAAS;AAAA,YACT,KAAK,YACH,KAAK,QAAQ,IACf,UAAU,UAAU,UAAU;AAAA,cAC5B,YAAY;AAAA,YACd,CAAC,YACC,QAAQ,SAAY,SAAS,UAAU,GAAG,CAAC,eAAe,EAC5D;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,GAAG,GAAM;AAIT,QAAI,KAAK,MAAM,SAAS,GAAG;AACzB,oBAAc,KAAK,mBAAmB;AACtC,WAAK,OAAO,OAAO,KAAK;AAAA,QACtB,SAAS;AAAA,QACT,KAAK,aAAa,KAAK,QAAQ,IAAI;AAAA,MACrC,CAAC;AACD,WAAK,KAAK,cAAc;AAAA,IAC1B;AAEA,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA,EAEA,OAAO,MAAM;AACX,SAAK,iBAAiB;AACtB,kBAAc,KAAK,mBAAmB;AACtC,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,WAAW,KAAK,QAAQ,IAAI;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EAEA,SAAS,MACP,IAAI;AAAA,IAAQ,CAACC,aACX,aAAa,MAAM,KAAK,MAAM,OAAO,EAAE,KAAKA,QAAO,CAAC;AAAA,EACtD;AAAA,EAEM,aAAa,MAAM;AACzB,UAAM,SAAqC,OAAO,EAAE,MAAM,OAAAC,OAAM,MAAM;AACpE,cAAQ,KAAK,MAAM;AAAA,QACjB,KAAK,yBAAyB;AAC5B,gBAAM,KAAK,8BAA8B,IAAI;AAC7C;AAAA,QACF;AAAA,QACA,KAAK,cAAc;AACjB,gBAAM,KAAK,oBAAoB,IAAI;AACnC;AAAA,QACF;AAAA,QACA,KAAK,sBAAsB;AACzB,gBAAM,KAAK,2BAA2B,IAAI;AAC1C;AAAA,QACF;AAAA,QACA,KAAK,gBAAgB;AACnB,gBAAM,KAAK,sBAAsB,IAAI;AACrC;AAAA,QACF;AAAA,QACA,KAAK,wBAAwB;AAC3B,gBAAM,KAAK,6BAA6B,IAAI;AAC5C;AAAA,QACF;AAAA,QACA,KAAK,gBAAgB;AACnB,gBAAM,KAAK,sBAAsB,IAAI;AACrC;AAAA,QACF;AAAA,QACA,KAAK,SAAS;AACZ,gBAAM,KAAK,gBAAgB,IAAI;AAC/B;AAAA,QACF;AAAA,QACA;AACE,gBAAM,IAAI;AAAA,MACd;AAGA,UAAIA,OAAM,OAAO,KAAKA,OAAM,UAAU;AAAG;AAEzC,UAAI,KAAK;AAAgB;AAGzB,oBAAc,KAAK,mBAAmB;AACtC,YAAM,kBACH,MAAM,KAAK,OAAO,QAAQ,kCAAkC,IAAI,GAC9D,SAAS,CAAC,GAAG,SAAS,KAAK,IAAI;AACpC,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,WAAK,OAAO,OAAO,KAAK;AAAA,QACtB,SAAS;AAAA,QACT,KAAK,aAAa,KAAK,QAAQ,IAAI,wBAAwB;AAAA,UACzD;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AACD,WAAK,KAAK,cAAc;AAAA,IAC1B;AAEA,UAAM,QAAQC,aAAgC;AAAA,MAC5C;AAAA,MACA,SAAS;AAAA,QACP,aAAa,KAAK,QAAQ;AAAA,QAC1B,WAAW;AAAA,MACb;AAAA,MACA,SAAS,CAAC,EAAE,OAAO,MAAM,OAAAD,OAAM,MAAM;AACnC,YAAI,KAAK;AAAgB;AAEzB,gBAAQ,KAAK,MAAM;AAAA,UACjB,KAAK,yBAAyB;AAC5B,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,6BAA6B,KAAK,QAAQ,YAAY,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YAC/K,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UACA,KAAK,cAAc;AACjB,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,eAAe,KAAK,UAAU,YAAY,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YACnK,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UACA,KAAK,sBAAsB;AACzB,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,eAAe,KAAK,iBAAiB,YAAY,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YAC1K,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UACA,KAAK,gBAAgB;AACnB,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,sBAAsB,KAAK,YAAY,YAAY,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YAC5K,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UAEA,KAAK,wBAAwB;AAC3B,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,sBAAsB,KAAK,mBAAmB,YAAY,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YACnL,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UACA,KAAK,gBAAgB;AACnB,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,iBAAiB,KAAK,YAAY,UAAU,gBAAgB,KAAK,SAAS,OAAO,KAAK,OAAO,gBAAgB,MAAM,OAAO;AAAA,YACrK,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UACA,KAAK,SAAS;AACZ,iBAAK,OAAO,OAAO,KAAK;AAAA,cACtB,SAAS;AAAA,cACT,KAAK,mBAAmB,KAAK,QAAQ,IAAI,WAAW,KAAK,WAAW,gBAAgB,MAAM,OAAO;AAAA,YACnG,CAAC;AACD,kBAAM,WAAW,OAAO,mBAAmB,KAAK;AAChD,YAAAA,OAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,EAAE,SAAS,CAAC;AACvC;AAAA,UACF;AAAA,UAEA;AACE,kBAAM,IAAI;AAAA,QACd;AAEA,aAAK,OAAO,OAAO,KAAK;AAAA,UACtB,SAAS;AAAA,UACT,KAAK,oBAAoB,KAAK,QAAQ,IAAI;AAAA,QAC5C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEQ,sBAAsB,OAAO;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAqB;AACnB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,0BAA0B,UAAU,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC5H,CAAC;AAED,UAAM,OAAO,MAAM;AAAA,MACjB,EAAE,cAAc,KAAK,aAAa;AAAA,MAClC;AAAA,QACE,SAAS,UAAU,SAAS;AAAA,QAC5B,QAAQ,UAAU,SAAS;AAAA,QAC3B,WAAW,MAAM,SAAS;AAAA,QAC1B,SAAS,MAAM,OAAO;AAAA,MACxB;AAAA,IACF;AACA,UAAM,eAAe,KAAK,kBAAkB,EAAE,WAAW,SAAS,KAAK,CAAC;AAExE,eAAW,eAAe,cAAc;AACtC,YAAM,EAAE,YAAY,SAAS,IAAI;AAEjC,UAAI,KAAK,eAAe,QAAQ,MAAM;AACpC,aAAK,eAAe,QAAQ,IAAI,CAAC;AAEnC,WAAK,eAAe,QAAQ,EAAE,KAAK,OAAO,UAAU;AAClD,cAAM,EAAE,kBAAkB,IAAI;AAC9B,cAAM,eAAe,MAAM,aAAa;AAAA,UAAO,CAAC,OAC9C,kBAAkB,IAAI,GAAG,IAAI;AAAA,QAC/B;AACA,cAAM,sBACJ,UAAU,SAAS,+BAA+B,OAC9C,MAAM,QAAQ;AAAA,UACZ,aAAa;AAAA,YAAI,CAAC,OAChB;AAAA,cACE,EAAE,cAAc,KAAK,aAAa;AAAA,cAClC,EAAE,MAAM,GAAG,KAAK;AAAA,YAClB;AAAA,UACF;AAAA,QACF,IACA,CAAC;AAEP,cAAM,KAAK,UAAU,wBAAwB;AAAA,UAC3C,MAAM,YAAY;AAAA,UAClB,UAAU;AAAA,YACR,YAAY,OAAO,YAAY,UAAU;AAAA,YACzC,UAAU,OAAO,YAAY,QAAQ;AAAA,UACvC;AAAA,UACA,WAAW,UAAU;AAAA,UACrB,SAAS,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,UAAU;AAAA,YAClB,MAAM;AAAA,UACR;AAAA,UACA,WAAW,aAAa;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,SAAK,0BAA0B,UAAU,EAAE,EAAE,qBAAqB;AAAA,MAChE;AAAA,MACA;AAAA,IACF,CAAC;AAED,SAAK,kBAAkB;AAEvB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,0BAA0B,UAAU,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC7H,CAAC;AAAA,EACH;AAAA,EAEQ,6BAA6B,OAAO;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAA4B;AAC1B,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,kCAAkC,iBAAiB,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC3I,CAAC;AAED,UAAM,WAAW,KAAK,UAAU,yBAAyB;AAAA,MACvD,SAAS,iBAAiB;AAAA,MAC1B,SAAS,iBAAiB;AAAA,MAC1B,WAAW,OAAO,iBAAiB,UAAU;AAAA,MAC7C,SAAS,OAAO,OAAO;AAAA,IACzB,CAAC;AAED,UAAM,OAAiB,CAAC;AACxB,qBAAiB,6BAA6B,UAAU;AACtD,YAAM,QAAQ,MAAM;AAAA,QAClB,EAAE,cAAc,KAAK,aAAa;AAAA,QAClC;AAAA,UACE,SAAS;AAAA,UACT,QAAQ,iBAAiB,SAAS;AAAA,UAClC,WAAW,YAAY,SAAS;AAAA,UAChC,SAAS,YAAY,OAAO;AAAA,QAC9B;AAAA,MACF;AACA,WAAK,KAAK,GAAG,KAAK;AAAA,IACpB;AAEA,UAAM,eAAe,KAAK,kBAAkB,EAAE,WAAW,SAAS,KAAK,CAAC;AAExE,eAAW,eAAe,cAAc;AACtC,YAAM,EAAE,YAAY,UAAU,MAAAE,OAAM,kBAAkB,IAAI;AAE1D,UAAI,KAAK,eAAe,QAAQ,MAAM;AACpC,aAAK,eAAe,QAAQ,IAAI,CAAC;AAEnC,WAAK,eAAe,QAAQ,EAAE,KAAK,OAAO,UAAU;AAClD,cAAM,eAAe,MAAM,aAAa;AAAA,UAAO,CAAC,OAC9C,kBAAkB,IAAI,GAAG,IAAI;AAAA,QAC/B;AACA,cAAM,sBACJ,iBAAiB,SAAS,+BAA+B,OACrD,MAAM,QAAQ;AAAA,UACZ,aAAa;AAAA,YAAI,CAAC,OAChB;AAAA,cACE,EAAE,cAAc,KAAK,aAAa;AAAA,cAClC,EAAE,MAAM,GAAG,KAAK;AAAA,YAClB;AAAA,UACF;AAAA,QACF,IACA,CAAC;AAEP,cAAM,KAAK,UAAU,+BAA+B;AAAA,UAClD,SAAS,iBAAiB;AAAA,UAC1B,SAAS,iBAAiB;AAAA,UAC1B;AAAA,UACA;AAAA,UACA;AAAA,UACA,MAAAA;AAAA,UACA,UAAU;AAAA,YACR,YAAY,OAAO,UAAU;AAAA,YAC7B,UAAU,OAAO,QAAQ;AAAA,UAC3B;AAAA,QACF,CAAC;AAED,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,iBAAiB;AAAA,YACzB,MAAM;AAAA,UACR;AAAA,UACA,WAAW,aAAa;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,SAAK,iCACH,iBAAiB,EACnB,EAAE,qBAAqB,CAAC,WAAW,OAAO,CAAC;AAE3C,SAAK,kBAAkB;AAEvB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,kCAAkC,iBAAiB,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC5I,CAAC;AAAA,EACH;AAAA,EAEQ,gCAAgC,OAAO;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAA+B;AAC7B,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,qCAAqC,QAAQ,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IACrI,CAAC;AAED,UAAM,OAAO,MAAM;AAAA,MACjB,EAAE,cAAc,KAAK,aAAa;AAAA,MAClC;AAAA,QACE,SAAS,QAAQ,SAAS;AAAA,QAC1B,QAAQ,CAAC,QAAQ,SAAS,aAAa;AAAA,QACvC,WAAW,MAAM,SAAS;AAAA,QAC1B,SAAS,MAAM,OAAO;AAAA,MACxB;AAAA,IACF;AAGA,UAAM,KAAK,UAAU,8BAA8B;AAAA,MACjD,SAAS,QAAQ;AAAA,MACjB;AAAA,IACF,CAAC;AAKD,UAAM,eAAe,KAAK,kBAAkB,EAAE,WAAW,SAAS,KAAK,CAAC;AACxE,eAAW,eAAe,cAAc;AACtC,UAAI,KAAK,eAAe,YAAY,QAAQ,MAAM;AAChD,aAAK,eAAe,YAAY,QAAQ,IAAI,CAAC;AAE/C,WAAK,eAAe,YAAY,QAAQ,EAAE,KAAK,OAAO,UAAU;AAC9D,cAAM,EAAE,kBAAkB,IAAI;AAE9B,cAAM,eAAe,MAAM,aAAa;AAAA,UAAO,CAAC,OAC9C,kBAAkB,IAAI,GAAG,IAAI;AAAA,QAC/B;AAEA,cAAM,KAAK,UAAU,wBAAwB;AAAA,UAC3C,MAAM,YAAY;AAAA,UAClB,UAAU;AAAA,YACR,YAAY,OAAO,YAAY,UAAU;AAAA,YACzC,UAAU,OAAO,YAAY,QAAQ;AAAA,UACvC;AAAA,UACA,WAAW;AAAA,YACT,SAAS,QAAQ,SAAS;AAAA,YAC1B,QAAQ,CAAC,QAAQ,SAAS,aAAa;AAAA,YACvC,4BAA4B;AAAA,UAC9B;AAAA,UACA,SAAS,QAAQ;AAAA,UACjB;AAAA,UACA;AAAA,UACA,qBAAqB,CAAC;AAAA,QACxB,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAGA,UAAM,EAAE,WAAW,gBAAgB,cAAc,IAC/C,KAAK,oCAAoC,QAAQ,EAAE,EAAE;AAAA,MACnD,CAAC,WAAW,OAAO;AAAA,IACrB;AAEF,YAAQ,QAAQ,MAAM;AAAA,MACpB,KAAK,cAAc;AACjB,YAAI,WAAW;AAIb,gBAAM,oBAAoB;AAAA,YACxB,CAAC,CAAC,iBAAiB,GAAG,aAAa,CAAC;AAAA,YACpC,KAAK,iCAAiC,QAAQ,EAAE,EAAE,YAAY;AAAA,UAChE;AACA,gBAAM,yBAAyB,UAAU;AAAA,YACvC,WAAW;AAAA,YACX,cACE,QAAQ,iBAAiB,KAAK,QAAQ;AAAA,UAC1C,CAAC;AAED,qBAAW,CAACC,YAAWC,QAAO,KAAK,wBAAwB;AACzD,iBAAK,MAAM;AAAA,cACT;AAAA,gBACE,MAAM;AAAA,gBACN,kBAAkB;AAAA,gBAClB,WAAAD;AAAA,gBACA,SAAAC;AAAA,cACF;AAAA,cACA,EAAE,UAAU,OAAO,mBAAmBD,WAAU;AAAA,YAClD;AAAA,UACF;AAAA,QACF;AACA,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,GAAG,QAAQ,YAAY;AAAA,YAC/B,MAAM;AAAA,UACR;AAAA,UACA,UAAU,YAAY;AAAA,QACxB;AACA;AAAA,MACF;AAAA,MAEA,KAAK,oBAAoB;AACvB,YAAI,WAAW;AAIb,gBAAM,oBAAoB;AAAA,YACxB,CAAC,CAAC,iBAAiB,GAAG,aAAa,CAAC;AAAA,YACpC,KAAK,mCAAmC,QAAQ,EAAE,EAAE,YAAY;AAAA,UAClE;AACA,gBAAM,2BAA2B,UAAU;AAAA,YACzC,WAAW;AAAA,YACX,cAAc;AAAA,UAChB,CAAC;AAED,qBAAW,CAACA,YAAWC,QAAO,KAAK,0BAA0B;AAC3D,iBAAK,MAAM;AAAA,cACT;AAAA,gBACE,MAAM;AAAA,gBACN,oBAAoB;AAAA,gBACpB,WAAAD;AAAA,gBACA,SAAAC;AAAA,cACF;AAAA,cACA,EAAE,UAAU,OAAO,mBAAmBD,WAAU;AAAA,YAClD;AAAA,UACF;AAAA,QACF;AACA,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,GAAG,QAAQ,YAAY;AAAA,YAC/B,MAAM;AAAA,UACR;AAAA,UACA,UAAU,YAAY;AAAA,QACxB;AACA;AAAA,MACF;AAAA,MAEA;AACE,cAAM,OAAO;AAAA,IACjB;AAEA,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,qCAAqC,QAAQ,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IACtI,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAwB,OAAO;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAuB;AACrB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,4BAA4B,YAAY,UAAU,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC9H,CAAC;AAED,UAAM,cACH,YAAY,YAAY,SAAS,UAAU,YAAY,SAAS;AACnE,UAAM,SACJ,eAAe,IAAI,IAAI,YAAY,SAAS,WAAW;AAMzD,UAAM,iBAA2B,CAAC;AAClC,aACM,cAAc,YAAY,QAC9B,eAAe,SACf,eAAe,YAAY,SAAS,UACpC;AACA,qBAAe,KAAK,WAAW;AAAA,IACjC;AAIA,QAAI,CAAC,eAAe,SAAS,OAAO,GAAG;AACrC,qBAAe,KAAK,OAAO;AAAA,IAC7B;AAEA,QAAI,kBAAkB;AACtB,eAAW,eAAe,gBAAgB;AACxC,YAAM,WAAW,MAAM,KAAK,UAAU,SAAS;AAAA,QAC7C,SAAS,YAAY;AAAA,QACrB;AAAA,MACF,CAAC;AAED,YAAM,aAAa;AACnB,YAAM,WAAW;AAEjB,UAAI,UAAU;AACZ,cAAM,KAAK,UAAU,0BAA0B;AAAA,UAC7C,SAAS,YAAY;AAAA,UACrB,aAAa,YAAY;AAAA,UACzB,UAAU;AAAA,YACR,YAAY,OAAO,UAAU;AAAA,YAC7B,UAAU,OAAO,QAAQ;AAAA,UAC3B;AAAA,QACF,CAAC;AAED,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,YAAY;AAAA,YACpB,MAAM;AAAA,UACR;AAAA,UACA,WAAW,aAAa;AAAA,QAC1B;AAAA,MACF,OAAO;AACL,YAAI,KAAK,eAAe,WAAW,MAAM;AACvC,eAAK,eAAe,WAAW,IAAI,CAAC;AAEtC,aAAK,eAAe,WAAW,EAAE,KAAK,OAAO,UAAU;AACrD,gBAAM,KAAK,UAAU,0BAA0B;AAAA,YAC7C,SAAS,YAAY;AAAA,YACrB,aAAa,YAAY;AAAA,YACzB;AAAA,YACA,UAAU;AAAA,cACR,YAAY,OAAO,UAAU;AAAA,cAC7B,UAAU,OAAO,QAAQ;AAAA,YAC3B;AAAA,UACF,CAAC;AAED,eAAK,OAAO,QAAQ,mCAAmC;AAAA,YACrD;AAAA,cACE,SAAS,KAAK,QAAQ;AAAA,cACtB,QAAQ,YAAY;AAAA,cACpB,MAAM;AAAA,YACR;AAAA,YACA,WAAW,aAAa;AAAA,UAC1B;AAAA,QACF,CAAC;AAAA,MACH;AAEA,wBAAkB,cAAc;AAAA,IAClC;AAEA,SAAK,4BAA4B,YAAY,EAAE,EAAE,qBAAqB;AAAA,MACpE;AAAA,MACA;AAAA,IACF,CAAC;AAED,SAAK,kBAAkB;AAEvB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,4BAA4B,YAAY,UAAU,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC/H,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAwB,OAAO;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAuB;AACrB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,4BAA4B,YAAY,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAChI,CAAC;AAED,UAAM,SAAS,MAAM;AAAA,MACnB,EAAE,cAAc,KAAK,aAAa;AAAA,MAClC;AAAA,QACE;AAAA,QACA;AAAA,QACA,aAAa,YAAY,SAAS;AAAA,QAClC,WAAW,YAAY,SAAS;AAAA,MAClC;AAAA,IACF,EAAE;AAAA,MACA,CAACE,YAAWA,QAAO,OAAO,CAAC,MAAM,EAAE,SAAS,MAAM;AAAA,IACpD;AAGA,UAAM,sBAAsB,MAAM,QAAQ;AAAA,MACxC,OAAO,OAAO,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC,EAAE;AAAA,QAAI,CAACC,UAChD;AAAA,UACE;AAAA,YACE,cAAc,KAAK;AAAA,UACrB;AAAA,UACA;AAAA,YACE,MAAAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,uBAAuB,oBAAI,IAAU;AAC3C,eAAW,WAAW,qBAAqB;AACzC,UAAI,QAAQ,WAAW,OAAO;AAC5B,6BAAqB,IAAI,QAAQ,eAAe;AAAA,MAClD;AAAA,IACF;AAEA,UAAM,mBAAmB,OAAO;AAAA,MAC9B,CAAC,UAAU,qBAAqB,IAAI,MAAM,eAAe,MAAM;AAAA,IACjE;AAEA,UAAM,sBAAmE,CAAC;AAC1E,UAAM,wBAA+D,CAAC;AAEtE,eAAW,SAAS,kBAAkB;AACpC,YAAM,cAAcC,aAAY,MAAM,WAAW;AAEjD,UAAI,oBAAoB,WAAW,MAAM,QAAW;AAClD,4BAAoB,WAAW,IAAI,CAAC;AAAA,MACtC;AACA,UAAI,sBAAsB,WAAW,MAAM,QAAW;AACpD,8BAAsB,WAAW,IAAI,oBAAI,IAAU;AAAA,MACrD;AAEA,0BAAoB,WAAW,EAAG,KAAK,KAAK;AAC5C,4BAAsB,WAAW,EAAG,IAAI,MAAM,eAAe;AAAA,IAC/D;AAEA,UAAM,iBAAiB,OAAO,KAAK,qBAAqB,EACrD,IAAI,MAAM,EACV,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAIvB,QAAI,CAAC,eAAe,SAAS,OAAO,GAAG;AACrC,qBAAe,KAAK,OAAO;AAAA,IAC7B;AAEA,UAAM,iBAKA,CAAC;AAEP,QAAI,OAAO;AACX,eAAW,eAAe,gBAAgB;AACxC,qBAAe,KAAK;AAAA,QAClB,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,QAAQ,oBAAoB,WAAW,KAAK,CAAC;AAAA,QAC7C,mBAAmB,sBAAsB,WAAW,KAAK,oBAAI,IAAI;AAAA,MACnE,CAAC;AACD,aAAO,cAAc;AAAA,IACvB;AAEA,eAAW,iBAAiB,gBAAgB;AAC1C,YAAM,EAAE,YAAY,SAAS,IAAI;AAEjC,UAAI,KAAK,eAAe,QAAQ,MAAM;AACpC,aAAK,eAAe,QAAQ,IAAI,CAAC;AAEnC,WAAK,eAAe,QAAQ,EAAE,KAAK,OAAO,UAAU;AAClD,cAAM,EAAE,kBAAkB,IAAI;AAC9B,cAAM,eAAe,MAAM,aAAa;AAAA,UAAO,CAAC,OAC9C,kBAAkB,IAAI,GAAG,IAAI;AAAA,QAC/B;AAEA,cAAM,KAAK,UAAU,0BAA0B;AAAA,UAC7C,QAAQ,cAAc;AAAA,UACtB,UAAU;AAAA,YACR,YAAY,OAAO,UAAU;AAAA,YAC7B,UAAU,OAAO,QAAQ;AAAA,UAC3B;AAAA,UACA,aAAa,YAAY;AAAA,UACzB,SAAS,YAAY;AAAA,UACrB;AAAA,UACA;AAAA;AAAA;AAAA;AAAA,UAIA,qBAAqB,oBAAoB;AAAA,YAAO,CAAC,QAC/C,kBAAkB,IAAI,IAAI,eAAe;AAAA,UAC3C;AAAA,QACF,CAAC;AAED,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,YAAY;AAAA,YACpB,MAAM;AAAA,UACR;AAAA,UACA,WAAW,aAAa;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AACA,SAAK,4BAA4B,YAAY,EAAE,EAAE,qBAAqB;AAAA,MACpE;AAAA,MACA;AAAA,IACF,CAAC;AAED,SAAK,kBAAkB;AAEvB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,4BAA4B,YAAY,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IACjI,CAAC;AAAA,EACH;AAAA,EAEQ,+BAA+B,OAAO;AAAA,IAC5C;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAA8B;AAC5B,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,oCAAoC,mBAAmB,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAC/I,CAAC;AAED,UAAM,WAAW,KAAK,UAAU,yBAAyB;AAAA,MACvD,SAAS,mBAAmB;AAAA,MAC5B,SAAS,mBAAmB;AAAA,MAC5B,WAAW,OAAO,mBAAmB,UAAU;AAAA,MAC/C,SAAS,OAAO,OAAO;AAAA,IACzB,CAAC;AAED,UAAM,SAA0B,CAAC;AACjC,qBAAiB,6BAA6B,UAAU;AACtD,YAAM,UAAU,MAAM;AAAA,QACpB,EAAE,cAAc,KAAK,aAAa;AAAA,QAClC;AAAA,UACE;AAAA,UACA;AAAA,UACA,aAAa,mBAAmB,SAAS;AAAA,UACzC,WAAW;AAAA,QACb;AAAA,MACF,EAAE;AAAA,QACA,CAACF,YAAWA,QAAO,OAAO,CAAC,MAAM,EAAE,SAAS,MAAM;AAAA,MACpD;AACA,aAAO,KAAK,GAAG,OAAO;AAAA,IACxB;AAGA,UAAM,sBAAsB,MAAM,QAAQ;AAAA,MACxC,OAAO,OAAO,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC,EAAE;AAAA,QAAI,CAACC,UAChD;AAAA,UACE;AAAA,YACE,cAAc,KAAK;AAAA,UACrB;AAAA,UACA;AAAA,YACE,MAAAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,uBAAuB,oBAAI,IAAU;AAC3C,eAAW,WAAW,qBAAqB;AACzC,UAAI,QAAQ,WAAW,OAAO;AAC5B,6BAAqB,IAAI,QAAQ,eAAe;AAAA,MAClD;AAAA,IACF;AAEA,UAAM,mBAAmB,OAAO;AAAA,MAC9B,CAAC,UAAU,qBAAqB,IAAI,MAAM,eAAe,MAAM;AAAA,IACjE;AAEA,UAAM,sBAAmE,CAAC;AAC1E,UAAM,wBAA+D,CAAC;AAEtE,eAAW,SAAS,kBAAkB;AACpC,YAAM,cAAcC,aAAY,MAAM,WAAW;AAEjD,UAAI,oBAAoB,WAAW,MAAM,QAAW;AAClD,4BAAoB,WAAW,IAAI,CAAC;AAAA,MACtC;AACA,UAAI,sBAAsB,WAAW,MAAM,QAAW;AACpD,8BAAsB,WAAW,IAAI,oBAAI,IAAU;AAAA,MACrD;AAEA,0BAAoB,WAAW,EAAG,KAAK,KAAK;AAC5C,4BAAsB,WAAW,EAAG,IAAI,MAAM,eAAe;AAAA,IAC/D;AAEA,UAAM,iBAAiB,OAAO,KAAK,qBAAqB,EACrD,IAAI,MAAM,EACV,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAIvB,QAAI,CAAC,eAAe,SAAS,OAAO,GAAG;AACrC,qBAAe,KAAK,OAAO;AAAA,IAC7B;AAEA,UAAM,iBAKA,CAAC;AAEP,QAAI,OAAO;AACX,eAAW,eAAe,gBAAgB;AACxC,qBAAe,KAAK;AAAA,QAClB,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,QAAQ,oBAAoB,WAAW,KAAK,CAAC;AAAA,QAC7C,mBAAmB,sBAAsB,WAAW,KAAK,oBAAI,IAAI;AAAA,MACnE,CAAC;AACD,aAAO,cAAc;AAAA,IACvB;AAEA,eAAW,iBAAiB,gBAAgB;AAC1C,YAAM,EAAE,YAAY,SAAS,IAAI;AAEjC,UAAI,KAAK,eAAe,QAAQ,MAAM;AACpC,aAAK,eAAe,QAAQ,IAAI,CAAC;AAEnC,WAAK,eAAe,QAAQ,EAAE,KAAK,OAAO,UAAU;AAClD,cAAM,EAAE,kBAAkB,IAAI;AAC9B,cAAM,eAAe,MAAM,aAAa;AAAA,UAAO,CAAC,OAC9C,kBAAkB,IAAI,GAAG,IAAI;AAAA,QAC/B;AAEA,cAAM,KAAK,UAAU,iCAAiC;AAAA,UACpD,SAAS,mBAAmB;AAAA,UAC5B,SAAS,mBAAmB;AAAA,UAC5B;AAAA,UACA;AAAA;AAAA;AAAA;AAAA,UAIA,qBAAqB,oBAAoB;AAAA,YAAO,CAAC,QAC/C,kBAAkB,IAAI,IAAI,eAAe;AAAA,UAC3C;AAAA,UACA,QAAQ,cAAc;AAAA,UACtB,UAAU;AAAA,YACR,YAAY,OAAO,UAAU;AAAA,YAC7B,UAAU,OAAO,QAAQ;AAAA,UAC3B;AAAA,QACF,CAAC;AAED,aAAK,OAAO,QAAQ,mCAAmC;AAAA,UACrD;AAAA,YACE,SAAS,KAAK,QAAQ;AAAA,YACtB,QAAQ,mBAAmB;AAAA,YAC3B,MAAM;AAAA,UACR;AAAA,UACA,WAAW,aAAa;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,SAAK,mCACH,mBAAmB,EACrB,EAAE,qBAAqB,CAAC,WAAW,OAAO,CAAC;AAE3C,SAAK,kBAAkB;AAEvB,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,oCAAoC,mBAAmB,YAAY,gBAAgB,SAAS,OAAO,OAAO;AAAA,IAChJ,CAAC;AAAA,EACH;AAAA,EAEQ,kBAAkB,OAAO,EAAE,aAAa,UAAU,MAAiB;AACzE,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,aAAa,KAAK,QAAQ,IAAI,0BAA0B,WAAW,SAAS,UAAU,MAAM;AAAA,IACnG,CAAC;AAED,UAAM,QAAQ,MAAM;AAAA,MAClB,EAAE,cAAc,KAAK,aAAa;AAAA,MAClC;AAAA,QACE;AAAA,MACF;AAAA,IACF;AAEA,eAAW,YAAY,WAAW;AAChC,YAAM,SAAS,KAAK;AAAA,IACtB;AAEA,UAAM,qBAAqB,KAAK,qBAAqB,kBAAkB;AAAA,MACrE;AAAA,MACA,gBAAgBA,aAAY,MAAM,SAAS;AAAA,IAC7C,CAAC;AAED,QAAI,oBAAoB;AACtB,WAAK,wBAAwB,KAAK;AAAA,QAChC,GAAG;AAAA,QACH,gBAAgB,mBAAmB;AAAA,QACnC,SAAS,OAAO,KAAK,QAAQ,OAAO;AAAA,QACpC,aAAa,OAAO,mBAAmB,WAAW;AAAA,MACpD,CAAC;AAAA,IACH;AAEA,SAAK,OAAO,OAAO,MAAM;AAAA,MACvB,SAAS;AAAA,MACT,KAAK,cAAc,KAAK,QAAQ,IAAI,0BAA0B,WAAW,SAAS,UAAU,MAAM;AAAA,IACpG,CAAC;AAAA,EACH;AAAA,EAEQ,oBAAoB,CAAC;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAIM;AACJ,UAAM,oBAA0D,CAAC;AACjE,UAAM,wBAA+D,CAAC;AAEtE,SAAK,QAAQ,CAAC,QAAQ;AACpB,YAAM,cAAcA,aAAY,IAAI,WAAY;AAChD,OAAC,sBAAsB,WAAW,MAAM,oBAAI,IAAU,GAAG;AAAA,QACvD,IAAI;AAAA,MACN;AACA,OAAC,kBAAkB,WAAW,MAAM,CAAC,GAAG,KAAK,GAAG;AAAA,IAClD,CAAC;AAED,UAAM,iBAAiB,OAAO,KAAK,qBAAqB,EACrD,IAAI,MAAM,EACV,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAIvB,QAAI,CAAC,eAAe,SAAS,OAAO,GAAG;AACrC,qBAAe,KAAK,OAAO;AAAA,IAC7B;AAEA,UAAM,oBAKA,CAAC;AAEP,QAAI,OAAO;AACX,eAAW,eAAe,gBAAgB;AACxC,wBAAkB,KAAK;AAAA,QACrB,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,MAAM,kBAAkB,WAAW,KAAK,CAAC;AAAA,QACzC,mBAAmB,sBAAsB,WAAW,KAAK,oBAAI,IAAI;AAAA,MACnE,CAAC;AACD,aAAO,cAAc;AAAA,IACvB;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB,MAAM;AAMhC,UAAM,4BAA4B,KAAK;AAAA,MACrC,GAAG;AAAA,QACD,GAAG,OAAO,OAAO,KAAK,yBAAyB;AAAA,QAC/C,GAAG,OAAO,OAAO,KAAK,mCAAmC;AAAA,QACzD,GAAG,OAAO,OAAO,KAAK,gCAAgC;AAAA,QACtD,GAAG,OAAO,OAAO,KAAK,2BAA2B;AAAA,QACjD,GAAG,OAAO,OAAO,KAAK,kCAAkC;AAAA,QACxD,GAAG,OAAO,OAAO,KAAK,2BAA2B;AAAA,MACnD,EACG,OAAO,CAAC,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC,EACxC,IAAI,CAAC,MAAM,EAAE,cAAc,CAAC;AAAA,IACjC;AAEA,QAAI,4BAA4B,KAAK,8BAA8B;AACjE,YAAM,YAAY,OAAO,KAAK,KAAK,cAAc,EAC9C,IAAI,MAAM,EACV,OAAO,CAAC,gBAAgB,eAAe,yBAAyB;AAEnE,WAAK,qBAAqB,iBAAiB,EAAE,cAAc,UAAU,CAAC;AAEtE,iBAAW,eAAe,WAAW;AACnC,aAAK,MAAM;AAAA,UACT;AAAA,YACE,MAAM;AAAA,YACN;AAAA,YACA,WAAW,KAAK,eAAe,WAAW;AAAA,UAC5C;AAAA,UACA,EAAE,UAAU,OAAO,mBAAmB,YAAY;AAAA,QACpD;AACA,eAAO,KAAK,eAAe,WAAW;AAAA,MACxC;AAEA,WAAK,+BAA+B;AAAA,IACtC;AAAA,EACF;AAAA,EAEQ,0BAA0B;AAAA,IAChC;AAAA,IACA,CAAC,eAA2B;AAC1B,WAAK,KAAK,wBAAwB,UAAU;AAAA,IAC9C;AAAA,EACF;AACF;;;AE52DA,SAAkC,eAAAC,oBAAmB;;;AC/BrD;AAAA,EACE;AAAA,EACA;AAAA,OACK;AAGA,IAAM,gBACX;AAEK,SAAS,0BAA0B;AAAA,EACxC;AAAA,EACA;AACF,GAMG;AACD,QAAM,eAA0B,CAAC;AACjC,aAAW,QAAQ,CAAC,cAAc;AAChC,UAAM,UACJ,UAAU,YAAY,SAClB,CAAC,IACD,MAAM,QAAQ,UAAU,OAAO,IAC7B,UAAU,UACV,CAAC,UAAU,OAAO;AAC1B,iBAAa,KAAK,GAAG,OAAO;AAAA,EAC9B,CAAC;AACD,MAAI,aAAa,KAAK,CAAC,MAAM,yBAAyB,OAAO,CAAC,CAAC,GAAG;AAChE,WAAO;AAAA,EACT;AAEA,QAAM,YAAmB,CAAC;AAC1B,aAAW,QAAQ,CAAC,cAAc;AAChC,cAAU,QAAQ,QAAQ,CAAC,UAAU;AACnC,UAAI,UAAU;AAAM;AACpB,UAAI,MAAM,QAAQ,KAAK;AAAG,kBAAU,KAAK,GAAG,KAAK;AAAA;AAC5C,kBAAU,KAAK,KAAK;AAAA,IAC3B,CAAC;AAAA,EACH,CAAC;AACD,MAAI,UAAU,KAAK,CAAC,MAAM,eAAe,OAAO,CAAC,CAAC,GAAG;AACnD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACvCO,SAAS,WAAW;AAAA,EACzB;AAAA,EACA;AACF,GAGG;AACD,SAAO,KAAK;AAAA,IAAO,CAAC,QAClB,WAAW,KAAK,CAAC,cAAc,qBAAqB,EAAE,KAAK,UAAU,CAAC,CAAC;AAAA,EACzE;AACF;AAEO,SAAS,qBAAqB;AAAA,EACnC;AAAA,EACA;AACF,GAGG;AACD,QAAM,aAAa,YAAY,IAAI,OAAO;AAE1C,MAAI,UAAU,YAAY,UAAa,UAAU,QAAQ,SAAS,GAAG;AACnE,QAAI,MAAM,QAAQ,UAAU,OAAO,GAAG;AACpC,UAAI,CAAC,UAAU,QAAQ,SAAS,UAAU;AAAG,eAAO;AAAA,IACtD,OAAO;AACL,UAAI,eAAe,UAAU;AAAS,eAAO;AAAA,IAC/C;AAAA,EACF;AAEA,MAAI,UAAU,QAAQ;AACpB,eAAW,CAAC,OAAO,KAAK,KAAK,UAAU,OAAO,QAAQ,GAAG;AACvD,UAAI,UAAU,QAAQ,UAAU;AAAW;AAE3C,UAAI,IAAI,OAAO,KAAK,MAAM,QAAQ,IAAI,OAAO,KAAK,MAAM;AACtD,eAAO;AAET,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,YAAI,CAAC,MAAM,SAAS,YAAY,IAAI,OAAO,KAAK,CAAC,CAAC;AAAG,iBAAO;AAAA,MAC9D,OAAO;AACL,YAAI,YAAY,IAAI,OAAO,KAAK,CAAC,MAAM;AAAO,iBAAO;AAAA,MACvD;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AACF,GAMG;AACD,SAAO,WAAW;AAAA,IAAO,CAAC,cACxB,iBAAiB;AAAA,MAAK,CAAC,oBACrB,2BAA2B,EAAE,WAAW,gBAAgB,CAAC;AAAA,IAC3D;AAAA,EACF;AACF;AAEO,SAAS,2BAA2B;AAAA,EACzC;AAAA,EACA;AACF,GAGG;AACD,QAAM,cAAc,YAAY,UAAU,OAAO,IAAI;AACrD,QAAM,YAAY,YAAY,UAAU,OAAO,EAAE;AAEjD,MACE,gBAAgB,gBAAgB,UAChC,gBAAgB,YAAY,SAAS,GACrC;AACA,QAAI,CAAC,gBAAgB,YAAY,SAAS,WAAW;AAAG,aAAO;AAAA,EACjE;AAEA,MACE,gBAAgB,cAAc,UAC9B,gBAAgB,UAAU,SAAS,GACnC;AACA,QAAI,CAAC,gBAAgB,UAAU,SAAS,SAAS;AAAG,aAAO;AAAA,EAC7D;AAEA,SAAO;AACT;;;AC/FA,SAAoC,eAAAC,oBAAmB;AAOhD,IAAM,wBAAwB,CAAC;AAAA,EACpC,MAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,OAA8B;AAAA,EAC5B,MAAAA;AAAA,EACA;AAAA,EACA,QAAQD,aAAY,MAAM;AAAA,EAC1B,WAAWA,aAAY,SAAS;AAClC;;;AHqEA,IAAM,gBAAgB;AAAA,EACpB;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AACnD;AACA,IAAM,oBAAoB;AAEnB,IAAME,UAAS,CAAC;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MASe;AACb,QAAM,aAAa,QAAQ,OAAO,WAAW;AAC7C,QAAM,oBAAoB,QAAQ,OAAO,kBAAkB;AAC3D,QAAM,eAAe,QAAQ,OAAO,aAAa;AACjD,QAAM,mBAAmB,QAAQ,OAAO,iBAAiB;AACzD,QAAM,0BAA0B,QAAQ,OAAO,wBAAwB;AAEvE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV,gBAAgB,sBAAsB,cAAc;AAAA,IACpD,YAAY,CAAC;AAAA,IACb,OAAO;AAAA,IACP,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,IACA,6BACE,WAAW,KAAK,CAAC,MAAM,EAAE,SAAS,0BAA0B,KAC5D,kBAAkB,KAAK,CAAC,MAAM,EAAE,SAAS,0BAA0B;AAAA,IACrE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAMC,SAAQ,CAAC,YAAqB;AAWzC,QAAM,QAAQ,YAAY;AAAA,IACxB,SAAS;AAAA,IACT,aAAa;AAAA,IACb,cAAc;AAAA,IACd,QAAQ,OAAO,iBAA4B;AACzC,YAAM,mBAAmB,oBAAoB,OAAO;AACpD,YAAM,qBAAqBC,aAAY,aAAa,MAAM;AAG1D,UAAI,iBAAiB,SAAS,aAAa,MAAM;AAC/C,gBAAQ,OAAO,OAAO,MAAM;AAAA,UAC1B,SAAS;AAAA,UACT,KAAK,uBAAuB,QAAQ,QAAQ,IAAI,WAAW,kBAAkB;AAAA,QAC/E,CAAC;AAED;AAAA,MACF;AAEA,UAAI;AAGF,YAAI,iBAAiB,UAAU,oBAAoB;AACjD,gBAAM,YAAY,SAAS,YAAY;AAEvC,gBAAM,MAAM;AACZ;AAAA,QACF;AAGA,YAAI,iBAAiB,SAAS,IAAI,oBAAoB;AAEpD,gBAAM,oBAAoB;AAAA,YACxB,iBAAiB,SAAS;AAAA,YAC1B,KAAK;AAAA,cACH;AAAA,cACA,iBAAiB,SAAS;AAAA,YAC5B;AAAA,UACF;AACA,gBAAM,gBAAgB,MAAM,QAAQ;AAAA,YAClC,kBAAkB;AAAA,cAAI,CAAC,gBACrB,sBAAsB,SAAS,EAAE,YAAY,CAAC;AAAA,YAChD;AAAA,UACF;AAEA,kBAAQ,OAAO,OAAO,MAAM;AAAA,YAC1B,SAAS;AAAA,YACT,KAAK,WAAW,kBAAkB,MAAM,aACtC,QAAQ,QAAQ,IAClB,iBAAiB,iBAAiB,SAAS,CAAC,OAAO,KAAK;AAAA,cACtD;AAAA,cACA,iBAAiB,SAAS;AAAA,YAC5B,CAAC;AAAA,UACH,CAAC;AAKD,cAAI,QAAQ;AAAU;AAEtB,gBAAM,MAAM;AAEZ,qBAAW,gBAAgB,eAAe;AACxC,kBAAM,IAAI,YAAY;AAAA,UACxB;AAEA,gBAAM,IAAI,YAAY;AAEtB;AAAA,QACF;AAGA,YAAI,aAAa,eAAe,iBAAiB,MAAM;AACrD,gBAAM,YAAY,SAAS,YAAY;AACvC,gBAAM,MAAM;AACZ;AAAA,QACF;AAIA,cAAM,YAAY,SAAS,EAAE,aAAa,CAAC;AAG3C,gBAAQ,oBAAoB;AAE5B;AAAA,MACF,SAAS,QAAQ;AACf,YAAI,QAAQ;AAAU;AAEtB,cAAM,QAAQ;AAEd,gBAAQ,OAAO,OAAO,KAAK;AAAA,UACzB,SAAS;AAAA,UACT,KAAK,sBAAsB,QAAQ,QAAQ,IAAI,WAAW,kBAAkB,gBAAgB,MAAM,OAAO;AAAA,QAC3G,CAAC;AAED,cAAM,WAAW,cAAc,QAAQ,iBAAiB;AAExD,gBAAQ,OAAO,OAAO,KAAK;AAAA,UACzB,SAAS;AAAA,UACT,KAAK,aAAa,QAAQ,QAAQ,IAAI,gBAAgB,QAAQ,IAC5D,aAAa,IAAI,WAAW,SAC9B;AAAA,QACF,CAAC;AAED,cAAM,KAAK,WAAW,GAAK;AAI3B,cAAM,MAAM;AAGZ,YAAI,EAAE,QAAQ,sBAAsB,cAAc,QAAQ;AACxD,kBAAQ,OAAO,OAAO,MAAM;AAAA,YAC1B,SAAS;AAAA,YACT,KAAK,mCAAmC,QAAQ,QAAQ,IAAI,WAAW,kBAAkB,UAAU,cAAc,MAAM;AAAA,YACvH;AAAA,UACF,CAAC;AAED,kBAAQ,aAAa,KAAK;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,UAAU,YAAY;AAC1B,QAAI;AACF,YAAM,QAAQ,MAAM,sBAAsB,SAAS;AAAA,QACjD,UAAU;AAAA,MACZ,CAAC;AAED,aAAO,MAAM,IAAI,KAAK;AAAA,IACxB,SAAS,QAAQ;AACf,UAAI,QAAQ;AAAU;AAEtB,YAAM,QAAQ;AAEd,cAAQ,OAAO,OAAO,KAAK;AAAA,QACzB,SAAS;AAAA,QACT,KAAK,2BAA2B,QAAQ,QAAQ,IAAI,uBAAuB,MAAM,OAAO;AAAA,MAC1F,CAAC;AAAA,IACH;AAAA,EACF;AAEA,cAAY,SAAS,QAAQ,QAAQ,eAAe;AAEpD,UAAQ,QAAQ;AAGhB,SAAO,QAAQ,EAAE,KAAK,MAAM,KAAK;AACnC;AAEO,IAAMC,QAAO,OAAO,YAAqB;AAC9C,UAAQ,WAAW;AACnB,UAAQ,OAAO,MAAM;AACrB,UAAQ,OAAO,MAAM;AACrB,QAAM,QAAQ,OAAO,OAAO;AAC9B;AAYO,IAAM,cAAc,OACzB,SACA,EAAE,aAAa,MACZ;AACH,QAAM,qBAAqBD,aAAY,aAAa,MAAM;AAC1D,QAAM,wBAAwBA,aAAY,aAAa,SAAS;AAEhE,UAAQ,OAAO,OAAO,MAAM;AAAA,IAC1B,SAAS;AAAA,IACT,KAAK,oBAAoB,QAAQ,QAAQ,IAAI,WAAW,kBAAkB;AAAA,EAC5E,CAAC;AAGD,QAAM,oBACJ,QAAQ,kBAAkB,SAAS,KACnC,aAAa,cAAc,iBAC3B,0BAA0B;AAAA,IACxB,OAAO,aAAa;AAAA,IACpB,YAAY,QAAQ,WAAW,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,EACtD,CAAC;AACH,QAAM,sBACJ,QAAQ,iBAAiB,SAAS,KAClC,QAAQ,wBAAwB,SAAS;AAG3C,QAAM,YAAY,oBACd,MAAM,aAAa,SAAS,EAAE,WAAW,aAAa,KAAK,CAAC,IAC5D,CAAC;AACL,QAAM,UAAU,MAAM,eAAe,SAAS;AAAA,IAC5C,MAAM;AAAA,IACN,iBAAiB,OAAO,kBAAkB;AAAA,EAC5C,CAAC;AAGD,MACE,qBACA,aAAa,cAAc,iBAC3B,UAAU,WAAW,GACrB;AACA,UAAM,IAAI;AAAA,MACR,qBAAqB,QAAQ,QAAQ,IAAI;AAAA,IAC3C;AAAA,EACF;AAEA,MACE,sBACC,QAAQ,WAAW,SAAS,KAAK,QAAQ,kBAAkB,SAAS,IACrE;AACA,YAAQ,OAAO,OAAO,MAAM;AAAA,MAC1B,SAAS;AAAA,MACT,KAAK,8BAA8B,QAAQ,QAAQ,IAAI,WAAW,kBAAkB;AAAA,IACtF,CAAC;AAAA,EACH;AAGA,QAAM,cAAc,sBAChB,MAAM,aAAa,SAAS;AAAA,IAC1B,aAAa;AAAA,EACf,CAAC,IACD,CAAC;AACL,QAAM,kBAAkB,YAAY;AAAA,IAClC,CAAC,UAAU,MAAM,SAAS;AAAA,EAC5B;AACA,QAAM,gBAAgB,MAAM,qBAAqB,SAAS;AAAA,IACxD,YAAY;AAAA,IACZ,MAAM;AAAA,IACN,iBAAiB,OAAO,kBAAkB;AAAA,EAC5C,CAAC;AAGD,aAAW,aAAa,eAAe;AACrC,QAAI,UAAU,cAAc,aAAa,MAAM;AAC7C,YAAM,IAAI;AAAA,QACR,wCAAwC,UAAU,SAAS,6CAA6C,aAAa,IAAI;AAAA,MAC3H;AAAA,IACF;AAAA,EACF;AAIA,MACE,uBACA,aAAa,aAAa,WAAW,KACrC,YAAY,WAAW,GACvB;AACA,UAAM,IAAI;AAAA,MACR,qBAAqB,QAAQ,QAAQ,IAAI;AAAA,IAC3C;AAAA,EACF;AAEA,QAAM,oBAAoB,oBAAI,IAAU;AACxC,aAAW,OAAO,SAAS;AACzB,sBAAkB,IAAI,IAAI,eAAe;AAAA,EAC3C;AACA,aAAW,aAAa,eAAe;AACrC,sBAAkB,IAAI,UAAU,eAAe;AAAA,EACjD;AAEA,QAAM,eAAe,aAAa,aAAa;AAAA,IAAO,CAAC,MACrD,kBAAkB,IAAI,EAAE,IAAI;AAAA,EAC9B;AAEA,QAAM,yBACJ,QAAQ,+BAA+B,cAAc,SAAS,IAC1D,MAAM,QAAQ;AAAA,IACZ,aAAa;AAAA,MAAI,CAAC,EAAE,MAAAE,MAAK,MACvB,2BAA2B,SAAS,EAAE,MAAAA,MAAK,CAAC;AAAA,IAC9C;AAAA,EACF,IACA,CAAC;AAGP,QAAM,uBAAuB,oBAAI,IAAU;AAC3C,aAAW,WAAW,wBAAwB;AAC5C,QAAI,QAAQ,WAAW,OAAO;AAC5B,2BAAqB,IAAI,QAAQ,eAAe;AAAA,IAClD;AAAA,EACF;AAEA,QAAM,0BAA0B,cAAc;AAAA,IAC5C,CAAC,UAAU,qBAAqB,IAAI,MAAM,eAAe,MAAM;AAAA,EACjE;AAKA,QAAM,cAAc,QAAQ,SAAS;AACrC,QAAM,oBAAoB,wBAAwB,SAAS;AAC3D,QAAM,gBAAgB,QAAQ,aAAa;AAAA,IACzC,CAAC,iBACE,qBAAqB,YAAY,SAAS,UACzC,YAAY,SAAS,aACvB;AAAA,EACJ;AAEA,MAAI,eAAe,qBAAqB,eAAe;AACrD,UAAM,QAAQ,UAAU,oBAAoB;AAAA,MAC1C,SAAS,QAAQ,QAAQ;AAAA,MACzB,OAAO;AAAA,MACP;AAAA,MACA,qBAAqB;AAAA,MACrB,MAAM;AAAA,MACN,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAEA,MAAI,eAAe,mBAAmB;AACpC,UAAM,eACJ,QAAQ,WAAW,IAAI,UAAU,GAAG,QAAQ,MAAM;AACpD,UAAM,iBACJ,cAAc,WAAW,IACrB,iBACA,GAAG,cAAc,MAAM;AAC7B,UAAM,OAAO,CAAC,cAAc,cAAc,EAAE,KAAK,OAAO;AACxD,YAAQ,OAAO,OAAO,KAAK;AAAA,MACzB,SAAS;AAAA,MACT,KAAK,UAAU,IAAI,UAAU,QAAQ,QAAQ,IAAI,WAAW,kBAAkB;AAAA,IAChF,CAAC;AAAA,EACH,WAAW,eAAe;AACxB,YAAQ,OAAO,OAAO,KAAK;AAAA,MACzB,SAAS;AAAA,MACT,KAAK,gBAAgB,kBAAkB,UAAU,QAAQ,QAAQ,IAAI;AAAA,IACvE,CAAC;AAAA,EACH;AAEA,UAAQ,QAAQ;AAAA,IACd,MAAM;AAAA,IACN,SAAS,QAAQ,QAAQ;AAAA,IACzB,YAAY;AAAA,MACV,GAAG;AAAA,MACH,gBAAgB;AAAA,MAChB,SAAS,OAAO,QAAQ,QAAQ,OAAO;AAAA,MACvC,aAAa,OAAO,kBAAkB;AAAA,IACxC;AAAA,EACF,CAAC;AAED,UAAQ,WAAW,KAAK,sBAAsB,YAAY,CAAC;AAE3D,UAAQ,OAAO,QAAQ,oCAAoC;AAAA,IACzD,EAAE,SAAS,QAAQ,QAAQ,KAAK;AAAA,IAChC;AAAA,EACF;AACA,UAAQ,OAAO,QAAQ,uCAAuC;AAAA,IAC5D,EAAE,SAAS,QAAQ,QAAQ,KAAK;AAAA,IAChC;AAAA,EACF;AAMA,QAAM,qBACJ,sBACA,QAAQ,eAAe,SAAS,IAAI,QAAQ,QAAQ;AACtD,MAAI,oBAAoB;AACtB,UAAM,wBAAwB,QAAQ,WAAW;AAAA,MAC/C,CAAC,UACC,MAAM,WACN,qBAAqB,QAAQ,QAAQ;AAAA,IACzC;AAIA,UAAM,QAAQ,UAAU,uBAAuB;AAAA,MAC7C,SAAS,QAAQ,QAAQ;AAAA,MACzB,YAAY,QAAQ,WAAW,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,MACpD,mBAAmB,QAAQ,kBAAkB,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,MAClE,cAAc,QAAQ,aAAa,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,MACxD,cAAc,QAAQ,iBAAiB,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,MAC5D,qBAAqB,QAAQ,wBAAwB;AAAA,QACnD,CAAC,MAAM,EAAE;AAAA,MACX;AAAA,MACA,UAAU;AAAA,QACR,YAAY,OAAO,QAAQ,eAAe,SAAS,CAAC;AAAA,QACpD,UAAU,OAAO,sBAAsB,MAAM;AAAA,MAC/C;AAAA,IACF,CAAC;AAED,YAAQ,OAAO,OAAO,MAAM;AAAA,MAC1B,SAAS;AAAA,MACT,KAAK,aACH,sBAAsB,SAAS,QAAQ,eAAe,SAAS,CACjE,KAAK,QAAQ,QAAQ,IAAI,iBACvB,QAAQ,eAAe,SAAS,CAClC,OAAO,sBAAsB,MAAM;AAAA,IACrC,CAAC;AAED,YAAQ,aAAa,QAAQ,WAAW;AAAA,MACtC,CAAC,UAAU,MAAM,SAAS,sBAAsB;AAAA,IAClD;AAEA,YAAQ,iBAAiB;AAEzB,YAAQ,QAAQ;AAAA,MACd,MAAM;AAAA,MACN,SAAS,QAAQ,QAAQ;AAAA,MACzB,YAAY;AAAA,QACV,GAAG;AAAA,QACH,gBAAgB,QAAQ,eAAe;AAAA,QACvC,SAAS,OAAO,QAAQ,QAAQ,OAAO;AAAA,QACvC,aAAa,OAAO,QAAQ,eAAe,MAAM;AAAA,MACnD;AAAA,IACF,CAAC;AAAA,EACH;AAEA,UAAQ,OAAO,OAAO,MAAM;AAAA,IAC1B,SAAS;AAAA,IACT,KAAK,qBAAqB,QAAQ,QAAQ,IAAI,WAAW,kBAAkB;AAAA,EAC7E,CAAC;AACH;AASO,IAAM,cAAc,OACzB,SACA,iBACG;AACH,QAAM,oBAAoBF,aAAY,aAAa,MAAM;AAEzD,UAAQ,OAAO,OAAO,KAAK;AAAA,IACzB,SAAS;AAAA,IACT,KAAK,oBAAoB,QAAQ,QAAQ,IAAI,qBAAqB,iBAAiB;AAAA,EACrF,CAAC;AAGD,QAAM,gBAAgB,QAAQ,WAAW;AAAA,IACvC,CAAC,UAAU,MAAM,SAAS;AAAA,EAC5B;AAGA,MAAI,cAAc;AAElB,SAAO,MAAM;AACX,UAAM,cAAc,oBAAoB;AAAA,MACtC,YAAY;AAAA,MACZ,gBAAgB,QAAQ;AAAA,IAC1B,CAAC;AAED,QAAI,YAAY,SAAS,YAAY,YAAY;AAC/C,YAAM,QAAQ,UAAU,mBAAmB;AAAA,QACzC,SAAS,QAAQ,QAAQ;AAAA,QACzB,WAAW,OAAO,YAAY,MAAM;AAAA,MACtC,CAAC;AAED,cAAQ,aAAa;AAErB,cAAQ,QAAQ;AAAA,QACd,MAAM;AAAA,QACN,SAAS,QAAQ,QAAQ;AAAA,QACzB,gBAAgB;AAAA,UACd,GAAG;AAAA,UACH,gBAAgB,YAAY;AAAA,UAC5B,SAAS,OAAO,QAAQ,QAAQ,OAAO;AAAA,UACvC,aAAa,OAAO,YAAY,MAAM;AAAA,QACxC;AAAA,MACF,CAAC;AAED,cAAQ,OAAO,OAAO,KAAK;AAAA,QACzB,SAAS;AAAA,QACT,KAAK,cACH,oBAAoB,YAAY,MAClC,oBAAoB,QAAQ,QAAQ,IAAI,gCACtC,YAAY,MACd;AAAA,MACF,CAAC;AAED;AAAA,IACF;AAEA,QAAI,cAAc,WAAW;AAAG;AAAA,SAC3B;AACH,oBAAc,MAAM,oBAAoB,SAAS;AAAA,QAC/C,WAAW,YAAY;AAAA,MACzB,CAAC;AACD,oBAAc,IAAI;AAAA,IACpB;AAAA,EACF;AAIA,QAAM,MAAM,8BAA8B,QAAQ,QAAQ,IAAI,kCAAkC,QAAQ,eAAe,MAAM;AAE7H,UAAQ,OAAO,OAAO,KAAK,EAAE,SAAS,YAAY,IAAI,CAAC;AACvD,UAAQ,aAAa,IAAI,MAAM,GAAG,CAAC;AAEnC,UAAQ,aAAa,CAAC;AACxB;AAEA,IAAM,iBAAiB,OACrB,SACA;AAAA,EACE;AAAA,EACA;AACF,MAIG;AACH,MAAI,QAAQ,kBAAkB,WAAW,GAAG;AAC1C,WAAO,WAAW;AAAA,MAChB;AAAA,MACA,YAAY,QAAQ,WAAW,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,IACtD,CAAC;AAAA,EACH,OAAO;AAEL,UAAM,qBAAqB,WAAW;AAAA,MACpC;AAAA,MACA,YAAY,QAAQ,kBAAkB,IAAI,CAAC,QAAQ;AAAA,QACjD,SAAS,GAAG,SAAS;AAAA,QACrB,QAAQ,CAAC,GAAG,SAAS,aAAa;AAAA,MACpC,EAAE;AAAA,IACJ,CAAC;AAED,UAAM,QAAQ,UAAU,8BAA8B;AAAA,MACpD,SAAS,QAAQ,QAAQ;AAAA,MACzB,MAAM;AAAA,IACR,CAAC;AAQD,UAAM,oBAAoB,MAAM,QAAQ;AAAA,MACtC,QAAQ,kBAAkB,IAAI,OAAO,YAAY;AAC/C,cAAM,WAAW,QAAQ,UAAU,yBAAyB;AAAA,UAC1D,SAAS,QAAQ,QAAQ;AAAA,UACzB,SAAS,QAAQ;AAAA,UACjB,WAAW,OAAO,QAAQ,UAAU;AAAA,UACpC,SAAS;AAAA,QACX,CAAC;AACD,cAAM,yBAAoC,CAAC;AAC3C,yBAAiB,SAAS,UAAU;AAClC,iCAAuB,KAAK,GAAG,KAAK;AAAA,QACtC;AACA,eAAO;AAAA,UACL,SAAS;AAAA,UACT,QAAQ,QAAQ,SAAS;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,WAAW;AAAA,MAChB;AAAA,MACA,YAAY;AAAA,QACV,GAAG,QAAQ,WAAW,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,QAC3C,GAAG,kBAAkB,OAAO,CAAC,MAAM,EAAE,QAAQ,WAAW,CAAC;AAAA,MAC3D;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAM,uBAAuB,OAC3B,SACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,MAKG;AACH,MAAI,QAAQ,wBAAwB,WAAW,GAAG;AAChD,WAAO,iBAAiB;AAAA,MACtB;AAAA,MACA,kBAAkB,QAAQ,iBAAiB,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,IAClE,CAAC;AAAA,EACH,OAAO;AAEL,UAAM,qBAAqB,WAAW;AAAA,MACpC;AAAA,MACA,YAAY,QAAQ,kBAAkB,IAAI,CAAC,QAAQ;AAAA,QACjD,SAAS,GAAG,SAAS;AAAA,QACrB,QAAQ,CAAC,GAAG,SAAS,aAAa;AAAA,MACpC,EAAE;AAAA,IACJ,CAAC;AAED,UAAM,QAAQ,UAAU,8BAA8B;AAAA,MACpD,SAAS,QAAQ,QAAQ;AAAA,MACzB,MAAM;AAAA,IACR,CAAC;AAQD,UAAM,sBAAsB,MAAM,QAAQ;AAAA,MACxC,QAAQ,wBAAwB,IAAI,OAAO,YAAY;AACrD,cAAM,WAAW,QAAQ,UAAU,yBAAyB;AAAA,UAC1D,SAAS,QAAQ,QAAQ;AAAA,UACzB,SAAS,QAAQ;AAAA,UACjB,WAAW,OAAO,QAAQ,UAAU;AAAA,UACpC,SAAS;AAAA,QACX,CAAC;AACD,cAAM,yBAAoC,CAAC;AAC3C,yBAAiB,SAAS,UAAU;AAClC,iCAAuB,KAAK,GAAG,KAAK;AAAA,QACtC;AACA,eAAO;AAAA,UACL,WAAW;AAAA,UACX,aAAa,QAAQ,SAAS;AAAA,QAChC;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,iBAAiB;AAAA,MACtB;AAAA,MACA,kBAAkB;AAAA,QAChB,GAAG,QAAQ,iBAAiB,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,QACjD,GAAG,oBAAoB,OAAO,CAAC,MAAM,EAAE,UAAU,WAAW,CAAC;AAAA,MAC/D;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAM,sBAAsB,CAAC;AAAA,EAC3B;AAAA,EACA;AACF,MAAsD;AACpD,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT;AAAO,WAAO,WAAW,WAAW,SAAS,CAAC;AAChD;;;AIpxBA,IAAMG,WAAU;AAAA,EACd,OAAAC;AAAA,EACA,MAAAC;AACF;AAEO,IAAM,4BAA4B,OAAOC,SAAQH,QAAO;;;ACN/D;AAAA,EAEE;AAAA,OACK;AACP;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAIA,eAAAI;AAAA,EACA,SAAAC;AAAA,OACK;AAoBP,IAAMC,eAAc;AACpB,IAAMC,iBAAgB;AAKf,IAAM,qBAAqB,CAAC;AAAA,EACjC;AAAA,EACA;AACF,MAGoB;AAClB,QAAM,eAAe,OAAO,YAAgD;AAC1E,aAAS,IAAI,GAAG,KAAKD,cAAa,KAAK;AACrC,UAAI;AACF,cAAM,YAAY,WAAW;AAC7B,cAAM,WAAW,MAAM,QAAQ,UAAU,QAAQ,OAAO;AACxD,eAAO,QAAQ,4BAA4B;AAAA,UACzC,EAAE,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,KAAK;AAAA,UAChD,UAAU;AAAA,QACZ;AAEA,eAAO;AAAA,MACT,SAAS,QAAQ;AACf,cAAM,QAAQ;AAEd,YACE,QAAQ,WAAW,iBACnBE,OAAM,QAAQ,OAAO,CAAC,EAAE,SAAS,KACjCA,OAAM,QAAQ,OAAO,CAAC,EAAE,OAAO,GAC/B;AACA,gBAAM,uBAAuB,mBAAmB;AAAA,YAC9C,QAAQ,QAAQ;AAAA,YAChB;AAAA,UACF,CAAC;AAED,cAAI,qBAAqB,gBAAgB;AAAO,kBAAM;AAEtD,iBAAO,OAAO,MAAM;AAAA,YAClB,SAAS;AAAA,YACT,KAAK,gCACH,QAAQ,IACV,6BAA6B,qBAAqB,OAC/C;AAAA,cACC,CAAC,EAAE,WAAW,QAAQ,MACpB,IAAIC,aAAY,SAAS,EAAE,SAAS,CAAC,KAAKA;AAAA,gBACxC;AAAA,cACF,EAAE,SAAS,CAAC;AAAA,YAChB,EACC,KAAK,IAAI,CAAC;AAAA,UACf,CAAC;AAED,gBAAM,OAAiB,CAAC;AACxB,qBAAW,EAAE,WAAW,QAAQ,KAAK,qBAAqB,QAAQ;AAChE,kBAAM,QAAQ,MAAM,aAAa;AAAA,cAC/B,QAAQ;AAAA,cACR,QAAQ;AAAA,gBACN;AAAA,kBACE,QAAQ,QAAQ,OAAQ,CAAC,EAAE;AAAA,kBAC3B,SAAS,QAAQ,OAAQ,CAAC,EAAE;AAAA,kBAC5B;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF,CAAC;AAED,iBAAK,KAAK,GAAI,KAAkB;AAAA,UAClC;AAEA,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,KAAK,MAAM,OAAO;AAChC,iBAAO,OAAO,KAAK;AAAA,YACjB,SAAS;AAAA,YACT,KAAK,WAAW,QAAQ,MAAM,2CAA2C,MAAM,OAAO;AAAA,UACxF,CAAC;AACD,gBAAM;AAAA,QACR;AAEA,YAAI,MAAMH,cAAa;AACrB,iBAAO,OAAO,KAAK;AAAA,YACjB,SAAS;AAAA,YACT,KAAK,WAAW,QAAQ,MAAM,uBAC5B,IAAI,CACN,yBAAyB,MAAM,OAAO;AAAA,UACxC,CAAC;AACD,gBAAM;AAAA,QACR;AAEA,cAAM,WAAWC,iBAAgB,KAAK;AACtC,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,WAAW,QAAQ,MAAM,iCAAiC,QAAQ,yBAAyB,MAAM,OAAO;AAAA,QAC/G,CAAC;AACD,cAAM,KAAK,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,eAMF,YAAY;AAAA,IACd,WAAW,QAAQ;AAAA,IACnB,aAAa,KAAK,KAAK,QAAQ,uBAAuB,CAAC;AAAA,IACvD,cAAc;AAAA,IACd,SAAS;AAAA,IACT,QAAQ,OAAO,SAGT;AACJ,aAAO,QAAQ,uBAAuB;AAAA,QACpC,EAAE,QAAQ,KAAK,QAAQ,QAAQ,SAAS,QAAQ,KAAK;AAAA,QACrD,KAAK,aAAa;AAAA,MACpB;AAEA,aAAO,MAAM,aAAa,KAAK,OAAO;AAAA,IACxC;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL,GAAG;AAAA,IACH,SAAS,CACP,WACG;AACH,YAAM,eAAe,WAAW;AAEhC,aAAO,aAAa,IAAI,EAAE,SAAS,QAAQ,aAAa,CAAC;AAAA,IAC3D;AAAA,EACF;AACF;AAKA,SAAS,YAAY,OAAc;AACjC,MAAI,UAAU,SAAS,OAAO,MAAM,SAAS,UAAU;AACrD,QAAI,MAAM,SAAS;AAAI,aAAO;AAC9B,QAAI,MAAM,SAAS,qBAAqB;AAAM,aAAO;AACrD,QAAI,MAAM,SAAS,sBAAsB;AAAM,aAAO;AACtD,QAAI,MAAM,SAAS,iBAAiB;AAAM,aAAO;AACjD,WAAO;AAAA,EACT;AACA,MAAI,iBAAiB;AAAoB,WAAO;AAChD,MAAI,iBAAiB,oBAAoB,MAAM,QAAQ;AAErD,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AAEjC,QAAI,MAAM,WAAW;AAAK,aAAO;AACjC,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;AC5LA,SAAyB,eAAAG,cAAa,eAAAC,oBAAmB;;;AChBzD,SAAS,QAAQ,eAAAC,cAAa,kBAAkB;AAEhD,IAAM,gBAAgB;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,kBAAkB,CAAC;AAAA,EAC9B;AAAA,EACA;AACF,MAGiB;AACf,SAAO,CAAC,EAAE,MAAM,MAAM;AACpB,UAAM,IAAI,OAAO;AAAA,MACf,MAAM,QAAQ,EAAE,QAAQ,OAAO,GAAG;AAChC,cAAM,OAAO,EAAE,QAAQ,OAAO;AAE9B,YAAI,cAAc,SAAS,MAAM,GAAG;AAClC,cAAI,UAAkB;AACtB,cAAI,cAA8B;AAElC,cAAI,WAAW,YAAY;AACzB,kBAAM,CAAC,EAAE,MAAM,GAAG,GAAG,YAAY,IAAI;AAKrC,sBAAU,GAAG,MAAgB,IAAI,YAAY,EAAE,CAAC,IAAI;AAAA,cAClD;AAAA,YACF,CAAC;AACD,0BAAc;AAAA,UAChB,WAAW,WAAW,kBAAkB;AACtC,kBAAM,CAAC,SAAS,YAAY,IAAI;AAEhC,sBAAU,GAAG,MAAgB,IAAI,YAAY,OAAO,CAAC;AACrD,0BAAc;AAAA,UAChB,WAAW,WAAW,eAAe;AACnC,kBAAM,CAAC,SAAS,YAAY,IAAI;AAEhC,sBAAU,GAAG,MAAgB,IAAI,YAAY,OAAO,CAAC;AACrD,0BAAc;AAAA,UAChB,WAAW,WAAW,oBAAoB;AACxC,kBAAM,CAAC,SAAS,MAAM,YAAY,IAAI;AAMtC,sBAAU,GAAG,MAAgB,IAAI;AAAA,cAC/B;AAAA,YACF,CAAC,IAAI,YAAY,IAAI,CAAC;AACtB,0BAAc;AAAA,UAChB;AAEA,gBAAM,oBACJ,gBAAgB,WAAW,aAAaA,aAAY,WAAW;AAEjE,gBAAM,eAAe,MAAM,UAAU,oBAAoB;AAAA,YACvD,aAAa;AAAA,YACb,SAAS,MAAO;AAAA,YAChB;AAAA,UACF,CAAC;AAED,cAAI,cAAc;AAAQ,mBAAO,aAAa;AAAA,eACzC;AACH,kBAAM,WAAW,MAAM,aAAa,QAAQ,IAAI;AAChD,kBAAM,UAAU,uBAAuB;AAAA,cACrC,aAAa;AAAA,cACb,SAAS,MAAO;AAAA,cAChB;AAAA,cACA,QAAQ;AAAA,YACV,CAAC;AACD,mBAAO;AAAA,UACT;AAAA,QACF,OAAO;AACL,iBAAO,aAAa,QAAQ,IAAI;AAAA,QAClC;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO,EAAE,EAAE,OAAO,YAAY,EAAE,CAAC;AAAA,EACnC;AACF;;;ADzBA,IAAM,iCAAiC;AAEhC,IAAMC,UAAS,OAAO;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAQwB;AACtB,QAAM,aAAa,QAAQ,OAA8B,CAAC,KAAK,QAAQ;AACrE,QAAI,IAAI,EAAE,IAAI;AACd,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAEL,QAAM,sBAAsB,CAAC,sBAAyC;AACpE,YAAQ,kBAAkB,MAAM;AAAA,MAC9B,KAAK,cAAc;AACjB,oBAAY,gBAAgB;AAAA,UAC1B,CAAC,OAAO,GAAG,QAAQ,YAAY,kBAAkB;AAAA,QACnD,EAAG,SAAU,aAAa,kBAAkB;AAI5C,cAAM,gBAAgB;AAAA,UACpB,GAAG,YAAY,gBACZ,OAAO,CAAC,OAAO,GAAG,aAAa,MAAS,EACxC,IAAI,CAAC,OAAO,GAAG,SAAU,UAAU;AAAA,QACxC;AAIA,YAAI,CAAC,wBAAwB,eAAe,YAAY,UAAU;AAChE;AAIF,cAAM,iBAAiB,EAAE,GAAG,YAAY,WAAW;AACnD,cAAM,eAAe,EAAE,GAAG,cAAc;AAExC,oBAAY,aAAa;AAEzB,wBAAgB;AAAA,UACd,MAAM;AAAA,UACN;AAAA,UACA;AAAA,QACF,CAAC;AAED;AAAA,MACF;AAAA,MAEA,KAAK,SAAS;AACZ,oBAAY,gBAAgB;AAAA,UAC1B,CAAC,OAAO,GAAG,QAAQ,YAAY,kBAAkB;AAAA,QACnD,EAAG,SAAU,aAAa,kBAAkB;AAE5C,YACE;AAAA,UACE,YAAY;AAAA,UACZ,kBAAkB;AAAA,QACpB,GACA;AACA,sBAAY,aAAa,kBAAkB;AAAA,QAC7C;AAEA,wBAAgB,iBAAiB;AAEjC;AAAA,MACF;AAAA,MAEA,KAAK,YAAY;AACf,oBAAY,gBAAgB;AAAA,UAC1B,CAAC,OAAO,GAAG,QAAQ,YAAY,kBAAkB;AAAA,QACnD,EAAG,SAAU,sBAAsB,kBAAkB;AAErD,cAAM,yBAAyB;AAAA,UAC7B,GAAG,YAAY,gBACZ,OAAO,CAAC,OAAO,GAAG,aAAa,MAAS,EACxC,IAAI,CAAC,OAAO,GAAG,SAAU,mBAAmB;AAAA,QACjD;AAEA,YACE;AAAA,UACE;AAAA,UACA,YAAY;AAAA,QACd,GACA;AACA,0BAAgB;AAAA,YACd,MAAM;AAAA,YACN,YAAY;AAAA,UACd,CAAC;AACD,sBAAY,sBAAsB;AAAA,QACpC;AAEA;AAAA,MACF;AAAA,MAEA;AACE,cAAM,iBAAiB;AAAA,IAC3B;AAAA,EACF;AAEA,QAAM,kBAA8C,MAAM,QAAQ;AAAA,IAChE,SAAS,IAAI,OAAO,YAAY;AAC9B,YAAM,iBAAiB,QAAQ;AAAA,QAC7B,CAAC,WAAW,OAAO,gBAAgB,QAAQ;AAAA,MAC7C;AAEA,YAAM,eAAe,mBAAmB;AAAA,QACtC;AAAA,QACA;AAAA,MACF,CAAC;AAED,YAAM,CAAC,EAAE,aAAa,eAAe,GAAG,aAAa,IACnD,MAAM,QAAQ,IAAI;AAAA,QAChB,4BAA4B;AAAA,UAC1B;AAAA,UACA;AAAA,QACF,CAAC;AAAA,QACD,aAAa,QAAQ,EAAE,QAAQ,cAAc,CAAC,EAAE,KAAKC,YAAW;AAAA,MAClE,CAAC;AAEH,UAAI,QAAQ,YAAY,eAAe;AACrC,eAAO,OAAO,KAAK;AAAA,UACjB,SAAS;AAAA,UACT,KAAK,oBAAoB,aAAa,yCAAyC,QAAQ,OAAO,kBAAkB,QAAQ,IAAI;AAAA,QAC9H,CAAC;AAAA,MACH;AAEA,YAAM,iBAAiB,IAAI,sBAAsB;AAAA,QAC/C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS;AAAA,MACX,CAAC;AAED,YAAM,eAAe,MAAM;AAAA,QACzB,mBAAmBA,aAAY,YAAY,MAAM;AAAA,QACjD,sBAAsBA,aAAY,eAAe,MAAM;AAAA,MACzD,CAAC;AAED,YAAM,6BAAyC;AAAA,QAC7C,GAAG;AAAA,QACH,gBAAgBA,aAAY,eAAe,SAAS;AAAA,QACpD,SAAS,OAAO,QAAQ,OAAO;AAAA,QAC/B,aAAaC,aAAY,eAAe,MAAM;AAAA,MAChD;AAEA,YAAM,kBAAkB,mBAAmB;AAAA,QACzC,SAAS;AAAA,QACT;AAAA,MACF,CAAC;AAED,UAAI,iBAAiB;AACnB,eAAO;AAAA,UACL;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,iBAAiB,gBAAgB,EAAE,cAAc,UAAU,CAAC;AAAA,UAC5D;AAAA,UACA,UAAU;AAAA,UACV,YAAY;AAAA,YACV;AAAA,YACA,YAAY;AAAA,YACZ,0BAA0B;AAAA,UAC5B;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM,eAAe,0BAA0B;AAAA,UAC7C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,SAAS;AAAA,UACT;AAAA,QACF,CAAC;AAED,eAAO;AAAA,UACL;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,iBAAiB,gBAAgB,EAAE,cAAc,UAAU,CAAC;AAAA,UAC5D;AAAA,UACA,UAAU;AAAA,YACR;AAAA,YACA,YAAY;AAAA,YACZ,qBAAqB;AAAA,YACrB;AAAA,UACF;AAAA,UACA,YAAY;AAAA,YACV;AAAA,YACA,YAAY;AAAA,YACZ,0BAA0B;AAAA,UAC5B;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAGA,aAAW,kBAAkB,iBAAiB;AAC5C,mBAAe,WAAW,eAAe;AAAA,MACvC;AAAA,MACA,CAAC,eAA2B;AAC1B,uBAAe,WAAW,aAAa;AAEvC,eAAO,OAAO,MAAM;AAAA,UAClB,SAAS;AAAA,UACT,KAAK,wCAAwC,WAAW,cAAc,YAAY,WAAW,OAAO,gBAAgB,WAAW,WAAW;AAAA,QAC5I,CAAC;AAAA,MACH;AAAA,IACF;AACA,mBAAe,WAAW,eAAe,GAAG,gBAAgB,MAAM;AAChE,qBAAe,WAAW,2BAA2B;AAErD,UACE,gBAAgB;AAAA,QACd,CAAC,EAAE,WAAW,MAAM,WAAW;AAAA,MACjC,GACA;AACA,eAAO,OAAO,KAAK;AAAA,UACjB,SAAS;AAAA,UACT,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,cAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,qBAAqB;AAAA,MACnB,GAAG,gBAAgB,IAAI,CAAC,OAAO,GAAG,0BAA0B;AAAA,IAC9D;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAKO,IAAM,kBAAkB,CAAC,gBAAyB;AACvD,aAAW,EAAE,WAAW,KAAK,YAAY,iBAAiB;AACxD,eAAW,eAAe,MAAM;AAAA,EAClC;AACF;AAMO,IAAM,0BAA0B,iBACrC,aAC0E;AAC1E,SAAO,MAAM;AACX,QAAI,YAAY;AAAU;AAE1B,UAAM,aAAa,YAAY,gBAAgB;AAAA,MAC7C,CAAC,OAAO,GAAG,WAAW;AAAA,IACxB;AAEA,QAAI,YAAY;AACd,YAAM,qBAAqB;AAAA,QACzB,GAAG,YAAY,gBAAgB;AAAA,UAC7B,CAAC,EAAE,2BAA2B,MAAM;AAAA,QACtC;AAAA,MACF;AAIA,UAAI,CAAC,wBAAwB,oBAAoB,YAAY,UAAU;AACrE;AAEF,YAAM;AAAA,QACJ,gBAAgB,YAAY;AAAA,QAC5B,cAAc;AAAA,MAChB;AAEA,kBAAY,aAAa;AAEzB;AAAA,IACF,OAAO;AACL,YAAM,KAAK,8BAA8B;AAEzC,YAAM,qBAAqB,YAAY,gBAAgB;AAAA,QACrD,CAAC,OAAO,GAAG,WAAW;AAAA,MACxB;AAIA,UAAI,mBAAmB,KAAK,CAAC,OAAO,OAAO,MAAS,GAAG;AACrD;AAAA,MACF;AAEA,YAAM,gBAAgB;AAAA,QACpB,GAAI;AAAA,MACN;AAGA,UAAI,CAAC,wBAAwB,eAAe,YAAY,UAAU,GAAG;AACnE;AAAA,MACF;AAEA,YAAM;AAAA,QACJ,gBAAgB,YAAY;AAAA,QAC5B,cAAc;AAAA,MAChB;AAEA,kBAAY,aAAa;AAAA,IAC3B;AAAA,EACF;AACF;AAKO,IAAM,gBAAgB,CAAC,gBAAyB;AACrD,aAAW,EAAE,UAAU,QAAQ,KAAK,YAAY,iBAAiB;AAC/D,QAAI,aAAa,QAAW;AAC1B,kBAAY,OAAO,OAAO,MAAM;AAAA,QAC9B,SAAS;AAAA,QACT,KAAK,kCAAkC,QAAQ,IAAI;AAAA,MACrD,CAAC;AACD,kBAAY,OAAO,QAAQ,6BAA6B;AAAA,QACtD,EAAE,SAAS,QAAQ,KAAK;AAAA,QACxB;AAAA,MACF;AAAA,IACF,OAAO;AACL,eAAS,aAAa,MAAM;AAC5B,kBAAY,OAAO,QAAQ,6BAA6B;AAAA,QACtD,EAAE,SAAS,QAAQ,KAAK;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAMC,QAAO,OAAO,gBAAyB;AAClD,cAAY,WAAW;AAEvB,QAAM,cAA+B,CAAC;AAEtC,aAAW,EAAE,YAAY,SAAS,KAAK,YAAY,iBAAiB;AAClE,eAAW,eAAe,KAAK;AAC/B,QAAI,aAAa;AAAW,kBAAY,KAAK,SAAS,aAAa,KAAK,CAAC;AAAA,EAC3E;AAEA,QAAM,QAAQ,IAAI,WAAW;AAC/B;AAEO,IAAM,qBAAqB,CAAC,aAAsB,YAAqB;AAC5E,QAAM,EAAE,aAAa,IAAI,YAAY,gBAAgB;AAAA,IACnD,CAAC,OAAO,GAAG,QAAQ,YAAY,QAAQ;AAAA,EACzC;AACA,SAAO,gBAAgB,EAAE,cAAc,WAAW,YAAY,UAAU,CAAC;AAC3E;AAEA,IAAM,8BAA8B,OAAO;AAAA,EACzC;AAAA,EACA;AACF,MAAwD;AACtD,QAAM,cAAc,MAAM;AAAA,IACxB,EAAE,aAAa;AAAA,IACf,EAAE,UAAU,SAAS;AAAA,EACvB;AAEA,QAAM,uBAAuB,KAAK;AAAA,IAChC;AAAA,IACAF,aAAY,YAAY,MAAM,IAAI,QAAQ;AAAA,EAC5C;AAEA,QAAM,iBAAiB,MAAM;AAAA,IAC3B,EAAE,aAAa;AAAA,IACf;AAAA,MACE,aAAa;AAAA,IACf;AAAA,EACF;AAEA,SAAO,EAAE,aAAa,eAAe;AACvC;AAEA,IAAM,qBAAqB,CAAC;AAAA,EAC1B;AAAA,EACA;AACF,MAGM;AAIJ,QAAM,YAAY,QAAQ,IAAI,CAAC,MAAM,EAAE,QAAQ;AAC/C,SAAO,UAAU;AAAA,IACf,CAAC,MAAM,MAAM,UAAa,KAAKA,aAAY,eAAe,MAAM;AAAA,EAClE;AACF;;;AVjcA,IAAMG,WAAU;AAAA,EACd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,MAAAC;AACF;AAEO,IAAM,oBAAoB,OAAOC,SAAQF,QAAO;AA4FhD,IAAM,wBAAwB,CACnC,EAAE,aAAa,GACf;AAAA,EACE;AAAA,EACA;AACF,MAIA,aACG,QAAQ;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,IACN,OAAO,gBAAgB,WACnBG,aAAY,WAAW,IACvB,eAAe;AAAA,IACnB;AAAA,EACF;AACF,CAAC,EACA,KAAK,CAAC,WAAW;AAChB,MAAI,CAAC;AACH,UAAM,IAAIC,oBAAmB;AAAA,MAC3B,aAAc,eAAe;AAAA,IAC/B,CAAC;AACH,SAAO;AACT,CAAC;AAKE,IAAM,sBAAsB,CACjC,EAAE,aAAa,GACf,EAAE,UAAU,MAEZ,aACG,QAAQ;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ,CAAC,WAAW,IAAI;AAC1B,CAAC,EACA,KAAK,CAAC,WAAW;AAChB,MAAI,CAAC;AACH,UAAM,IAAIA,oBAAmB;AAAA,MAC3B;AAAA,IACF,CAAC;AACH,SAAO;AACT,CAAC;AAME,IAAM,eAAe,OAC1B,EAAE,aAAa,GACf,WAOuB;AACvB,MAAI,eAAe,QAAQ;AACzB,WAAO,aACJ,QAAQ;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,QACN;AAAA,UACE,WAAW,OAAO;AAAA,UAElB,QAAQ,OAAO;AAAA,UACf,SAAS,OAAO,UACZ,MAAM,QAAQ,OAAO,OAAO,IAC1B,OAAO,QAAQ,IAAI,CAAC,MAAM,YAAY,CAAC,CAAC,IACxC,YAAY,OAAO,OAAO,IAC5B;AAAA,QACN;AAAA,MACF;AAAA,IACF,CAAC,EACA,KAAK,CAAC,MAAM,CAAc;AAAA,EAC/B;AAEA,SAAO,aACJ,QAAQ;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,MACN;AAAA,QACE,WACE,OAAO,OAAO,cAAc,WACxBD,aAAY,OAAO,SAAS,IAC5B,OAAO;AAAA,QACb,SACE,OAAO,OAAO,YAAY,WACtBA,aAAY,OAAO,OAAO,IAC1B,OAAO;AAAA,QAEb,QAAQ,OAAO;AAAA,QACf,SAAS,OAAO,UACZ,MAAM,QAAQ,OAAO,OAAO,IAC1B,OAAO,QAAQ,IAAI,CAAC,MAAM,YAAY,CAAC,CAAC,IACxC,YAAY,OAAO,OAAO,IAC5B;AAAA,MACN;AAAA,IACF;AAAA,EACF,CAAC,EACA,KAAK,CAAC,MAAM,CAAc;AAC/B;AAKO,IAAM,6BAA6B,CACxC,EAAE,aAAa,GACf,EAAE,MAAAE,MAAK,MAEP,aACG,QAAQ;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ,CAACA,KAAI;AACf,CAAC,EACA,KAAK,CAAC,YAAY;AACjB,MAAI,CAAC;AACH,UAAM,IAAI,gCAAgC;AAAA,MACxC,MAAAA;AAAA,IACF,CAAC;AACH,SAAO;AACT,CAAC;AAOE,IAAM,gBAAgB,CAC3B,EAAE,aAAa,GACf,WAOA,aACG,QAAQ;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,IACN;AAAA,MACE,WACE,OAAO,OAAO,cAAc,WACxBF,aAAY,OAAO,SAAS,IAC5B,OAAO;AAAA,MACb,SACE,OAAO,OAAO,YAAY,WACtBA,aAAY,OAAO,OAAO,IAC1B,OAAO;AAAA,MACb,aAAa,OAAO,cAChB,OAAO,YAAY,IAAI,CAAC,MAAM,YAAY,CAAC,CAAC,IAC5C;AAAA,MACJ,WAAW,OAAO,YACd,OAAO,UAAU,IAAI,CAAC,MAAM,YAAY,CAAC,CAAC,IAC1C;AAAA,IACN;AAAA,EACF;AACF,CAAQ,EACP,KAAK,CAAC,WAAW,MAAgC;AAO/C,IAAM,eAAe,CAC1B,EAAE,aAAa,GACf,WAIA,aACG,QAAQ;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,IACN,OAAO,OAAO,gBAAgB,WAC1BA,aAAY,OAAO,WAAW,IAC9B,OAAO;AAAA,EACb;AACF,CAAQ,EACP,KAAK,CAAC,WAAW,MAAgC;;;AY7QtD,eAAsB,IAAI;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,SAAO,UAAU,EAAE,GAAG,OAAO,SAAS,GAAG,cAAc;AAEvD,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI,eAAe,SAAS,UAAU;AACpC,UAAM,EAAE,UAAU,IAAI;AACtB,eAAW,IAAI,sBAAsB,EAAE,QAAQ,UAAU,CAAC;AAC1D,KAAC,eAAe,iBAAiB,IAAI,MAAM,SACxC,MAAM,EAAE,QAAQ,QAAQ,CAAC,EACzB,KAAK,CAAC,EAAE,eAAAG,gBAAe,WAAW,MAAM,CAACA,gBAAe,UAAU,CAAC;AAEtE,gBAAY,IAAI,gBAAgB,EAAE,IAAI,SAAS,OAAO,CAAC;AAAA,EACzD,OAAO;AACL,UAAM,EAAE,YAAY,QAAQ,eAAe,cAAc,IAAI;AAC7D,eAAW,IAAI,wBAAwB;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AACD,KAAC,eAAe,iBAAiB,IAAI,MAAM,SACxC,MAAM,EAAE,QAAQ,QAAQ,CAAC,EACzB,KAAK,CAAC,EAAE,eAAAA,gBAAe,WAAW,MAAM,CAACA,gBAAe,UAAU,CAAC;AAEtE,gBAAY,IAAI,kBAAkB,EAAE,IAAI,SAAS,OAAO,CAAC;AAAA,EAC3D;AAEA,QAAM,gBAAgB,iBAAiB;AAAA,IACrC,MAAM,SAAS;AAAA,IACf;AAAA,IACA;AAAA,IACA,IAAI,SAAS;AAAA,EACf,CAAC;AAED,QAAM,SAAS,MAAMC,cAAa,EAAE,QAAQ,eAAe,cAAc,CAAC;AAI1E,QAAM,SAAS,iBAAiB;AAEhC,aAAW,EAAE,QAAQ,cAAc,CAAC;AAGpC,QAAM,cAAc,MAAM,kBAAkB;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA,IAGA,iBAAiB,CAAC,kBAAkB;AAClC,oBAAc,IAAI,aAAa;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,eAAe,OACnB,QACA,wBACG;AACH,QAAI,wBAAwB,QAAW;AACrC,sBAAgB,0BAA0B,mBAAmB;AAAA,IAC/D;AAEA,QAAI,OAAO,WAAW;AAAG,aAAO,EAAE,QAAQ,UAAU;AAEpD,WAAO,MAAM,gBAAgB,cAAc,EAAE,OAAO,CAAC;AAAA,EACvD;AAEA,QAAMC,eAAc,OAAO,mBAA+B;AACxD,UAAM,SAAS,OAAO;AAAA,MACpB,YAAY;AAAA,MACZ;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,iBAAiB,OAAO,eAA2B;AACvD,UAAM,SAAS,0BAA0B,EAAE,WAAW,CAAC;AAAA,EACzD;AAEA,QAAM,gBAAgB,YAAY;AAAA,IAChC,cAAc;AAAA,IACd,SAAS;AAAA,IACT,aAAa;AAAA,IACb,QAAQ,OAAO,UAAyB;AACtC,cAAQ,MAAM,MAAM;AAAA,QAClB,KAAK,aAAa;AAChB,gBAAM,sBAAsB,MAAM,UAAU,uBAAuB;AAAA,YACjE;AAAA,YACA,gBAAgB,MAAM;AAAA,YACtB,cAAc,MAAM;AAAA,UACtB,CAAC;AACD,2BAAiB,aAAa,UAAU,UAAU;AAAA,YAChD;AAAA,YACA,gBAAgB,MAAM;AAAA,YACtB,cAAc,MAAM;AAAA,YACpB,OAAO;AAAA,UACT,CAAC,GAAG;AACF,kBAAM,SAAS,MAAM;AAAA,cACnB,aAAa,aAAa,SAAS;AAAA,cACnC;AAAA,YACF;AACA,gBAAI,OAAO,WAAW;AAAS,gCAAkB,OAAO,KAAK;AAAA,UAC/D;AAEA;AAAA,QACF;AAAA,QACA,KAAK;AACH,gBAAMA,aAAY,MAAM,cAAc;AACtC;AAAA,QAEF,KAAK;AACH,gBAAM,eAAe,MAAM,UAAU;AACrC;AAAA,QAEF;AACE,gBAAM,KAAK;AAAA,MACf;AAAA,IACF;AAAA,EACF,CAAC;AAED,MAAI,gBAA+B;AAAA,IACjC,GAAG,iBAAiB;AAAA,MAClB,MAAM,SAAS;AAAA,MACf;AAAA,MACA;AAAA,MACA,IAAI,SAAS;AAAA,IACf,CAAC;AAAA,IACD,GAAG,mBAAmB;AAAA,MACpB,MAAM,SAAS;AAAA,MACf;AAAA,MACA;AAAA,MACA,IAAI,SAAS;AAAA,IACf,CAAC;AAAA,EACH;AAEA,QAAM,kBAAkB,sBAAsB;AAAA,IAC5C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAMC,SAAQ,YAAY;AACxB,gBAAY,gBAAgB;AAG5B,QAAI,kBAAkB,mBAAmB,cAAc,GAAG;AACxD,YAAM,SAAS,MAAM,gBAAgB,mBAAmB;AAAA,QACtD;AAAA,QACA;AAAA,MACF,CAAC;AACD,UAAI,OAAO,WAAW,UAAU;AAC9B;AAAA,MACF,WAAW,OAAO,WAAW,SAAS;AACpC,0BAAkB,OAAO,KAAK;AAC9B;AAAA,MACF;AAAA,IACF;AAGA,qBAAiB;AAAA,MACf;AAAA,MACA;AAAA,IACF,KAAK,YAAY,wBAAwB,GAAG;AAC1C,YAAM,sBAAsB,MAAM,UAAU,uBAAuB;AAAA,QACjE;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAED,uBAAiB,aAAa,UAAU,UAAU;AAAA,QAChD;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO;AAAA,MACT,CAAC,GAAG;AACF,cAAM,SAAS,MAAM;AAAA,UACnB,aAAa,aAAa,SAAS;AAAA,UACnC;AAAA,QACF;AAEA,YAAI,OAAO,WAAW,UAAU;AAC9B;AAAA,QACF,WAAW,OAAO,WAAW,SAAS;AACpC,4BAAkB,OAAO,KAAK;AAC9B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,WAAO,OAAO,KAAK;AAAA,MACjB,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAED,QAAI,SAAS,SAAS,YAAY;AAChC,YAAM,SAAS,QAAQ;AAAA,IACzB;AACA,UAAM,eAAe,YAAY,mBAAmB;AAEpD,UAAM,SAAS,cAAc,EAAE,OAAO,CAAC;AAEvC,WAAO,WAAW;AAClB,WAAO,OAAO,KAAK;AAAA,MACjB,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAED,oBAAgB;AAAA,MACd,GAAG,iBAAiB;AAAA,QAClB,MAAM,SAAS;AAAA,QACf;AAAA,QACA;AAAA,QACA,IAAI,SAAS;AAAA,MACf,CAAC;AAAA,MACD,GAAG,iBAAiB;AAAA,QAClB,MAAM,SAAS;AAAA,QACf;AAAA,QACA;AAAA,QACA,IAAI,SAAS;AAAA,MACf,CAAC;AAAA,IACH;AAEA,oBAAgB,oBAAoB,EAAE,eAAe,OAAO,CAAC;AAE7D,gBAAY,cAAc;AAAA,EAC5B;AAEA,QAAM,eAAeA,OAAM;AAE3B,SAAO,YAAY;AACjB,UAAM,gBAAgB,OAAO,KAAK;AAClC,oBAAgB,KAAK;AACrB,UAAM,YAAY,KAAK;AACvB,kBAAc,MAAM;AACpB,kBAAc,MAAM;AACpB,UAAM,cAAc,OAAO;AAC3B,UAAM;AACN,UAAM;AACN,UAAM,SAAS,KAAK;AAAA,EACtB;AACF;;;A1D/SA,eAAsB,IAAI,EAAE,WAAW,GAA+B;AACpE,QAAM,UAAU,aAAa,EAAE,WAAW,CAAC;AAE3C,QAAM,SAAS,aAAa,EAAE,OAAO,QAAQ,SAAS,CAAC;AAEvD,QAAM,CAAC,OAAO,OAAO,MAAM,IAAI,QAAQ,SAAS,KAAK,MAAM,GAAG,EAAE,IAAI,MAAM;AAC1E,MAAI,QAAQ,MAAO,UAAU,MAAM,QAAQ,IAAK;AAC9C,WAAO,MAAM;AAAA,MACX,SAAS;AAAA,MACT,KAAK,uDAAuD,KAAK,IAAI,KAAK;AAAA,IAC5E,CAAC;AACD,UAAM,OAAO,KAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,MAAI,CAACC,YAAWC,MAAK,KAAK,QAAQ,SAAS,YAAY,CAAC,GAAG;AACzD,WAAO,KAAK;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,IACP,CAAC;AAAA,EACH;AAEA,QAAM,gBAAgBA,MAAK,SAAS,QAAQ,SAAS,QAAQ,UAAU;AACvE,SAAO,MAAM;AAAA,IACX,SAAS;AAAA,IACT,KAAK,8BAA8B,aAAa;AAAA,EAClD,CAAC;AAED,QAAM,UAAU,IAAI,eAAe;AACnC,QAAM,YAAY,gBAAgB,EAAE,SAAS,OAAO,CAAC;AACrD,QAAM,SAAS,EAAE,SAAS,QAAQ,SAAS,UAAU;AAErD,QAAM,eAAe,MAAM,mBAAmB,EAAE,OAAO,CAAC;AAExD,QAAM,YAAY,IAAI,UAAU,EAAE,OAAO,CAAC;AAE1C,MAAI,oBAAoB,MAAM,QAAQ,QAAQ;AAE9C,QAAM,UAAU,YAAY;AAC1B,UAAM,kBAAkB;AACxB,UAAM,aAAa,KAAK;AACxB,UAAM,UAAU,KAAK;AACrB,cAAU,KAAK;AAAA,EACjB;AAEA,QAAM,WAAW,cAAc,EAAE,QAAQ,QAAQ,CAAC;AAElD,QAAM,aAAa,YAAY;AAAA,IAC7B,cAAc;AAAA,IACd,aAAa;AAAA,IACb,QAAQ,OAAO,WAAwB;AACrC,YAAM,kBAAkB;AAExB,UAAI,OAAO,WAAW,WAAW;AAC/B,kBAAU,MAAM;AAChB,gBAAQ,aAAa;AAErB,4BAAoB,MAAM,IAAI;AAAA,UAC5B;AAAA,UACA,OAAO,OAAO;AAAA,UACd,cAAc,MAAM;AAClB,qBAAS,EAAE,QAAQ,wBAAwB,MAAM,EAAE,CAAC;AAAA,UACtD;AAAA,UACA,mBAAmB,CAAC,UAAU;AAC5B,uBAAW,MAAM;AACjB,uBAAW,IAAI,EAAE,QAAQ,SAAS,MAAM,CAAC;AAAA,UAC3C;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AAEL,kBAAU,mBAAmB;AAC7B,4BAAoB,MAAM,QAAQ,QAAQ;AAAA,MAC5C;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,gBAAgB,MAAM,aAAa,MAAM;AAAA,IAC7C,OAAO;AAAA,IACP,SAAS,CAAC,gBAAgB;AACxB,iBAAW,MAAM;AACjB,iBAAW,IAAI,WAAW;AAAA,IAC5B;AAAA,EACF,CAAC;AAED,MAAI,cAAc,WAAW,SAAS;AACpC,UAAM,SAAS,EAAE,QAAQ,uBAAuB,MAAM,EAAE,CAAC;AACzD,WAAO;AAAA,EACT;AAEA,YAAU,OAAO;AAAA,IACf,MAAM;AAAA,IACN,YAAY,EAAE,aAAa,OAAO,GAAG,aAAa,cAAc,KAAK,EAAE;AAAA,EACzE,CAAC;AAED,aAAW,IAAI,aAAa;AAE5B,SAAO,YAAY;AACjB,eAAW,MAAM;AACjB,UAAM,QAAQ;AAAA,EAChB;AACF;;;A2DjHA,OAAOC,WAAU;AAajB,eAAsBC,OAAM,EAAE,WAAW,GAA+B;AACtE,QAAM,UAAU,aAAa,EAAE,WAAW,CAAC;AAE3C,QAAM,SAAS,aAAa,EAAE,OAAO,QAAQ,SAAS,CAAC;AAEvD,QAAM,CAAC,OAAO,OAAO,MAAM,IAAI,QAAQ,SAAS,KAAK,MAAM,GAAG,EAAE,IAAI,MAAM;AAC1E,MAAI,QAAQ,MAAO,UAAU,MAAM,QAAQ,IAAK;AAC9C,WAAO,MAAM;AAAA,MACX,SAAS;AAAA,MACT,KAAK,uDAAuD,KAAK,IAAI,KAAK;AAAA,IAC5E,CAAC;AACD,UAAM,OAAO,KAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,gBAAgBC,MAAK,SAAS,QAAQ,SAAS,QAAQ,UAAU;AACvE,SAAO,MAAM;AAAA,IACX,SAAS;AAAA,IACT,KAAK,8BAA8B,aAAa;AAAA,EAClD,CAAC;AAED,QAAM,UAAU,IAAI,eAAe;AACnC,QAAM,YAAY,gBAAgB,EAAE,SAAS,OAAO,CAAC;AACrD,QAAM,SAAS,EAAE,SAAS,QAAQ,SAAS,UAAU;AAErD,QAAM,eAAe,MAAM,mBAAmB,EAAE,OAAO,CAAC;AAExD,MAAI,oBAAoB,MAAM,QAAQ,QAAQ;AAE9C,QAAM,UAAU,YAAY;AAC1B,UAAM,kBAAkB;AACxB,UAAM,UAAU,KAAK;AAAA,EACvB;AAEA,QAAM,WAAW,cAAc,EAAE,QAAQ,QAAQ,CAAC;AAElD,QAAM,gBAAgB,MAAM,aAAa,MAAM,EAAE,OAAO,MAAM,CAAC;AAE/D,QAAM,aAAa,KAAK;AAExB,MAAI,cAAc,WAAW,SAAS;AACpC,UAAM,SAAS,EAAE,QAAQ,uBAAuB,MAAM,EAAE,CAAC;AACzD,WAAO;AAAA,EACT;AAEA,YAAU,OAAO;AAAA,IACf,MAAM;AAAA,IACN,YAAY,EAAE,aAAa,SAAS,GAAG,aAAa,cAAc,KAAK,EAAE;AAAA,EAC3E,CAAC;AAED,QAAM,EAAE,gBAAgB,eAAe,QAAQ,cAAc,IAC3D,cAAc;AAEhB,SAAO,UAAU,EAAE,GAAG,OAAO,SAAS,GAAG,cAAc;AAEvD,MAAI,eAAe,SAAS,UAAU;AACpC,UAAM,SAAS;AAAA,MACb,QAAQ;AAAA,MACR,MAAM;AAAA,IACR,CAAC;AACD,WAAO;AAAA,EACT;AAEA,MAAI,eAAe,kBAAkB,QAAW;AAC9C,UAAM,SAAS;AAAA,MACb,QAAQ;AAAA,MACR,MAAM;AAAA,IACR,CAAC;AACD,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,YAAY,QAAQ,cAAc,IAAI;AAC9C,QAAM,WAAW,IAAI,wBAAwB;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA,IAGA,YAAY;AAAA,EACd,CAAC;AAED,QAAM,gBAAgB,iBAAiB;AAAA,IACrC,MAAM;AAAA,IACN;AAAA;AAAA;AAAA;AAAA,IAIA,eAAe;AAAA,MACb,eAAe,eAAe;AAAA,IAChC;AAAA,IACA,IAAI,SAAS;AAAA,EACf,CAAC;AAED,QAAM,SAAS,MAAMC,cAAa,EAAE,eAAe,QAAQ,cAAc,CAAC;AAC1E,SAAO,WAAW;AAElB,sBAAoB,YAAY;AAC9B,UAAM,OAAO,KAAK;AAClB,UAAM,SAAS,KAAK;AAAA,EACtB;AAEA,SAAO;AACT;;;ACnHA,OAAOC,YAAU;AAUjB,eAAsBC,OAAM,EAAE,WAAW,GAA+B;AACtE,QAAM,UAAU,aAAa,EAAE,WAAW,CAAC;AAE3C,QAAM,SAAS,aAAa,EAAE,OAAO,QAAQ,SAAS,CAAC;AAEvD,QAAM,CAAC,OAAO,OAAO,MAAM,IAAI,QAAQ,SAAS,KAAK,MAAM,GAAG,EAAE,IAAI,MAAM;AAC1E,MAAI,QAAQ,MAAO,UAAU,MAAM,QAAQ,IAAK;AAC9C,WAAO,MAAM;AAAA,MACX,SAAS;AAAA,MACT,KAAK,uDAAuD,KAAK,IAAI,KAAK;AAAA,IAC5E,CAAC;AACD,UAAM,OAAO,KAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,gBAAgBC,OAAK,SAAS,QAAQ,SAAS,QAAQ,UAAU;AACvE,SAAO,MAAM;AAAA,IACX,SAAS;AAAA,IACT,KAAK,8BAA8B,aAAa;AAAA,EAClD,CAAC;AAED,QAAM,UAAU,IAAI,eAAe;AACnC,QAAM,YAAY,gBAAgB,EAAE,SAAS,OAAO,CAAC;AACrD,QAAM,SAAS,EAAE,SAAS,QAAQ,SAAS,UAAU;AAErD,QAAM,eAAe,MAAM,mBAAmB,EAAE,OAAO,CAAC;AAExD,MAAI,oBAAoB,MAAM,QAAQ,QAAQ;AAE9C,QAAM,UAAU,YAAY;AAC1B,UAAM,kBAAkB;AACxB,UAAM,UAAU,KAAK;AAAA,EACvB;AAEA,QAAM,WAAW,cAAc,EAAE,QAAQ,QAAQ,CAAC;AAElD,QAAM,gBAAgB,MAAM,aAAa,MAAM,EAAE,OAAO,MAAM,CAAC;AAE/D,QAAM,aAAa,KAAK;AAExB,MAAI,cAAc,WAAW,SAAS;AACpC,UAAM,SAAS,EAAE,QAAQ,uBAAuB,MAAM,EAAE,CAAC;AACzD,WAAO;AAAA,EACT;AAEA,YAAU,OAAO;AAAA,IACf,MAAM;AAAA,IACN,YAAY,EAAE,aAAa,SAAS,GAAG,aAAa,cAAc,KAAK,EAAE;AAAA,EAC3E,CAAC;AAED,sBAAoB,MAAM,IAAI;AAAA,IAC5B;AAAA,IACA,OAAO,cAAc;AAAA,IACrB,cAAc,MAAM;AAClB,eAAS,EAAE,QAAQ,wBAAwB,MAAM,EAAE,CAAC;AAAA,IACtD;AAAA,IACA,mBAAmB,MAAM;AACvB,eAAS,EAAE,QAAQ,8BAA8B,MAAM,EAAE,CAAC;AAAA,IAC5D;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;AlG5DA,OAAO,OAAO,EAAE,MAAM,aAAa,CAAC;AAEpC,IAAM,YAAY,QAAQ,cAAc,YAAY,GAAG,CAAC;AACxD,IAAM,kBAAkB,QAAQ,WAAW,oBAAoB;AAC/D,IAAM,cAAc,KAAK;AAAA,EACvBC,cAAa,iBAAiB,EAAE,UAAU,OAAO,CAAC;AACpD;AAEA,IAAM,SAAS,IAAI,QAAQ,QAAQ,EAChC,MAAM,qBAAqB,EAC3B,WAAW,cAAc,wBAAwB,EACjD,YAAY,KAAK,EACjB;AAAA,EACC;AAAA,EACA;AACF,EACC;AAAA,EACC;AAAA,EACA;AAAA,EACA;AACF,EACC;AAAA,EACC;AAAA,EACA;AACF,EACC;AAAA,EACC;AAAA,EACA;AACF,EACC,QAAQ,YAAY,SAAS,iBAAiB,yBAAyB,EACvE,cAAc,EAAE,mBAAmB,KAAK,CAAC,EACzC,qBAAqB,KAAK,EAC1B,mBAAmB,EACnB,wBAAwB,KAAK;AAMhC,IAAM,aAAa,IAAI,QAAQ,KAAK,EACjC,YAAY,iDAAiD,EAC7D,OAAO,qBAAqB,2BAA2B,QAAQ,KAAK,EACpE,OAAO,6BAA6B,+BAA+B,SAAS,EAC5E,OAAO,OAAO,GAAG,YAAY;AAC5B,QAAM,aAAa;AAAA,IACjB,GAAG,QAAQ,gBAAgB;AAAA,IAC3B,SAAS,QAAQ,KAAK;AAAA,EACxB;AACA,QAAM,IAAI,EAAE,WAAW,CAAC;AAC1B,CAAC;AAEH,IAAM,eAAe,IAAI,QAAQ,OAAO,EACrC,YAAY,6BAA6B,EACzC,OAAO,qBAAqB,2BAA2B,QAAQ,KAAK,EACpE,OAAO,6BAA6B,+BAA+B,SAAS,EAC5E,OAAO,OAAO,GAAG,YAAY;AAC5B,QAAM,aAAa;AAAA,IACjB,GAAG,QAAQ,gBAAgB;AAAA,IAC3B,SAAS,QAAQ,KAAK;AAAA,EACxB;AACA,QAAMC,OAAM,EAAE,WAAW,CAAC;AAC5B,CAAC;AAEH,IAAM,eAAe,IAAI,QAAQ,OAAO,EACrC,YAAY,sDAAsD,EAClE,OAAO,qBAAqB,2BAA2B,QAAQ,KAAK,EACpE,OAAO,6BAA6B,+BAA+B,SAAS,EAC5E,OAAO,OAAO,GAAG,YAAY;AAC5B,QAAM,aAAa;AAAA,IACjB,GAAG,QAAQ,gBAAgB;AAAA,IAC3B,SAAS,QAAQ,KAAK;AAAA,EACxB;AACA,QAAMC,OAAM,EAAE,WAAW,CAAC;AAC5B,CAAC;AAEH,IAAM,iBAAiB,IAAI,QAAQ,SAAS,EACzC,YAAY,6CAA6C,EACzD,OAAO,OAAO,GAAG,YAAY;AAC5B,QAAM,aAAa;AAAA,IACjB,GAAG,QAAQ,gBAAgB;AAAA,IAC3B,SAAS,QAAQ,KAAK;AAAA,EACxB;AACA,QAAM,QAAQ,EAAE,WAAW,CAAC;AAC9B,CAAC;AAsBH,OAAO,WAAW,UAAU;AAC5B,OAAO,WAAW,YAAY;AAC9B,OAAO,WAAW,YAAY;AAC9B,OAAO,WAAW,cAAc;AAYhC,MAAM,OAAO,WAAW;","names":["readFileSync","create","methods","params","readFileSync","path","GraphQLObjectType","GraphQLBoolean","GraphQLInt","GraphQLList","GraphQLString","GraphQLBoolean","GraphQLString","GraphQLInt","GraphQLList","GraphQLEnumType","GraphQLInt","GraphQLNonNull","GraphQLString","GraphQLNonNull","GraphQLString","GraphQLInt","GraphQLNonNull","GraphQLNonNull","GraphQLObjectType","getEventSelector","transport","symbol","resolve","resolve","_parameters","startBlockMaybeNan","startBlock","endBlockMaybeNan","endBlock","intervalMaybeNan","interval","columnName","tableName","column","file","path","path","file","buildResult","hash","readFileSync","path","totalBlocks","cachedBlocks","completedBlocks","progress","path","createHash","readFileSync","path","start","hash","createHash","packageJson","kill","path","packageJsonPath","readFileSync","os","os","existsSync","path","Box","Text","React","Text","React","React","Box","Text","ui","createHash","sql","prometheus","migrations","StaticMigrationProvider","migrationProvider","migrationProvider","finalizedCheckpoint","result","sql","isTable","prometheus","existsSync","path","sql","migrations","StaticMigrationProvider","migrationProvider","existsSync","mkdirSync","path","dirname","Migrator","WithSchemaPlugin","sql","prometheus","migrations","StaticMigrationProvider","migrationProvider","path","Migrator","WithSchemaPlugin","migrationProvider","finalizedCheckpoint","result","sql","scalarToSqlType","prometheus","existsSync","sql","column","columnName","query","rows","db","sql","create","row","sql","columnName","query","sql","MAX_BATCH_SIZE","rows","create","row","create","readFileSync","codeFrameColumns","parseStackTrace","path","create","kill","methods","create","kill","path","createServer","path","httpServer","resolve","start","start2","blockNumber","start","sql","checksumAddress","hexToBigInt","hexToNumber","sql","query","hexToNumber","hexToBigInt","checksumAddress","start","sql","checksumAddress","hexToBigInt","hexToNumber","hexToNumber","sql","buildFactoryChildAddressSelectExpression","query","hexToNumber","hexToBigInt","checksumAddress","start","BlockNotFoundError","numberToHex","createQueue","hexToNumber","resolve","queue","createQueue","logs","fromBlock","toBlock","traces","hash","hexToNumber","hexToNumber","hexToNumber","hash","create","start","hexToNumber","kill","hash","methods","start","kill","create","hexToBigInt","isHex","RETRY_COUNT","BASE_DURATION","isHex","hexToBigInt","hexToBigInt","hexToNumber","hexToBigInt","create","hexToNumber","hexToBigInt","kill","methods","kill","create","numberToHex","BlockNotFoundError","hash","namespaceInfo","createServer","handleReorg","start","existsSync","path","path","serve","path","createServer","path","start","path","readFileSync","start","serve"]}